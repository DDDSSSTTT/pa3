/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/lezer-python/dist/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/lezer-python/dist/index.cjs ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var lezer = __webpack_require__(/*! lezer */ "./node_modules/lezer/dist/index.cjs");

// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  printKeyword = 1,
  newline = 164,
  newlineBracketed = 165,
  newlineEmpty = 166,
  eof = 167,
  continueBody = 168,
  endBody = 169,
  ParenthesizedExpression = 21,
  TupleExpression = 48,
  ComprehensionExpression = 49,
  ArrayExpression = 53,
  ArrayComprehensionExpression = 56,
  DictionaryExpression = 57,
  DictionaryComprehensionExpression = 60,
  SetExpression = 61,
  SetComprehensionExpression = 62,
  compoundStatement = 231;

const newline$1 = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46;

const bracketed = [
  ParenthesizedExpression, TupleExpression, ComprehensionExpression, ArrayExpression, ArrayComprehensionExpression,
  DictionaryExpression, DictionaryComprehensionExpression, SetExpression, SetComprehensionExpression
], parentStatement = [compoundStatement];

const caches = new WeakMap;

// Per-input-stream indentation cache. `prev` maps indentation depths
// to the last position at which a statement indented to that depth
// was seen. There's an extra set of slots for the _current_
// indentation, since that needs to be available alongside a previous
// indentation position at the same level.
class Cache {
  constructor() {
    this.last = this.lastIndent = -1;
    this.prev = [];
  }

  get(pos) {
    if (this.last == pos) return this.lastIndent
    for (let i = 0; i < this.prev.length; i++) if (this.prev[i] == pos) return i
    return -1
  }

  set(pos, indent) {
    if (pos == this.last) return
    if (this.last > -1) this.setPrev(this.last, this.lastIndent);
    this.last = pos;
    this.lastIndent = indent;
  }

  setPrev(pos, indent) {
    while (this.prev.length < indent) this.prev.push(-1);
    this.prev[indent] = pos;
  }

  static for(input) {
    let found = caches.get(input);
    if (!found) caches.set(input, found = new Cache);
    return found
  }
}

const maxIndent = 50;

function getIndent(input, pos) {
  let cache = Cache.for(input), found = cache.get(pos);
  if (found > -1) return found

  // This shouldn't happen very often (or even at all) in normal
  // parsing, since the indentations are stored by the newline
  // tokenizer ahead of time. But it's kind of tricky to prove whether
  // that always happens in incremental parsing scenarios, so here's a
  // fallback anyway.
  let before = input.read(Math.max(0, pos - maxIndent), pos);
  let count = 0, start = before.length;
  for (; start > 0; start--) {
    let next = before.charCodeAt(start - 1);
    if (next == newline$1 || next == carriageReturn) break
  }
  for (let i = start; i < before.length; i++) {
    let ch = before.charCodeAt(i);
    if (ch == space) count++;
    else if (ch == tab) count += 8 - (count % 8);
    else break
  }
  cache.setPrev(pos, count);
  return count
}

const newlines = new lezer.ExternalTokenizer((input, token, stack) => {
  let next = input.get(token.start);
  if (next < 0) {
    token.accept(eof, token.start);
    return
  }
  if (next != newline$1 && next != carriageReturn) return
  if (stack.startOf(bracketed) != null) {
    token.accept(newlineBracketed, token.start + 1);
    return
  }
  let scan = token.start + 1, indent = 0;
  for (; scan < input.length; scan++) {
    let ch = input.get(scan);
    if (ch == space) indent++;
    else if (ch == tab) indent += 8 - (indent % 8);
    else if (ch == newline$1 || indent == carriageReturn || ch == hash) {
      token.accept(newlineEmpty, token.start + 1);
      return
    } else {
      break
    }
  }
  token.accept(newline, token.start + 1);
  Cache.for(input).set(scan, indent);
}, {contextual: true, fallback: true});

const bodyContinue = new lezer.ExternalTokenizer((input, token, stack) => {
  let parent = stack.startOf(parentStatement);
  let parentIndent = parent == null ? 0 : getIndent(input, parent);
  let indentHere = getIndent(input, token.start);
  token.accept(indentHere <= parentIndent ? endBody : continueBody, token.start);
}, {contextual: true, fallback: true});

const legacyPrint = new lezer.ExternalTokenizer((input, token) => {
  let pos = token.start;
  for (let print = "print", i = 0; i < print.length; i++, pos++)
    if (input.get(pos) != print.charCodeAt(i)) return
  let end = pos;
  if (/\w/.test(String.fromCharCode(input.get(pos)))) return
  for (;; pos++) {
    let next = input.get(pos);
    if (next == space || next == tab) continue
    if (next != parenOpen && next != dot && next != newline$1 && next != carriageReturn && next != hash)
      token.accept(printKeyword, end);
    return
  }
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,await:40, or:48, and:50, in:54, not:56, is:58, if:64, else:66, lambda:70, self:74, yield:90, from:92, async:100, for:102, None:154, True:156, False:156, del:170, pass:174, break:178, continue:182, return:186, raise:194, import:198, as:200, global:204, nonlocal:206, assert:210, elif:220, while:224, try:230, except:232, finally:234, with:238, def:242, class:252};
const parser = lezer.Parser.deserialize({
  version: 13,
  states: "!;[O`Q!LTOOO%fQ!LUO'#GcOOQ!LQ'#Cm'#CmOOQ!LQ'#Cn'#CnO'UQ!LSO'#ClO(zQ!LUO'#GbOOQ!LQ'#Gc'#GcOOQ!LQ'#DS'#DSOOQ!LQ'#Gb'#GbO)hQ!LSO'#CqO)xQ!LSO'#DcO*YQ!LSO'#DgOOQ!LQ'#Dt'#DtO*mOWO'#DtO*uO`O'#DtO*}OpO'#DuO+YO!bO'#DuO+eO#tO'#DuO+pO&jO'#DuO-rQ!LUO'#GSOOQ!LQ'#GS'#GSO'UQ!LSO'#GRO/UQ!LUO'#GROOQ!LQ'#E^'#E^O/mQ!LSO'#E_OOQ!LQ'#GQ'#GQO/wQ!LSO'#GPOOQ&FV'#GP'#GPO0SQ!LSO'#FQOOQ!LQ'#Ft'#FtO0XQ!LSO'#FPOOQ&FV'#H]'#H]OOQ&FV'#GO'#GOOOQ!LR'#FS'#FSQ`Q!LTOOO'UQ!LSO'#CoO0gQ!LSO'#CzO0nQ!LSO'#DOO1PQ!LSO'#GgO1aQ!LUO'#ERO'UQ!LSO'#ESOOQ!LQ'#EU'#EUOOQ!LQ'#EW'#EWOOQ!LQ'#EY'#EYO1uQ!LSO'#E[O2SQ!LSO'#E`O0SQ!LSO'#EbO2gQ!LUO'#EbO0SQ!LSO'#EeO/mQ!LSO'#EhO/mQ!LSO'#ElO/mQ!LSO'#EoO2rQ!LSO'#EqO2yQ!LSO'#EvO3UQ!LSO'#ErO/mQ!LSO'#EvO0SQ!LSO'#ExO0SQ!LSO'#E}OOQ!LQ'#Cc'#CcOOQ!LQ'#Cd'#CdOOQ!LQ'#Ce'#CeOOQ!LQ'#Cf'#CfOOQ!LQ'#Cg'#CgOOQ!LQ'#Ch'#ChOOQ!LQ'#Cj'#CjO'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O3ZQ!LSO'#DnOOQ!LQ,5:X,5:XO3nQ!LSO,5:[O3{Q#)WO,5:[O4QQ!LUO,59WO0gQ!LSO,59_O0gQ!LSO,59_O0gQ!LSO,59_O6pQ!LSO,59_O6uQ!LSO,59_O6|Q!LSO,59gO7TQ!LSO'#GbO8ZQ!LSO'#GaOOQ!LQ'#Ga'#GaOOQ!LQ'#DY'#DYO8rQ!LSO,59]O'UQ!LSO,59]O9QQ!LSO,59]O9VQ!LSO,5:QO'UQ!LSO,5:QOOQ!LQ,59},59}O9eQ!LSO,59}O9jQ!LSO,5:WO'UQ!LSO,5:WO'UQ!LSO,5:UOOQ!LQ,5:R,5:RO9{Q!LSO,5:RO:QQ!LSO,5:VOOOO'#F]'#F]O:VOWO,5:`OOQ!LQ,5:`,5:`OOOO'#F^'#F^O:_O`O,5:`O:gQ!LSO'#DvOOOO'#F_'#F_O:wOpO,5:aOOQ!LQ,5:a,5:aOOOO'#Fb'#FbO;SO!bO,5:aOOOO'#Fc'#FcO;_O#tO,5:aOOOO'#Fd'#FdO;jO&jO,5:aOOQ!LQ'#Fe'#FeO;uQ!LUO,5:eO>gQ!LUO,5<mO?QQ#4^O'#FfO?tQ!LUO,5<mOOQ!LQ,5:y,5:yO@]Q!LTO'#FmOAlQ!LSO,5;UOOQ&FV,5<k,5<kOAwQ!LUO'#HYOB`Q!LSO,5;lOOQ!LQ-E9r-E9rOOQ&FV,5;k,5;kO3PQ!LSO'#ExOOQ!LR-E9Q-E9QOBhQ!LUO,59ZODoQ!LUO,59fOEYQ!LSO'#GdOEeQ!LSO'#GdO0SQ!LSO'#GdOEpQ!LSO'#DQOExQ!LSO,59jOE}Q!LSO'#GhO'UQ!LSO'#GhO/mQ!LSO,5=ROOQ!LQ,5=R,5=RO/mQ!LSO'#D}OOQ!LQ'#EO'#EOOFlQ!LSO'#FgOF|Q!LSO,58zOG[Q!LSO,58zO)kQ!LSO,5:kOGaQ!LUO'#GjOOQ!LQ,5:n,5:nOOQ!LQ,5:v,5:vOGtQ!LSO,5:zOHVQ!LSO,5:|OOQ!LQ'#Fj'#FjOHeQ!LUO,5:|OHsQ!LSO,5:|OHxQ!LSO'#H[OOQ!LQ,5;P,5;POIWQ!LSO'#HXOOQ!LQ,5;S,5;SO3UQ!LSO,5;WO3UQ!LSO,5;ZOIiQ!LUO'#H^O'UQ!LSO'#H^OIsQ!LSO,5;]O2rQ!LSO,5;]O/mQ!LSO,5;bO0SQ!LSO,5;dOIxQ!LTO'#EmOKRQ&FXO,5;^ONjQ!LSO'#H_O3UQ!LSO,5;bONuQ!LSO,5;dONzQ!LSO,5;iO!#oQ!LUO1G.hO!#vQ!LUO1G.hO!&gQ!LUO1G.hO!&qQ!LUO1G.hO!)[Q!LUO1G.hO!)oQ!LUO1G.hO!*SQ!LUO1G.hO!,rQ!LSO'#GpO!-QQ!LUO'#GSO/mQ!LSO'#GpO!-[Q!LSO'#GoOOQ!LQ,5:Y,5:YO!-dQ!LSO,5:YO!-iQ!LSO'#GqO!-tQ!LSO'#GqO!.XQ!LSO1G/vOOQ!LQ'#Dr'#DrOOQ!LQ1G/v1G/vOOQ!LQ1G.y1G.yO!/XQ!LUO1G.yO!/`Q!LUO1G.yO0gQ!LSO1G.yO!/{Q!LSO1G/ROOQ!LQ'#DX'#DXO/mQ!LSO,59rOOQ!LQ1G.w1G.wO!0SQ!LSO1G/dO!0dQ!LSO1G/dO!0lQ!LSO1G/eO'UQ!LSO'#GiO!0qQ!LSO'#GiO!0vQ!LUO1G.wO!1WQ!LSO,59fO!2^Q!LSO'#FXO!2qQ!LSO,5=XO!2yQ!LSO1G/lO!3OQ!LUO1G/lOOQ!LQ1G/i1G/iO!3`Q!LSO'#FUO!4YQ!LSO,5=SO/mQ!LSO1G/pO!4wQ!LSO1G/rO!4|Q!LUO1G/rO!5^Q!LUO1G/pOOQ!LQ1G/m1G/mOOQ!LQ1G/q1G/qOOOO-E9Z-E9ZOOQ!LQ1G/z1G/zOOOO-E9[-E9[O!5nQ!LSO'#G|O/mQ!LSO'#G|O!5|Q!LSO,5:bOOOO-E9]-E9]OOQ!LQ1G/{1G/{OOOO-E9`-E9`OOOO-E9a-E9aOOOO-E9b-E9bOOQ!LQ-E9c-E9cO!6XQ!LUO1G2XO'UQ!LSO,5<QOOQ!LQ,5<Q,5<QOOQ!LQ-E9d-E9dOOQ!LQ,5<X,5<XOOQ!LQ-E9k-E9kOOQ&FV1G0p1G0pO0SQ!LSO'#FiO!6pQ!LUO,5=tOOQ!LQ1G1W1G1WO!7XQ!LSO1G1WOOQ!LQ'#DT'#DTO/mQ!LSO,5=OOOQ!LQ,5=O,5=OO!7^Q!LSO'#FTO!7lQ!LSO,59lO!7tQ!LSO1G/UO!8OQ!LUO,5=SOOQ!LQ1G2m1G2mOOQ!LQ,5:i,5:iO!8oQ!LSO'#GROOQ!LQ,5<R,5<ROOQ!LQ-E9e-E9eO!9QQ!LSO1G.fOOQ!LQ1G0V1G0VO!9`Q!LSO'#FWO!9sQ!LSO,5=UO/mQ!LSO1G0fO/mQ!LSO1G0fO0SQ!LSO1G0hOOQ!LQ-E9h-E9hO!:UQ!LSO1G0hO!:aQ!LSO1G0hO!:fQ!LSO'#FlO!:wQ!LSO,5=vO!;VQ!LSO'#FhO!;pQ!LSO,5=sO!<RQ&FXO1G0rO!?gQ&FXO1G0uO!BxQ!LSO'#FpO!CVQ!LSO,5=xO!C_Q!LUO,5=xO/mQ!LSO1G0wO!CiQ!LSO1G0wO3UQ!LSO1G0|ONuQ!LSO1G1OOOQ&FV,5;X,5;XO!CnQ!LTO,5;XO!EaQ&FXO1G0xO!HxQ!LSO'#FqO3UQ!LSO1G0xO3UQ!LSO1G0xO!IVQ!LSO'#FrO!IgQ!LSO,5=yO0SQ!LSO,5=yOOQ&FV1G0|1G0|O!JQQ!LSO'#EzO!JXQ#)WO1G1OOOQ&FV1G1T1G1TO3UQ!LSO1G1TOOQ!LQ,5=[,5=[OOQ!LQ'#Do'#DoO/mQ!LSO,5=[O!JaQ!LSO'#FZO!JwQ!LSO,5=ZOOQ!LQ1G/t1G/tO!KPQ!LSO'#F[O!KdQ!LSO,5=]O!KlQ!LSO,5=]O!LPQ!LSO,5=]O!LaQ!LSO,5=]OOQ!LQ7+%b7+%bOOQ!LQ7+$e7+$eO!7tQ!LSO7+$mO!NSQ!LSO1G.yO!NZQ!LSO1G.yOOQ!LQ1G/^1G/^OOQ!LQ,5;q,5;qO'UQ!LSO,5;qOOQ!LQ7+%O7+%OO!NbQ!LSO7+%OOOQ!LQ-E9T-E9TOOQ!LQ7+%P7+%PO!NrQ!LSO,5=TO'UQ!LSO,5=TOOQ!LQ7+$c7+$cO!NwQ!LSO7+%OO# PQ!LSO7+%POOQ!LQ,5;s,5;sO'UQ!LSO,5;sOOQ!LQ-E9V-E9VOOQ!LQ7+%W7+%WO# UQ!LSO1G2sO# ^Q!LSO7+%WOOQ!LQ,5;p,5;pO'UQ!LSO,5;pOOQ!LQ-E9S-E9SO# cQ!LSO7+%[OOQ!LQ7+%^7+%^O# qQ!LSO1G2nO#!`Q!LSO7+%^O#!eQ!LSO'#FYO#!xQ!LSO1G2tO##QQ!LSO7+%[O##VQ!LSO'#F`O##pQ!LSO,5=hO##pQ!LSO,5=hO#$OOMhO'#DxO#$ZOQO'#G}OOOO1G/|1G/|O#$`Q!LSO1G/|O#$hQ!LUO1G1lOOQ!LQ,5<T,5<TOOQ!LQ-E9g-E9gOOQ!LQ7+&r7+&rOOQ!LQ1G2j1G2jOOQ!LQ,5;o,5;oOOQ!LQ-E9R-E9ROOQ!LQ7+$p7+$pO#%RQ!LSO'#FfO#%oQ!LSO,5<mO#&QQ!LUO,5;rOOQ!LQ-E9U-E9UOOQ!LQ7+&Q7+&QO#&eQ!LSO7+&QOOQ!LQ7+&S7+&SO#&sQ!LSO'#HZO0SQ!LSO7+&SO#'XQ!LSO7+&SOOQ!LQ,5<W,5<WOOQ!LQ-E9j-E9jOOQ!LQ,5<S,5<SOOQ!LQ-E9f-E9fO#'dQ&FXO7+&^O!HxQ!LSO'#FoO3UQ!LSO7+&^O3UQ!LSO7+&aO#*xQ!LUO,5<[O'UQ!LSO,5<[OOQ!LQ-E9n-E9nO#+SQ!LSO1G3dO3UQ!LSO7+&cO/mQ!LSO7+&cOOQ&FV7+&h7+&hO!JXQ#)WO7+&jO#+[Q&FWO1G0sOOQ&FV-E9o-E9oO3UQ!LSO7+&dO3UQ!LSO7+&dOOQ&FV,5<],5<]O#+gQ!LSO,5<]OOQ&FV7+&d7+&dO#+rQ&FXO7+&dO#/TQ!LSO,5<^OOQ!LQ-E9p-E9pO#/`Q!LSO1G3eO#/hQ!LSO'#HaO#/vQ!LSO'#HaO0SQ!LSO'#HaOOQ!LQ'#Ha'#HaO#0RQ!LSO'#H`OOQ!LQ,5;f,5;fO#0ZQ!LSO,5;fO/mQ!LSO'#E|OOQ&FV7+&j7+&jO3UQ!LSO7+&jOOQ&FV7+&o7+&oOOQ!LQ1G2v1G2vOOQ!LQ,5;u,5;uOOQ!LQ-E9X-E9XO#0`Q!LSO,5;vO#0kQ!LSO,5;vOOQ!LQ-E9Y-E9YO#1OQ!LSO1G2wO#1WQ!LSO1G2wO#1hQ!LSO1G2wO#1OQ!LSO1G2wOOQ!LQ<<HX<<HXO#1sQ!LUO1G1]OOQ!LQ<<Hj<<HjP#1}Q!LSO'#FVO6|Q!LSO1G2oO#2[Q!LSO1G2oO#2aQ!LSO<<HjOOQ!LQ<<Hk<<HkO#2qQ!LUO1G1_OOQ!LQ<<Hr<<HrO#2{Q!LUO1G1[O#3lQ!LSO7+(`O#3tQ!LSO<<HvOOQ!LQ<<Hx<<HxO#3yQ!LSO,5;tO'UQ!LSO,5;tOOQ!LQ-E9W-E9WOOQ!LQ<<Hv<<HvOOQ!LQ,5;z,5;zO/mQ!LSO,5;zOOQ!LQ-E9^-E9^O#4OQ!LSO1G3SOOOO'#Fa'#FaO#4^OMhO,5:dOOOO,5=i,5=iOOOO7+%h7+%hO#4iQ!LSO1G2XO/mQ!LSO<<IlO#4zQ!LSO'#FkO#5`Q!LSO,5=uO0SQ!LSO,5=uO#5qQ!LSO<<InOOQ!LQ<<In<<InO0SQ!LSO<<InOOQ&FV-E9m-E9mO3UQ!LSO<<IxOOQ&FV,5<Z,5<ZO3UQ!LSO,5<ZOOQ&FV<<Ix<<IxOOQ&FV<<I{<<I{O#5vQ!LUO1G1vO#6QQ&FXO<<I}O3UQ!LSO<<I}OOQ&FV<<JU<<JUO3UQ!LSO<<JUO!CnQ!LTO'#FnO#9cQ&FWO7+&_OOQ&FV7+&_7+&_OOQ&FV<<JO<<JOO#9nQ&FXO<<JOOOQ&FV1G1w1G1wO0SQ!LSO1G1wO3UQ!LSO<<JOO0SQ!LSO1G1xO#=PQ!LSO7+)POOQ!LQ'#E{'#E{O/mQ!LSO,5={O#=XQ!LSO,5={OOQ!LQ,5={,5={O#=dQ!LSO'#FsO#=nQ!LSO,5=zOOQ!LQ1G1Q1G1QOOQ!LQ,5;h,5;hO#=vQ!LSO1G1bO#>ZQ!LSO1G1bO#>kQ!LSO1G1bO#>vQ!LSO7+(cO#>vQ!LSO7+(cO#?OQ!LSO7+(cO#?`Q!LSO7+(ZO6|Q!LSO7+(ZOOQ!LQAN>UAN>UOOQ!LQAN>bAN>bO/mQ!LSO1G1`O#?yQ!LUO1G1`OOQ!LQ1G1f1G1fOOOO-E9_-E9_OOQ!LQAN?WAN?WO#@TQ!LSO,5<VOOQ!LQ-E9i-E9iO#@iQ!LSO1G3aOOQ!LQAN?YAN?YO#@zQ!LSOAN?YOOQ&FVAN?dAN?dOOQ&FV1G1u1G1uO3UQ!LSOAN?iO#APQ&FXOAN?iOOQ&FVAN?pAN?pOOQ&FU,5<Y,5<YOOQ&FU-E9l-E9lOOQ&FV<<Iy<<IyO3UQ!LSOAN?jO3UQ!LSO7+'cOOQ&FVAN?jAN?jOOQ!LQ7+'d7+'dOOQ!LQ1G3g1G3gO/mQ!LSO1G3gOOQ!LQ,5<_,5<_OOQ!LQ-E9q-E9qO#DbQ!LSO7+&|O#DrQ!LSO7+&|OOQ!LQ7+&|7+&|O#D}Q!LSO<<K}O#D}Q!LSO<<K}O#EVQ!LSO'#GkOOQ!LQ<<Ku<<KuO#EaQ!LSO<<KuOOQ!LQ7+&z7+&zO0SQ!LSO1G1qO#EzQ!LSO7+({OOQ!LQG24tG24tOOQ&FVG25TG25TO3UQ!LSOG25TOOQ&FVG25UG25UOOQ&FV<<J}<<J}OOQ!LQ7+)R7+)ROOQ!LQ<<Jh<<JhO#F]Q!LSO<<JhO#FmQ!LSOANAiO#FuQ!LSO'#GlOOQ!LQ'#Gl'#GlO0nQ!LSO'#DbO#G`Q!LSO,5=VOOQ!LQANAaANAaOOQ!LQ7+']7+']OOQ&FVLD*oLD*oOOQ!LQAN@SAN@SO#GwQ!LSO,59|OOQ!LQ1G2q1G2qO#EVQ!LSO1G/hOOQ!LQ7+%S7+%SO6|Q!LSO'#CzO6|Q!LSO,59_O6|Q!LSO,59_O6|Q!LSO,59_O#G|Q!LUO,5<mO6|Q!LSO1G.yO/mQ!LSO1G/UO/mQ!LSO7+$mO'UQ!LSO'#GRO#HaQ!LSO,59_O#HfQ!LSO,59_O#HmQ!LSO,59jO#HrQ!LSO1G/RO0nQ!LSO'#DOO6|Q!LSO,59g",
  stateData: "#IT~O$qOS$lOS$kOSQOS~OPhOTeOdsOfXOltOp!SOsuOudO}vO!O!PO!S!VO!T!UO!WYO![ZO!gdO!ndO!odO!pdO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#d!TO#g!WO#k!XO#m!YO#r!ZO#ulO$jqO$|QO$}QO%RRO%SVO%g[O%h]O%k^O%n_O%t`O%waO%ybO~OT!aO]!aO_!bOf!jO!W!lO!e!mO$w![O$x!]O$y!^O$z!_O${!_O$|!`O$}!`O%O!aO%P!aO%Q!aO~Oh%VXi%VXj%VXk%VXl%VXm%VXp%VXx%VXy%VX!t%VX#_%VX$j%VX$m%VX%X%VX!P%VX!S%VX!T%VX%Y%VX!X%VX!]%VX!O%VX#W%VXq%VX!k%VX~P$bOdsOfXOudO!WYO![ZO!gdO!ndO!odO!pdO$|QO$}QO%RRO%SVO%g[O%h]O%k^O%n_O%t`O%waO%ybO~Ox%UXy%UX#_%UX$j%UX$m%UX%X%UX~Oh!pOi!qOj!oOk!oOl!rOm!sOp!tO!t%UX~P(fOT!zOl,qOs-OO}vO~P'UOT!}Ol,qOs-OO!X#OO~P'UOT#RO_#SOl,qOs-OO!]#TO~P'UO%i#WO%j#YO~O%l#ZO%m#YO~O![#]O%o#^O%s#`O~O![#]O%u#aO%v#`O~O![#]O%j#`O%x#cO~O![#]O%m#`O%z#eO~OT$vX]$vX_$vXf$vXh$vXi$vXj$vXk$vXl$vXm$vXp$vXx$vX!W$vX!e$vX$w$vX$x$vX$y$vX$z$vX${$vX$|$vX$}$vX%O$vX%P$vX%Q$vX!P$vX!S$vX!T$vX~O%g[O%h]O%k^O%n_O%t`O%waO%ybOy$vX!t$vX#_$vX$j$vX$m$vX%X$vX%Y$vX!X$vX!]$vX!O$vX#W$vXq$vX!k$vX~P+{Ox#jOy$uX!t$uX#_$uX$j$uX$m$uX%X$uX~Ol,qOs-OO~P'UO#_#mO$j#oO$m#oO~O%SVO~O!S#tO#m!YO#r!ZO#ulO~OltO~P'UOT#yO_#zOu#xO%SVOytP~OT$OOl,qOs-OO!O$PO~P'UOy$RO!t$WO%X$SO#_!uX$j!uX$m!uX~OT$OOl,qOs-OO~P'UOl,qOs-OO#_#SX$j#SX$m#SX~P'UO!e$^O!n$^O%SVO~OT$hO~P'UO!T$jO#k$kO#m$lO~Oy$mO~OT$|O_$|Ol,qOs-OO!P%OO~P'UOl,qOs-OOy%RO~P'UO%f%TO~O_!bOf!jO!W!lO!e!mOT`a]`ah`ai`aj`ak`al`am`ap`ax`ay`a!t`a#_`a$j`a$m`a$w`a$x`a$y`a$z`a${`a$|`a$}`a%O`a%P`a%Q`a%X`a!P`a!S`a!T`a%Y`a!X`a!]`a!O`a#W`aq`a!k`a~Ok%YO~Ol%YO~P'UOl,qO~P'UOh,sOi,tOj,rOk,rOl,zOm,{Op-PO!P%UX!S%UX!T%UX%Y%UX!X%UX!]%UX!O%UX#W%UX!k%UX~P(fO%Y%[Ox%TX!P%TX!S%TX!T%TX!X%TXy%TX~Ox%_O!P%^O!S%cO!T%bO~O!P%^O~Ox%fO!S%cO!T%bO!X%aX~O!X%jO~Ox%kOy%mO!S%cO!T%bO!]%[X~O!]%qO~O!]%rO~O%i#WO%j%tO~O%l#ZO%m%tO~OT%wOl,qOs-OO}vO~P'UO![#]O%o#^O%s%zO~O![#]O%u#aO%v%zO~O![#]O%j%zO%x#cO~O![#]O%m%zO%z#eO~OT!ma]!ma_!maf!mah!mai!maj!mak!mal!mam!map!max!may!ma!W!ma!e!ma!t!ma#_!ma$j!ma$m!ma$w!ma$x!ma$y!ma$z!ma${!ma$|!ma$}!ma%O!ma%P!ma%Q!ma%X!ma!P!ma!S!ma!T!ma%Y!ma!X!ma!]!ma!O!ma#W!maq!ma!k!ma~P#yOx#jOy$ua!t$ua#_$ua$j$ua$m$ua%X$ua~P$bOT&QOltOsuOx$YXy$YX!t$YX#_$YX$j$YX$m$YX%X$YX~P'UOx#jOy$ua!t$ua#_$ua$j$ua$m$ua%X$ua~OPhOTeOltOsuO}vO!O!PO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#_$aX$j$aX$m$aX~P'UO#_#mO$j&VO$m&VO~O!e&WOf%|X$j%|X#W%|X#_%|X$m%|X#V%|X~Of!jO$j&YO~Ohcaicajcakcalcamcapcaxcayca!tca#_ca$jca$mca%Xca!Pca!Sca!Tca%Yca!Xca!]ca!Oca#Wcaqca!kca~P$bOpnaxnayna#_na$jna$mna%Xna~Oh!pOi!qOj!oOk!oOl!rOm!sO!tna~PDWO%X&[Ox%WXy%WX~O%SVOx%WXy%WX~Ox&_OytX~Oy&aO~Ox%kO#_%[X$j%[X$m%[X!P%[Xy%[X!]%[X!k%[X%X%[X~OT,yOl,qOs-OO}vO~P'UO%X$SO#_Sa$jSa$mSa~O%X$SO~Ox&jO#_%^X$j%^X$m%^Xk%^X~P$bOx&mO!O&lO#_#Sa$j#Sa$m#Sa~O#W&nO#_#Ua$j#Ua$m#Ua~O!e$^O!n$^O#V&pO%SVO~O#V&pO~Ox&rO#_&OX$j&OX$m&OX~Ox&tO#_%{X$j%{X$m%{Xy%{X~Ox&xOk&QX~P$bOk&{O~OPhOTeOltOsuO}vO!O!PO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO$j'QO~P'UOq'UO#h'SO#i'TOP#faT#fad#faf#fal#fap#fas#fau#fa}#fa!O#fa!S#fa!T#fa!W#fa![#fa!g#fa!n#fa!o#fa!p#fa!w#fa!y#fa!{#fa!}#fa#P#fa#T#fa#V#fa#Y#fa#Z#fa#]#fa#d#fa#g#fa#k#fa#m#fa#r#fa#u#fa$i#fa$j#fa$|#fa$}#fa%R#fa%S#fa%g#fa%h#fa%k#fa%n#fa%t#fa%w#fa%y#fa$m#fa$n#fa$o#fa~Ox'VO#W'XOy&RX~Of'ZO~Of!jOy$mO~OT!aO]!aO_!bOf!jO!W!lO!e!mO$y!^O$z!_O${!_O$|!`O$}!`O%O!aO%P!aO%Q!aOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O$x!]O~P! SO$xUi~P! SOT!aO]!aO_!bOf!jO!W!lO!e!mO$|!`O$}!`O%O!aO%P!aO%Q!aOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O$z!_O${!_O~P!#}O$zUi${Ui~P!#}O_!bOf!jO!W!lO!e!mOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi$zUi${Ui$|Ui$}Ui%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~OT!aO]!aO%O!aO%P!aO%Q!aO~P!&{OTUi]Ui%OUi%PUi%QUi~P!&{Of!jO!W!lO!e!mOTUi]Ui_UihUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi$zUi${Ui$|Ui$}Ui%OUi%PUi%QUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O!S%cO!T%bOx%dX!P%dX~O%X'`O%Y'`O~P+{Ox'bO!P%cX~O!P'dO~Ox'eOy'gO!X%eX~Ol,qOs-OOx'eOy'hO!X%eX~P'UO!X'jO~Oj!oOk!oOl!rOm!sOhgipgixgiygi!tgi#_gi$jgi$mgi%Xgi~Oi!qO~P!.^Oigi~P!.^Oh,sOi,tOj,rOk,rOl,zOm,{O~Oq'lO~P!/gOT'qOl,qOs-OO!P'rO~P'UOx'sO!P'rO~O!P'uO~O!T'wO~Ox'sO!P'xO!S%cO!T%bO~P$bOh,sOi,tOj,rOk,rOl,zOm,{O!Pna!Sna!Tna%Yna!Xna!]na!Ona#Wnaqna!kna~PDWOT'|Ol,qOs-OOx#{X!X#{X~P'UOx%fO!X%aa~O!X(OO~Ox%fO!S%cO!T%bO!X%aa~P$bOT(SOl,qOs-OOx#xX!]#xX#_#xX$j#xX$m#xX!P#xXy#xX!k#xX%X#xX~P'UOx%kO!]%[a#_%[a$j%[a$m%[a!P%[ay%[a!k%[a%X%[a~O!](VO~Ox%kO!S%cO!T%bO!]%[a~P$bOx(YO!S%cO!T%bO!]%ba~P$bOx(]Oy%pX!]%pX!k%pX~Oy(`O!](bO!k(cO~Ox#jOy$ui!t$ui#_$ui$j$ui$m$ui%X$ui~O!e&WOf%|a$j%|a#W%|a#_%|a$m%|a#V%|a~O$j(gO~OT#yO_#zOu#xO%SVO~Ox&_Oyta~OltOsuO~P'UOx%kO#_%[a$j%[a$m%[a!P%[ay%[a!]%[a!k%[a%X%[a~P$bOx(lO#_$uX$j$uX$m$uX%X$uX~O%X$SO#_Si$jSi$mSi~Ox#zX#_#zX$j#zX$m#zXk#zX~P'UOx&jO#_%^a$j%^a$m%^ak%^a~OT(rOf(tO%SVO~O#V(uO~O%SVOx$`X#_$`X$j$`X$m$`X~Ox&rO#_&Oa$j&Oa$m&Oa~Ol,qOs-OOx$[X#_$[X$j$[X$m$[Xy$[X~P'UOx&tO#_%{a$j%{a$m%{ay%{a~Oq(|O#b({OP#`iT#`id#`if#`il#`ip#`is#`iu#`i}#`i!O#`i!S#`i!T#`i!W#`i![#`i!g#`i!n#`i!o#`i!p#`i!w#`i!y#`i!{#`i!}#`i#P#`i#T#`i#V#`i#Y#`i#Z#`i#]#`i#d#`i#g#`i#k#`i#m#`i#r#`i#u#`i$i#`i$j#`i$|#`i$}#`i%R#`i%S#`i%g#`i%h#`i%k#`i%n#`i%t#`i%w#`i%y#`i$m#`i$n#`i$o#`i~Oq(}OP#ciT#cid#cif#cil#cip#cis#ciu#ci}#ci!O#ci!S#ci!T#ci!W#ci![#ci!g#ci!n#ci!o#ci!p#ci!w#ci!y#ci!{#ci!}#ci#P#ci#T#ci#V#ci#Y#ci#Z#ci#]#ci#d#ci#g#ci#k#ci#m#ci#r#ci#u#ci$i#ci$j#ci$|#ci$}#ci%R#ci%S#ci%g#ci%h#ci%k#ci%n#ci%t#ci%w#ci%y#ci$m#ci$n#ci$o#ci~OT)POk$dXx$dX~P'UOx&xOk&Qa~Ox&xOk&Qa~P$bOk)TO~OPhOTeOltOp!SOsuO}vO!O!PO!S!VO!T!UO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#d!TO#g!WO#k!XO#m!YO#r!ZO#ulO~P'UOq)ZO#h'SO#i)YOP#fiT#fid#fif#fil#fip#fis#fiu#fi}#fi!O#fi!S#fi!T#fi!W#fi![#fi!g#fi!n#fi!o#fi!p#fi!w#fi!y#fi!{#fi!}#fi#P#fi#T#fi#V#fi#Y#fi#Z#fi#]#fi#d#fi#g#fi#k#fi#m#fi#r#fi#u#fi$i#fi$j#fi$|#fi$}#fi%R#fi%S#fi%g#fi%h#fi%k#fi%n#fi%t#fi%w#fi%y#fi$m#fi$n#fi$o#fi~Ol,qOs-OOy$mO~P'UOl,qOs-OOx$fXy$fX~P'UOx'VOy&Ra~OT)dO_)eOu)cO%O)fO%SVO~O!P)hO~P!IoOy$mO&U)jO~OT$|O_$|Ol,qOs-OOx#}X!P#}X~P'UOx'bO!P%ca~Ol,qOs-OOy)rOx$OX!X$OX~P'UOx'eO!X%ea~Ol,qOs-OOx'eOy)uO!X%ea~P'UOl,qOs-OOx'eO!X%ea~P'UOx'eOy)uO!X%ea~Oj,rOk,rOl,zOm,{Ohgipgixgi!Pgi!Sgi!Tgi%Ygi!Xgiygi!]gi#_gi$jgi$mgi!Ogi#Wgiqgi!kgi%Xgi~Oi,tO~P!LlOigi~P!LlOT'qOl,qOs-OO!P)zO~P'UOk)|O~Ox*OO!P)zO~O!P*PO~Ox%fO!X%ai~O!X*RO~Ox(YO!S%cO!T%bO!]%bi~Ox%kO!]%[i#_%[i$j%[i$m%[i!P%[iy%[i!k%[i%X%[i~O!]*VO~O_*XOl,qOs-OOx#|X!]#|X~P'UOx(YO!]%bi~O!]*ZO~OT*]Ol,qOs-OOx$SXy$SX!]$SX!k$SX~P'UOx(]Oy%pa!]%pa!k%pa~O![#]O%r*`O!]!lX~O!]*bO~Oy(`O!]*cO~Ox$Yiy$Yi!t$Yi#_$Yi$j$Yi$m$Yi%X$Yi~P$bOT&QOl,qOs-OOx$YX#_$YX$j$YX$m$YX%X$YX~P'UOx(lO#_$ua$j$ua$m$ua%X$ua~Ox#za#_#za$j#za$m#zak#za~P$bOx*eO#_#Sq$j#Sq$m#Sq~Ox*fO#W*hO#_%}X$j%}X$m%}X!P%}X~OT*jOf*kO%SVO~Oq*mO#b({OP#`qT#`qd#`qf#`ql#`qp#`qs#`qu#`q}#`q!O#`q!S#`q!T#`q!W#`q![#`q!g#`q!n#`q!o#`q!p#`q!w#`q!y#`q!{#`q!}#`q#P#`q#T#`q#V#`q#Y#`q#Z#`q#]#`q#d#`q#g#`q#k#`q#m#`q#r#`q#u#`q$i#`q$j#`q$|#`q$}#`q%R#`q%S#`q%g#`q%h#`q%k#`q%n#`q%t#`q%w#`q%y#`q$m#`q$n#`q$o#`q~Ok$dax$da~P$bOx&xOk&Qi~O$m*yO$n*wO$o*yO~Ox*}Oy$mO#W*}O~O#i+OOP#fqT#fqd#fqf#fql#fqp#fqs#fqu#fq}#fq!O#fq!S#fq!T#fq!W#fq![#fq!g#fq!n#fq!o#fq!p#fq!w#fq!y#fq!{#fq!}#fq#P#fq#T#fq#V#fq#Y#fq#Z#fq#]#fq#d#fq#g#fq#k#fq#m#fq#r#fq#u#fq$i#fq$j#fq$|#fq$}#fq%R#fq%S#fq%g#fq%h#fq%k#fq%n#fq%t#fq%w#fq%y#fq$m#fq$n#fq$o#fq~O#W+POx$fay$fa~Ox'VOy&Ri~Oy$RO%X+ROx&TX!P&TX~O%SVOx&TX!P&TX~Ox+VO!P&SX~O!P+XO~Oy+ZOx$Oa!X$Oa~Ol,qOs-OOy+[Ox$Oa!X$Oa~P'UOx'eO!X%ei~Ol,qOs-OOx'eO!X%ei~P'UOx'eOy+`O!X%ei~Ox#yi!P#yi~P$bOT'qOl,qOs-OO~P'UOk+bO~OT'qOl,qOs-OO!P+cO~P'UOx#{i!X#{i~P$bOx#xi!]#xi#_#xi$j#xi$m#xi!P#xiy#xi!k#xi%X#xi~P$bOx(YO!]%bq~O!]+dO~Oy+eO~Ox(]Oy%pi!]%pi!k%pi~O![#]O%r*`O!]!la~Ox(lO#_$ui$j$ui$m$ui%X$ui~O%SVOx$_X#_$_X$j$_X$m$_X!P$_X~Ox*fO#_%}a$j%}a$m%}a!P%}a~O!P+mO~Ok$dix$di~P$bOq+qOP#eyT#eyd#eyf#eyl#eyp#eys#eyu#ey}#ey!O#ey!S#ey!T#ey!W#ey![#ey!g#ey!n#ey!o#ey!p#ey!w#ey!y#ey!{#ey!}#ey#P#ey#T#ey#V#ey#Y#ey#Z#ey#]#ey#d#ey#g#ey#k#ey#m#ey#r#ey#u#ey$i#ey$j#ey$|#ey$}#ey%R#ey%S#ey%g#ey%h#ey%k#ey%n#ey%t#ey%w#ey%y#ey$m#ey$n#ey$o#ey~O$m+vO$n*wO$o+vO~O#i+wOP#fyT#fyd#fyf#fyl#fyp#fys#fyu#fy}#fy!O#fy!S#fy!T#fy!W#fy![#fy!g#fy!n#fy!o#fy!p#fy!w#fy!y#fy!{#fy!}#fy#P#fy#T#fy#V#fy#Y#fy#Z#fy#]#fy#d#fy#g#fy#k#fy#m#fy#r#fy#u#fy$i#fy$j#fy$|#fy$}#fy%R#fy%S#fy%g#fy%h#fy%k#fy%n#fy%t#fy%w#fy%y#fy$m#fy$n#fy$o#fy~Ox'VOy&Rq~O%X+ROx&Ta!P&Ta~Ox$gX!P$gX~P!IoOx+VO!P&Sa~Ol,qOs-OOy,POx$Oi!X$Oi~P'UOl,qOs-OOx$Oi!X$Oi~P'UOy,POx$Oi!X$Oi~Ox'eO!X%eq~Ol,qOs-OOx'eO!X%eq~P'UOp,UO!S%cO!T%bO!P%]q!X%]q!]%]qx%]q~P!/gOx#|i!]#|i~P$bO#W,YOx$_a#_$_a$j$_a$m$_a!P$_a~Ox*fO#_%}i$j%}i$m%}i!P%}i~O!P,[O~Oq,^OP#e!RT#e!Rd#e!Rf#e!Rl#e!Rp#e!Rs#e!Ru#e!R}#e!R!O#e!R!S#e!R!T#e!R!W#e!R![#e!R!g#e!R!n#e!R!o#e!R!p#e!R!w#e!R!y#e!R!{#e!R!}#e!R#P#e!R#T#e!R#V#e!R#Y#e!R#Z#e!R#]#e!R#d#e!R#g#e!R#k#e!R#m#e!R#r#e!R#u#e!R$i#e!R$j#e!R$|#e!R$}#e!R%R#e!R%S#e!R%g#e!R%h#e!R%k#e!R%n#e!R%t#e!R%w#e!R%y#e!R$m#e!R$n#e!R$o#e!R~Ol,qOs-OOx$Oq!X$Oq~P'UOy,cOx$Oq!X$Oq~Ox'eO!X%ey~Ol,qOs,gO~P'UOp,UO!S%cO!T%bO!P%]y!X%]y!]%]yx%]y~P!/gOx*fO#_%}q$j%}q$m%}q!P%}q~Ol,qOs-OOx$Oy!X$Oy~P'UOx'eO!X%e!R~Op%`X!P%`X!S%`X!T%`X!X%`X!]%`Xx%`X~P!/gOp,UO!S%cO!T%bO!P%_a!X%_a!]%_ax%_a~Oy,oO~Ox(lO#_$ua$j$ua$m$ua%X$ua~P$bOk,vO~Ol,vO~P'UOy,wO~Oq,xO~P!/gO%h%k%w%y%g%n%t%S%g~",
  goto: "!&h&UPPPP&VP&_(|)d){*e+O+jP,VP&_,t,t&_P&_P/cPPPPPP/c1bPP1bP2}P3W7`PP7c7o7rPPP&_&_PP8O&_PP&_&_PP&_&_&_&_8S8x&_P8{P9O9O;qP<V&_PPP<Z<a&VP&V&VP&VP&VP&VP&VP&V&V&VP&VPP&VPP&VP<gP<n<tP<nP<n<nPPP<nP>mP>v>|?S>mP<n?YP?a?g?m?y@T@Z@e@o@uAcAiAoAuBPBVB]BcBiBoCRC]CcCiCoCyDPDVD]DcDmDsD}ETPPPPPPPPPE^EhEqE{FWPPPPPPPPPPPPI}JgNU!!qPP!!y!#X!#b!$W!#}!$a!$g!$j!$m!$p!$vPPPPPPPPPP!$y!$|PPPPPPPPP!%S!%`!%l!%x!%{!&R!&X!&_!&b]iOr#m$m'Q*w&XdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-Py!cP#i#v$X$g%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u{!dP#i#v$X$g$s%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u}!eP#i#v$X$g$s$t%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!P!fP#i#v$X$g$s$t$u%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!R!gP#i#v$X$g$s$t$u$v%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!T!hP#i#v$X$g$s$t$u$v$w%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!X!iP!n#i#v$X$g$s$t$u$v$w$x%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u&XSOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-P$yUOXYZhrtv|}!R!S!T!X!j!l!o!p!q!s!t#]#j#m$P$R$T$W$k$m$|%R%Y%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){)|*O*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,{-P$TWOXYZhrv|}!R!S!T!X!j!l#]#j#m$P$R$T$W$k$m$|%R%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){*O*]*e*w+S+Z+[+`+e+|,P,c,w,xQ#|uQ,m,gR,|-O&SdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-PW#pl!O!P$_W#xu&_,g-OQ$a!QQ$q!YQ$r!ZS${!j'bS&^#y#zQ'O$lQ(e&WQ(r&nW(s&p(t(u*kQ(v&rQ)b'XS)c'Z+VS+U)d)eQ+j*fQ+l*hQ+x*}Q+z+PR,j,YR&]#xe!wXY!S!T%_%f's({){*OR%]!vQ!{XQ%x#]Q&f$TR&i$WT,f,U,o!Y!kP!n#i#v$X$g$s$t$u$v$w$x$y%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,uQ&Z#qR'^$rR'a${R%U!m&WcOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-PT#gc#hS#^_#_S#a`#bS#ca#dS#eb#fT*`(`*aT(a%x(cQ$VwR+T)cX$Tw$U$V&hZkOr$m'Q*wXoOr'Q*wQ$n!WQ&v$eQ&w$fQ'Y$pQ']$rQ)U&}Q)['SQ)^'TQ)_'UQ)k'[Q)m'^Q*n({Q*p(|Q*q(}Q*s)SS*u)V)lQ*z)YQ*{)ZQ*|)]Q+o*mQ+p*oQ+r*tQ+s*vQ+y+OQ,]+qQ,_+wQ,`+xR,k,^WoOr'Q*wR#snQ'[$qR)V'OQ+S)cR+|+TQ)l'[R*v)VZmOnr'Q*wQrOR#urQ&`#{R(j&`S%l#Q#}S(T%l(WT(W%o&bQ%`!yS't%`'yR'y%dQ&k$XR(o&kQ%g!|S'}%g(PR(P%iQ(Z%pQ*T(UT*Y(Z*TQ'c$}R)p'cS'f%Q%RY)s'f)t+^,S,dU)t'g'h'iU+^)u)v)wS,S+_+`R,d,TQ#X]R%s#XQ#[^R%u#[Q#__R%y#_Q(^%vS*^(^*_R*_(_Q*a(`R+h*aQ#b`R%{#bQ#daR%|#dQ#fbR%}#fQ#hcR&O#hQ#kfQ&P#iW&S#k&P(m*dQ(m&eR*d,uQ$UwS&g$U&hR&h$VQ&u$cR(y&uQ&X#pR(f&XQ$_!PR&o$_Q*g(sS+k*g,ZR,Z+lQ&s$aR(w&sQ#njR&U#nQ*x)WR+u*xQ(z&vR*l(zQ&y$gS)Q&y)RR)R&zQ'R$nR)X'RQ'W$oS)a'W+QR+Q)bQ+W)gR,O+WWnOr'Q*wR#rnSqOrQ)W'QR+t*wWpOr'Q*wR'P$mYjOr$m'Q*wR&T#m[wOr#m$m'Q*wR&f$T$xPOXYZhrtv|}!R!S!T!X!j!l!o!p!q!s!t#]#j#m$P$R$T$W$k$m$|%R%Y%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){)|*O*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,{-PQ!nSQ#ieQ#vsU$Xx%b'wS$g!U$jQ$s!cQ$t!dQ$u!eQ$v!fQ$w!gQ$x!hQ$y!iQ%d!zQ%i!}Q%o#RQ%p#SQ&b$OQ&z$hQ(d&QQ(n&jQ)O&xQ)y'qQ*Q'|Q*S(SQ*r)PQ+f*XR,u,yQ!yXQ!|YQ$e!SQ$f!TW'p%_'s){*OQ'{%fR*o({[fOr#m$m'Q*wd!vXY!S!T%_%f's({){*OQ#QZQ#lhS#}v|Q$[}W$c!R$W&{)TS$o!X$kS$z!j'bQ%Q!lQ%v#]S&R#j(lQ&c$PQ&d$RQ&e$TQ'_$|Q'i%RQ'o%]Q(R%kQ(U%mQ(_%wQ(h&]S(k&a,wQ(p&lQ(q&mQ(x&tQ)]'SQ)`'VQ)n'aQ)q'eQ)v'gQ)w'hS)x'l,xQ*W(YQ*[(]Q+Y)jQ+])rQ+_)uQ+g*]Q+i*eQ+{+SQ,Q+ZQ,R+[Q,T+`Q,X+eQ,a+|Q,b,PR,l,cbTOr#j#m$m&a'Q'l*w#p!uXYZhv|}!R!S!T!X!j!l#]$P$R$T$W$k$|%R%]%_%f%k%m%w&]&l&m&t&{'S'V'a'b'e'g'h's(Y(](l({)T)j)r)u){*O*]*e+S+Z+[+`+e+|,P,c,w,xQ#wtW%V!o!s,r,{Q%W!pQ%X!qQ%Z!tQ%e,qS'k%Y,vQ'm,sQ'n,tQ+a)|Q,W+bS,e,U,oR,}-PU#{u,g-OR(i&_[gOr#m$m'Q*wX!xX#]$T$WQ#VZQ$QvR$Z|Q%a!yQ%h!|Q%n#QQ'_$zQ'z%dQ(Q%iQ(X%oQ([%pQ*U(UQ,V+aQ,i,WR,n,hQ$YxQ'v%bR)}'wQ,h,UR,p,oR#PYR#UZR%P!jQ$}!jR)o'bR%S!lR%x#]Q(b%xR*c(cQ$d!RQ&i$WQ)S&{R*t)TQ#qlQ$]!OQ$`!PR&q$_Q(r&pQ*i(tQ*j(uR+n*kR$b!QXpOr'Q*wQ$i!UR&|$jQ$p!XR&}$kR)i'ZQ)g'ZR+}+V",
  nodeNames: "⚠ print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ParenthesizedExpression ( BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList self VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from ) TupleExpression ComprehensionExpression async for LambdaExpression ArrayExpression [ ] ArrayComprehensionExpression DictionaryExpression { } DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At",
  maxTerm: 236,
  nodeProps: [
    [lezer.NodeProp.group, -14,4,81,83,84,86,88,90,92,94,95,96,98,101,104,"Statement Statement",-23,6,16,19,21,37,38,48,49,53,56,57,60,61,62,63,66,69,70,71,75,76,77,78,"Expression",-9,106,108,111,113,114,118,120,125,127,"Statement"]
  ],
  skippedNodes: [0,2],
  repeatNodeCount: 33,
  tokenData: "!E}MgR!^OX$}XY%wY[$}[]%w]p$}pq%wqr(crs*Ust2Otu$}uv4Qvw5Uwx5xxyAWyzAtz{Bb{|Cr|}Df}!OES!O!PFZ!P!QKa!Q!RLq!R![!(P![!]!)i!]!^!*m!^!_!+Z!_!`!,k!`!a!-_!a!b$}!b!c!.l!c!d!/b!d!e!1f!e!h!/b!h!i!8O!i!t!/b!t!u!=b!u!w!/b!w!x!?`!x!}!/b!}#O!@t#O#P!Ab#P#Q!Bc#Q#R!CP#R#S!/b#S#T$}#T#U!/b#U#V!1f#V#Y!/b#Y#Z!8O#Z#f!/b#f#g!=b#g#i!/b#i#j!?`#j#o!/b#o#p!Cs#p#q!D[#q#r!EO#r#s!Ea#s$g$}$g~!/b<r%`R%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i7[%nR%r7[O#o%i#p#q%i#r~%iMg&[Z%o`%up%r7[%x!b%z#t%iS%lW$q1sOX%iXY&}Y[%i[]&}]p%ipq&}q#O%i#O#P'w#P#o%i#p#q%i#r~%iHP'UZ%r7[$q1sOX%iXY&}Y[%i[]&}]p%ipq&}q#O%i#O#P'w#P#o%i#p#q%i#r~%iHP'|V%r7[OY%iYZ&}Z]%i]^&}^#o%i#p#q%i#r~%i<u(tY%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`#T%i#T#U)t#U#f%i#f#g)t#g#h)t#h#o%i#p#q%i#r~%i7_)kRjR%r7[O#o%i#p#q%i#r~%i7_){R!kR%r7[O#o%i#p#q%i#r~%iG{*e]%vp%o`%r7[%x!b%iS%g,XOY+^YZ.{Z]+^]^.{^r+^rs/]s#O+^#O#P0|#P#o+^#o#p1b#p#q+^#q#r1b#r~+^Bm+g]%r7[%lW%g,XOY,`YZ%iZ],`]^%i^r,`rs-`s#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be,g]%r7[%g,XOY,`YZ%iZ],`]^%i^r,`rs-`s#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be-gR%r7[%g,XO#o%i#p#q%i#r~%iBe-uT%r7[O#o,`#o#p.U#p#q,`#q#r.U#r~,`,X.ZV%g,XOY.UZ].U^r.Urs.ps#O.U#O#P.u#P~.U,X.uO%g,X,X.xPO~.U7d/SR%r7[%lWO#o%i#p#q%i#r~%iEc/dX%r7[%g,XOr.{rs0Ps#O.{#O#P0c#P#o.{#o#p0w#p#q.{#q#r0w#r~.{Ec0YR%m#|%r7[%k,XO#o%i#p#q%i#r~%i7d0hT%r7[O#o.{#o#p0w#p#q.{#q#r0w#r~.{W0|O%lWBm1RT%r7[O#o+^#o#p1b#p#q+^#q#r1b#r~+^,a1iV%lW%g,XOY.UZ].U^r.Urs.ps#O.U#O#P.u#P~.UMg2cXQ1s%o`%up%r7[%x!b%z#t%iS%lWOY3OYZ%iZ]3O]^%i^#o3O#o#p3r#p#q3O#q#r3r#r~3OHP3VXQ1s%r7[OY3OYZ%iZ]3O]^%i^#o3O#o#p3r#p#q3O#q#r3r#r~3O1s3wRQ1sOY3rZ]3r^~3rGz4eT%PQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iBd4{R!t,W%r7[O#o%i#p#q%i#r~%iGz5iT$yQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iG{6X_%s`%up%r7[%z#t%lW%g,XOY7WYZ:dZ]7W]^:d^r7Wrs:xsw7Wwx;|x#O7W#O#P>n#P#o7W#o#p?t#p#q7W#q#r?S#r~7WFq7e]%r7[%x!b%z#t%iS%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be8e]%r7[%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be9cT%r7[O#o8^#o#p9r#p#q8^#q#r9r#r~8^,X9wV%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9r,X:aPO~9r;h:oR%r7[%x!b%z#t%iSO#o%i#p#q%i#r~%iC{;T]%r7[%x!b%iS%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Fq<VZ%r7[%z#t%g,XOr:drs<xsw:dwx=[x#O:d#O#P=p#P#o:d#o#p>_#p#q:d#q#r>U#r~:d8r=RR%r7[%x!b%iSO#o%i#p#q%i#r~%iFq=gR%j!f%r7[%z#t%h,XO#o%i#p#q%i#r~%i;h=uT%r7[O#o:d#o#p>U#p#q:d#q#r>U#r~:d%[>_O%x!b%z#t%iS%[>dP%iS#o#p>g%W>nO%x!b%z#tFq>sT%r7[O#o7W#o#p?S#p#q7W#q#r?S#r~7W0e?_V%x!b%z#t%iS%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9r0e?{X%iS%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P#o9r#o#p@h#p~9r0a@qV%x!b%z#t%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9rG{AkRf,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i<uBXR!PR%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iG{BuVT,X%o`%up%r7[%x!b%z#t%iS%lWOz%iz{C[{!_%i!_!`4t!`#o%i#p#q%i#r~%iBeCcT_R%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{DVT$|,X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iG{DyRx,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iMgEgU$},X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`!aEy!a#o%i#p#q%i#r~%i<vFQR&U&j%r7[O#o%i#p#q%i#r~%iG{FnV!eQ%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!PGT!P!Q%i!Q![Gy![#o%i#p#q%i#r~%iBeGYT%r7[O!O%i!O!PGi!P#o%i#p#q%i#r~%iBeGpR!n,X%r7[O#o%i#p#q%i#r~%iBcHQ_!g,V%r7[O!Q%i!Q![Gy![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#SGy#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBcIUX%r7[O{%i{|Iq|}%i}!OIq!O!Q%i!Q![JV![#o%i#p#q%i#r~%iBcIvT%r7[O!Q%i!Q![JV![#o%i#p#q%i#r~%iBcJ^Z!g,V%r7[O!Q%i!Q![JV![!l%i!l!mKP!m#R%i#R#SJV#S#^%i#^#_KP#_#o%i#p#q%i#r~%iBcKWR!g,V%r7[O#o%i#p#q%i#r~%iG{KtV%OR%o`%up%r7[%x!b%z#t%iS%lWO!P%i!P!QLZ!Q!_%i!_!`4t!`#o%i#p#q%i#r~%iBdLbT%QQ%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iGyMUm!g,V%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!P! P!P!Q%i!Q![!!k![!d%i!d!e!#w!e!g%i!g!hIP!h!l%i!l!mKP!m!q%i!q!r!%V!r!z%i!z!{!&_!{#R%i#R#S!!k#S#U%i#U#V!#w#V#X%i#X#YIP#Y#^%i#^#_KP#_#c%i#c#d!%V#d#l%i#l#m!&_#m#o%i#p#q%i#r~%iBc! UT%r7[O!Q%i!Q![! e![#o%i#p#q%i#r~%iBc! l_!g,V%r7[O!Q%i!Q![! e![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S! e#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBc!!ra!g,V%r7[O!O%i!O!P! P!P!Q%i!Q![!!k![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S!!k#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBc!#|W%r7[O!Q%i!Q!R!$f!R!S!$f!S#R%i#R#S!$f#S#o%i#p#q%i#r~%iBc!$mW!g,V%r7[O!Q%i!Q!R!$f!R!S!$f!S#R%i#R#S!$f#S#o%i#p#q%i#r~%iBc!%[V%r7[O!Q%i!Q!Y!%q!Y#R%i#R#S!%q#S#o%i#p#q%i#r~%iBc!%xV!g,V%r7[O!Q%i!Q!Y!%q!Y#R%i#R#S!%q#S#o%i#p#q%i#r~%iBc!&dZ%r7[O!Q%i!Q![!'V![!c%i!c!i!'V!i#R%i#R#S!'V#S#T%i#T#Z!'V#Z#o%i#p#q%i#r~%iBc!'^Z!g,V%r7[O!Q%i!Q![!'V![!c%i!c!i!'V!i#R%i#R#S!'V#S#T%i#T#Z!'V#Z#o%i#p#q%i#r~%iGy!(da!g,V%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!P! P!P!Q%i!Q![!!k![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S!!k#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iMg!)|Ty1s%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`!*]!`#o%i#p#q%i#r~%i7_!*dR%YR%r7[O#o%i#p#q%i#r~%iG{!+QR#_,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iG{!+nVjR%o`%up%r7[%x!b%z#t%iS%lWO!^%i!^!_!,T!_!`)d!`!a)d!a#o%i#p#q%i#r~%iBd!,[T$zQ%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{!-OT%X,X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`#o%i#p#q%i#r~%iG{!-rUjR%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`!a!.U!a#o%i#p#q%i#r~%iBd!.]T${Q%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{!/RT]Q#uP%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iMg!/wZ%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XO!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jHP!0sZ%r7[%f&j%S,XO!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!1{c%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!t!0j!t!u!6v!u!}!0j!}#R%i#R#S!0j#S#T%i#T#f!0j#f#g!6v#g#o!0j#p#q%i#r$g%i$g~!0jBe!3_]%r7[%g,XOY,`YZ%iZ],`]^%i^r,`rs!4Ws#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be!4_T%r7[%g,XOr%irs!4ns#o%i#p#q%i#r~%iBe!4uR%r7[%k,XO#o%i#p#q%i#r~%iBe!5V]%r7[%g,XOY8^YZ%iZ]8^]^%i^w8^wx!6Ox#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be!6VT%r7[%g,XOw%iwx!6fx#o%i#p#q%i#r~%iBe!6mR%r7[%h,XO#o%i#p#q%i#r~%iHP!7P_%r7[%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!8ec%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!9psw%iwx!:|x!Q%i!Q![!0j![!c%i!c!t!0j!t!u!<Y!u!}!0j!}#R%i#R#S!0j#S#T%i#T#f!0j#f#g!<Y#g#o!0j#p#q%i#r$g%i$g~!0jBe!9wT%r7[%t,XOr%irs!:Ws#o%i#p#q%i#r~%iBe!:]T%r7[Or%irs!:ls#o%i#p#q%i#r~%iBe!:sR%r7[%y,XO#o%i#p#q%i#r~%iBe!;TT%r7[%n,XOw%iwx!;dx#o%i#p#q%i#r~%iBe!;iT%r7[Ow%iwx!;xx#o%i#p#q%i#r~%iBe!<PR%r7[%w,XO#o%i#p#q%i#r~%iHP!<c_%r7[%f&j%S,XOr%irs!9psw%iwx!:|x!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!=wg%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!h!0j!h!i!<Y!i!t!0j!t!u!6v!u!}!0j!}#R%i#R#S!0j#S#T%i#T#U!0j#U#V!6v#V#Y!0j#Y#Z!<Y#Z#o!0j#p#q%i#r$g%i$g~!0jMg!?u_%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jG{!AXR!W,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iMg!AgX%r7[OY$}YZ%wZ]$}]^%w^#o$}#o#p!BS#p#q$}#q#r!BS#r~$}&f!BcO%o`%up%x!b%z#t%iS%lW<u!BvR!XR%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iGz!CdT$xQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iGy!C|P![Gm%iS%lW#o#p!DP&Y!D[O%o`%up%x!b%z#tGz!DoT$wQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%i<u!EaO!]7_%o`%up%x!b%z#t%iS%lWGy!EtR%R,V%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i",
  tokenizers: [legacyPrint, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, newlines, bodyContinue],
  topRules: {"Script":[0,3]},
  specialized: [{term: 188, get: value => spec_identifier[value] || -1}],
  tokenPrec: 6067
});

exports.parser = parser;


/***/ }),

/***/ "./node_modules/lezer-tree/dist/tree.cjs":
/*!***********************************************!*\
  !*** ./node_modules/lezer-tree/dist/tree.cjs ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

/// The default maximum length of a `TreeBuffer` node.
const DefaultBufferLength = 1024;
let nextPropID = 0;
const CachedNode = new WeakMap();
/// Each [node type](#tree.NodeType) can have metadata associated with
/// it in props. Instances of this class represent prop names.
class NodeProp {
    /// Create a new node prop type. You can optionally pass a
    /// `deserialize` function.
    constructor({ deserialize } = {}) {
        this.id = nextPropID++;
        this.deserialize = deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// Create a string-valued node prop whose deserialize function is
    /// the identity function.
    static string() { return new NodeProp({ deserialize: str => str }); }
    /// Create a number-valued node prop whose deserialize function is
    /// just `Number`.
    static number() { return new NodeProp({ deserialize: Number }); }
    /// Creates a boolean-valued node prop whose deserialize function
    /// returns true for any input.
    static flag() { return new NodeProp({ deserialize: () => true }); }
    /// Store a value for this prop in the given object. This can be
    /// useful when building up a prop object to pass to the
    /// [`NodeType`](#tree.NodeType) constructor. Returns its first
    /// argument.
    set(propObj, value) {
        propObj[this.id] = value;
        return propObj;
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#tree.NodeSet.extend) or
    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop
    /// values for each node type in the set. Takes a [match
    /// object](#tree.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src)
                    src[0].set(props, src[1]);
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#tree.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#tree.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a number array. Each parser
/// [has](#lezer.Parser.nodeSet) a node set, and [tree
/// buffers](#tree.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536)
/// node types in it, so that the ids fit into 16-bit typed array
/// slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#tree.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    add[0].set(newProps, add[1]);
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the `TreeCursor` interface instead, which provides a view on
/// some part of this data structure, and can be used to move around
/// to adjacent nodes.
class Tree {
    /// Construct a new tree. You usually want to go through
    /// [`Tree.build`](#tree.Tree^build) instead.
    constructor(type, 
    /// The tree's child nodes. Children small enough to fit in a
    /// `TreeBuffer will be represented as such, other children can be
    /// further `Tree` instances with their own internal structure.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
    }
    /// @internal
    toString() {
        let children = this.children.map(c => c.toString()).join();
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular
    /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)
    /// nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, true);
    }
    /// Get a [syntax node](#tree.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#tree.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        return this.cursor(pos, side).node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, the given node
    /// will not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor();;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Balance the direct children of this tree.
    balance(maxBufferLength = DefaultBufferLength) {
        return this.children.length <= BalanceBranchFactor ? this
            : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length);
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer @internal
    constructor(
    /// @internal
    buffer, 
    // The total length of the group of nodes in the buffer.
    length, 
    /// @internal
    set, type = NodeType.none) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
        this.type = type;
    }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, after) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (after != -100000000 /* None */) {
                let start = buffer[i + 1], end = buffer[i + 2];
                if (dir > 0) {
                    if (end > after)
                        pick = i;
                    if (end > after)
                        break;
                }
                else {
                    if (start < after)
                        pick = i;
                    if (end >= after)
                        break;
                }
            }
            else {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
}
class TreeNode {
    constructor(node, from, index, _parent) {
        this.node = node;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get to() { return this.from + this.node.length; }
    nextChild(i, dir, after, full = false) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (after != -100000000 /* None */ && (dir < 0 ? start >= after : start + next.length <= after))
                    continue;
                if (next instanceof TreeBuffer) {
                    let index = next.findChild(0, next.buffer.length, dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - start);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if (full || (!next.type.isAnonymous || hasChild(next))) {
                    let inner = new TreeNode(next, start, i, parent);
                    return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);
                }
            }
            if (full || !parent.type.isAnonymous)
                return null;
            i = parent.index + dir;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, -100000000 /* None */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, -100000000 /* None */); }
    childAfter(pos) { return this.nextChild(0, 1, pos); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos); }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;
    }
    get prevSibling() {
        return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, after) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.context.start);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, -100000000 /* None */); }
    get lastChild() { return this.child(-1, -100000000 /* None */); }
    childAfter(pos) { return this.child(1, pos); }
    childBefore(pos) { return this.child(-1, pos); }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, full = false) {
        this.full = full;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enter(dir, after) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.buffer.start);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enter(1, -100000000 /* None */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enter(-1, -100000000 /* None */); }
    /// Move the cursor to the first child that starts at or after `pos`.
    childAfter(pos) { return this.enter(1, pos); }
    /// Move to the last child that ends at or before `pos`.
    childBefore(pos) { return this.enter(-1, pos); }
    /// Move the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000 /* None */, this.full));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000 /* None */, this.full)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                let child = parent.node.children[i];
                if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))
                    return false;
            }
        }
        return true;
    }
    move(dir) {
        if (this.enter(dir, -100000000 /* None */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty, its next sibling or the next sibling of
    /// the first parent node that has one.
    next() { return this.move(1); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by ist last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev() { return this.move(-1); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        for (;;) {
            if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))
                break;
            if (this.from == this.to ||
                (side < 1 ? this.from >= pos : this.from > pos) ||
                (side > -1 ? this.to <= pos : this.to < pos)) {
                this.parent();
                break;
            }
        }
        return this;
    }
    /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#tree.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#tree.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));
}
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
const BalanceBranchFactor = 8;
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        while (id == inRepeat) {
            cursor.next();
            ({ id, start, end, size } = cursor);
        }
        let startPos = start - parentStart;
        if (size < 0) { // Reused node
            children.push(reused[id]);
            positions.push(startPos);
            cursor.next();
            return;
        }
        let type = types[id], node, buffer;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index, inRepeat);
            node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            while (cursor.pos > endPos)
                takeNode(start, endPos, localChildren, localPositions, localInRepeat);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)
                node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start);
            else
                node = new Tree(type, localChildren, localPositions, end - start);
        }
        children.push(node);
        positions.push(startPos);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let nodeSize = fork.size, startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0)
                    break scan;
                if (fork.id >= minRepeatType)
                    localSkipped += 4;
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index, inRepeat) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (id == inRepeat)
            return index;
        let startIndex = index;
        if (size > 4) {
            let endPos = cursor.pos - (size - 4);
            while (cursor.pos > endPos)
                index = copyToBuffer(bufferStart, buffer, index, inRepeat);
        }
        if (id < minRepeatType) { // Don't copy repeat nodes into buffers
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[topID], children.reverse(), positions.reverse(), length);
}
function balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length) {
    let localChildren = [], localPositions = [];
    if (length <= maxBufferLength) {
        for (let i = from; i < to; i++) {
            localChildren.push(children[i]);
            localPositions.push(positions[i] - start);
        }
    }
    else {
        let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i];
            i++;
            for (; i < to; i++) {
                let nextEnd = positions[i] + children[i].length;
                if (nextEnd - groupStart > maxChild)
                    break;
            }
            if (i == groupFrom + 1) {
                let only = children[groupFrom];
                if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse
                    for (let j = 0; j < only.children.length; j++) {
                        localChildren.push(only.children[j]);
                        localPositions.push(only.positions[j] + groupStart - start);
                    }
                    continue;
                }
                localChildren.push(only);
            }
            else if (i == groupFrom + 1) {
                localChildren.push(children[groupFrom]);
            }
            else {
                let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart);
                if (innerType != NodeType.none && !containsType(inner.children, innerType))
                    inner = new Tree(NodeType.none, inner.children, inner.positions, inner.length);
                localChildren.push(inner);
            }
            localPositions.push(groupStart - start);
        }
    }
    return new Tree(outerType, localChildren, localPositions, length);
}
function containsType(nodes, type) {
    for (let elt of nodes)
        if (elt.type == type)
            return true;
    return false;
}
/// Tree fragments are used during [incremental
/// parsing](#lezer.ParseOptions.fragments) to track parts of old
/// trees that can be reused in a new parse. An array of fragments is
/// used to track regions of an old tree whose nodes might be reused
/// in new parses. Use the static
/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update
/// fragments for document changes.
class TreeFragment {
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, open) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = open;
    }
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        let cI = 0, pos = 0, off = 0;
        for (;;) {
            let nextC = cI < changes.length ? changes[cI++] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null :
                            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 /* Start */ : 0) | (nextC ? 2 /* End */ : 0));
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the token at its
    /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 /* End */ : 0)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
}
// Creates an `Input` that is backed by a single, flat string.
function stringInput(input) { return new StringInput(input); }
class StringInput {
    constructor(string, length = string.length) {
        this.string = string;
        this.length = length;
    }
    get(pos) {
        return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);
    }
    lineAfter(pos) {
        if (pos < 0)
            return "";
        let end = this.string.indexOf("\n", pos);
        return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));
    }
    read(from, to) { return this.string.slice(from, Math.min(this.length, to)); }
    clip(at) { return new StringInput(this.string, at); }
}

exports.DefaultBufferLength = DefaultBufferLength;
exports.NodeProp = NodeProp;
exports.NodeSet = NodeSet;
exports.NodeType = NodeType;
exports.Tree = Tree;
exports.TreeBuffer = TreeBuffer;
exports.TreeCursor = TreeCursor;
exports.TreeFragment = TreeFragment;
exports.stringInput = stringInput;
//# sourceMappingURL=tree.cjs.map


/***/ }),

/***/ "./node_modules/lezer/dist/index.cjs":
/*!*******************************************!*\
  !*** ./node_modules/lezer/dist/index.cjs ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var lezerTree = __webpack_require__(/*! lezer-tree */ "./node_modules/lezer-tree/dist/tree.cjs");

/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// A group of values that the stack will share with all
    /// split instances
    ///@internal
    cx, 
    /// Holds state, pos, value stack pos (15 bits array index, 15 bits
    /// buffer index) triplets for all but the top state
    /// @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.cx = cx;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(cx, state, pos = 0) {
        return new Stack(cx, [], state, pos, pos, 0, [], 0, null);
    }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.cx;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            // Zero-depth reductions are a special case—they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let start = this.pos, nextState = action, { parser } = this.cx;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            if (next <= this.cx.parser.maxNode)
                this.buffer.push(next, this.pos, nextEnd, 4);
            this.pos = nextEnd;
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt node into the buffer. This may be a reused node or
    // the result of running a nested parser.
    /// @internal
    useNode(value, next) {
        let index = this.cx.reused.length - 1;
        if (index < 0 || this.cx.reused[index] != value) {
            this.cx.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.cx.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 200 /* Token */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.cx.parser.stateSlot(sim.top, 4 /* DefaultReduce */) || this.cx.parser.hasAction(sim.top, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    /// Find the start position of the rule that is currently being parsed.
    get ruleStart() {
        for (let state = this.state, base = this.stack.length;;) {
            let force = this.cx.parser.stateSlot(state, 5 /* ForcedReduce */);
            if (!(force & 65536 /* ReduceFlag */))
                return 0;
            base -= 3 * (force >> 19 /* ReduceDepthShift */);
            if ((force & 65535 /* ValueMask */) < this.cx.parser.minRepeatTerm)
                return this.stack[base + 1];
            state = this.stack[base];
        }
    }
    /// Find the start position of an instance of any of the given term
    /// types, or return `null` when none of them are found.
    ///
    /// **Note:** this is only reliable when there is at least some
    /// state that unambiguously matches the given rule on the stack.
    /// I.e. if you have a grammar like this, where the difference
    /// between `a` and `b` is only apparent at the third token:
    ///
    ///     a { b | c }
    ///     b { "x" "y" "x" }
    ///     c { "x" "y" "z" }
    ///
    /// Then a parse state after `"x"` will not reliably tell you that
    /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check
    /// for either of those two rules (assuming that `a` isn't part of
    /// some rule that includes other things starting with `"x"`).
    ///
    /// When `before` is given, this keeps scanning up the stack until
    /// it finds a match that starts before that position.
    startOf(types, before) {
        let state = this.state, frame = this.stack.length, { parser } = this.cx;
        for (;;) {
            let force = parser.stateSlot(state, 5 /* ForcedReduce */);
            let depth = force >> 19 /* ReduceDepthShift */, term = force & 65535 /* ValueMask */;
            if (types.indexOf(term) > -1) {
                let base = frame - (3 * (force >> 19 /* ReduceDepthShift */)), pos = this.stack[base + 1];
                if (before == null || before > pos)
                    return pos;
            }
            if (frame == 0)
                return null;
            if (depth == 0) {
                frame -= 3;
                state = this.stack[frame];
            }
            else {
                frame -= 3 * (depth - 1);
                state = parser.getGoto(this.stack[frame - 3], term, true);
            }
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.cx.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = nextStates.filter(s => s != this.state && this.cx.parser.hasAction(s, next));
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ && i < nextStates.length; i++)
                    if (best.indexOf(nextStates[i]) < 0)
                        best.push(nextStates[i]);
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i++) {
            if (nextStates[i] == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(nextStates[i], this.pos);
            stack.score -= 200 /* Token */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.cx.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        if (!this.cx.parser.validAction(this.state, reduce)) {
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.cx.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.cx;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.cx.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.cx.parser.dialect.flags[dialectID]; }
}
var Recover;
(function (Recover) {
    Recover[Recover["Token"] = 200] = "Token";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(stack) {
        this.stack = stack;
        this.top = stack.state;
        this.rest = stack.stack;
        this.offset = this.rest.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.rest == this.stack.stack)
                this.rest = this.rest.slice();
            this.rest.push(this.top, 0, 0);
            this.offset += 3;
        }
        else {
            this.offset -= (depth - 1) * 3;
        }
        let goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);
        this.top = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack) {
        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

/// Tokenizers write the tokens they read into instances of this class.
class Token {
    constructor() {
        /// The start of the token. This is set by the parser, and should not
        /// be mutated by the tokenizer.
        this.start = -1;
        /// This starts at -1, and should be updated to a term id when a
        /// matching token is found.
        this.value = -1;
        /// When setting `.value`, you should also set `.end` to the end
        /// position of the token. (You'll usually want to use the `accept`
        /// method.)
        this.end = -1;
    }
    /// Accept a token, setting `value` and `end` to the given values.
    accept(value, end) {
        this.value = value;
        this.end = end;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, token, stack) { readToken(this.data, input, token, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// Exports that are used for `@external tokens` in the grammar should
/// export an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream and a token object,
    /// [fills](#lezer.Token.accept) the token object if it recognizes a
    /// token. `token.start` should be used as the start position to
    /// scan from.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, token, stack, group) {
    let state = 0, groupMask = 1 << group, dialect = stack.cx.parser.dialect;
    scan: for (let pos = token.start;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (token.value == -1 || token.value == term || stack.cx.parser.overrides(term, token.value))) {
                    token.accept(term, pos);
                    break;
                }
            }
        let next = input.get(pos++);
        // Do a binary search on the state's edges
        for (let low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
function cutAt(tree, pos, side) {
    let cursor = tree.cursor(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to <= pos : cursor.from >= pos) && !cursor.type.isError)
                    return side < 0 ? cursor.to - 1 : cursor.from + 1;
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments) {
        this.fragments = fragments;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            else if (start == pos && start + next.length <= this.safeTo) {
                return start == pos && start >= this.safeFrom ? next : null;
            }
            if (next instanceof lezerTree.TreeBuffer) {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
            else {
                this.index[last]++;
                if (start + next.length >= pos) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
        }
    }
}
class CachedToken extends Token {
    constructor() {
        super(...arguments);
        this.extended = -1;
        this.mask = 0;
    }
    clear(start) {
        this.start = start;
        this.value = this.extended = -1;
    }
}
const dummyToken = new Token;
class TokenCache {
    constructor(parser) {
        this.tokens = [];
        this.mainToken = dummyToken;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack, input) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.cx, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask) {
                this.updateCachedToken(token, tokenizer, stack, input);
                token.mask = mask;
            }
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (!main) {
            main = dummyToken;
            main.start = stack.pos;
            if (stack.pos == input.length)
                main.accept(stack.cx.parser.eofTerm, stack.pos);
            else
                main.accept(0 /* Err */, stack.pos + 1);
        }
        this.mainToken = main;
        return this.actions;
    }
    updateCachedToken(token, tokenizer, stack, input) {
        token.clear(stack.pos);
        tokenizer.token(input, token, stack);
        if (token.value > -1) {
            let { parser } = stack.cx;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](input.read(token.start, token.end), stack);
                    if (result >= 0 && stack.cx.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else if (stack.pos == input.length) {
            token.accept(stack.cx.parser.eofTerm, stack.pos);
        }
        else {
            token.accept(0 /* Err */, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.cx, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 1), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    Rec[Rec["MinBufferLengthPrune"] = 200] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
})(Rec || (Rec = {}));
/// A parse context can be used for step-by-step parsing. After
/// creating it, you repeatedly call `.advance()` until it returns a
/// tree to indicate it has reached the end of the parse.
class Parse {
    constructor(parser, input, startPos, context) {
        this.parser = parser;
        this.input = input;
        this.startPos = startPos;
        this.context = context;
        // The position to which the parse has advanced.
        this.pos = 0;
        this.recovering = 0;
        this.nextStackID = 0x2654;
        this.nested = null;
        this.nestEnd = 0;
        this.nestWrap = null;
        this.reused = [];
        this.tokens = new TokenCache(parser);
        this.topTerm = parser.top[1];
        this.stacks = [Stack.start(this, parser.top[0], this.startPos)];
        let fragments = context === null || context === void 0 ? void 0 : context.fragments;
        this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        if (this.nested) {
            let result = this.nested.advance();
            this.pos = this.nested.pos;
            if (result) {
                this.finishNested(this.stacks[0], result);
                this.nested = null;
            }
            return null;
        }
        let stacks = this.stacks, pos = this.pos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        let maybeNest;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], nest;
            for (;;) {
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (nest = this.checkNest(stack)) {
                    if (!maybeNest || maybeNest.stack.score < stack.score)
                        maybeNest = nest;
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.mainToken;
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (maybeNest) {
            this.startNested(maybeNest);
            return null;
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + this.parser.getName(this.tokens.mainToken.value));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 200 /* MinBufferLengthPrune */ && other.buffer.length > 200 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.pos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.pos)
                this.pos = newStacks[i].pos;
        return null;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { input, parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.fragments) {
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof lezerTree.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof lezerTree.Tree)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        let actions = this.tokens.getActions(stack, input);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            let nest = this.checkNest(stack);
            if (nest)
                return nest;
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        let maybeNest;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done) {
                    if (done !== true)
                        maybeNest = done;
                    continue;
                }
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done) {
                    if (done !== true)
                        maybeNest = done;
                    break;
                }
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.input.length > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        if (finished)
            return finished;
        if (maybeNest)
            for (let s of this.stacks)
                if (s.score > maybeNest.stack.score) {
                    maybeNest = undefined;
                    break;
                }
        if (maybeNest)
            this.startNested(maybeNest);
        return null;
    }
    forceFinish() {
        let stack = this.stacks[0].split();
        if (this.nested)
            this.finishNested(stack, this.nested.forceFinish());
        return this.stackToTree(stack.forceAll());
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack, pos = stack.pos) {
        return lezerTree.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.startPos,
            length: pos - this.startPos,
            minRepeatType: this.parser.minRepeatTerm });
    }
    checkNest(stack) {
        let info = this.parser.findNested(stack.state);
        if (!info)
            return null;
        let spec = info.value;
        if (typeof spec == "function")
            spec = spec(this.input, stack);
        return spec ? { stack, info, spec } : null;
    }
    startNested(nest) {
        let { stack, info, spec } = nest;
        this.stacks = [stack];
        this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);
        this.nestWrap = typeof spec.wrapType == "number" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;
        if (spec.startParse) {
            this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);
        }
        else {
            this.finishNested(stack);
        }
    }
    scanForNestEnd(stack, endToken, filter) {
        for (let pos = stack.pos; pos < this.input.length; pos++) {
            dummyToken.start = pos;
            dummyToken.value = -1;
            endToken.token(this.input, dummyToken, stack);
            if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end))))
                return pos;
        }
        return this.input.length;
    }
    finishNested(stack, tree) {
        if (this.nestWrap)
            tree = new lezerTree.Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos);
        else if (!tree)
            tree = new lezerTree.Tree(lezerTree.NodeType.none, [], [], this.nestEnd - stack.pos);
        let info = this.parser.findNested(stack.state);
        stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));
        if (verbose)
            console.log(this.stackID(stack) + ` (via unnest)`);
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class Parser {
    /// @internal
    constructor(spec) {
        /// @internal
        this.bufferLength = lezerTree.DefaultBufferLength;
        /// @internal
        this.strict = false;
        this.nextStateCache = [];
        this.cachedDialect = null;
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let tokenArray = decodeArray(spec.tokenData);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        this.nodeSet = new lezerTree.NodeSet(nodeNames.map((name, i) => lezerTree.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {
            return { name, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder };
        });
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        for (let i = 0, l = this.states.length / 6 /* Size */; i < l; i++)
            this.nextStateCache[i] = null;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    /// Parse a given string or stream.
    parse(input, startPos = 0, context = {}) {
        if (typeof input == "string")
            input = lezerTree.stringInput(input);
        let cx = new Parse(this, input, startPos, context);
        for (;;) {
            let done = cx.advance();
            if (done)
                return done;
        }
    }
    /// Start an incremental parse.
    startParse(input, startPos = 0, context = {}) {
        if (typeof input == "string")
            input = lezerTree.stringInput(input);
        return new Parse(this, input, startPos, context);
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    findNested(state) {
        let flags = this.stateSlot(state, 0 /* Flags */);
        return flags & 4 /* StartNest */ ? this.nested[flags >> 10 /* NestShift */] : null;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let cached = this.nextStateCache[state];
        if (cached)
            return cached;
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0 && result.indexOf(this.data[i + 1]) < 0)
                result.push(this.data[i + 1]);
        }
        let table = this.goto, max = table[0];
        for (let term = 0; term < max; term++) {
            for (let pos = table[term + 1];;) {
                let groupTag = table[pos++], target = table[pos++];
                for (let end = pos + (groupTag >> 1); pos < end; pos++)
                    if (table[pos] == state && result.indexOf(target) < 0)
                        result.push(target);
                if (groupTag & 1)
                    break;
            }
        }
        return this.nextStateCache[state] = result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(Parser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.nested)
            copy.nested = this.nested.map(obj => {
                if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name))
                    return obj;
                return { name: obj.name, value: config.nested[obj.name], end: obj.end, placeholder: obj.placeholder };
            });
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// Tells you whether this grammar has any nested grammars.
    get hasNested() { return this.nested.length > 0; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        if (this.cachedDialect && this.cachedDialect.source == dialect)
            return this.cachedDialect;
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return this.cachedDialect = new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new Parser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        if (stack.pos == stack.cx.input.length &&
            stack.cx.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}

exports.NodeProp = lezerTree.NodeProp;
exports.NodeSet = lezerTree.NodeSet;
exports.NodeType = lezerTree.NodeType;
exports.Tree = lezerTree.Tree;
exports.TreeCursor = lezerTree.TreeCursor;
exports.ExternalTokenizer = ExternalTokenizer;
exports.Parser = Parser;
exports.Stack = Stack;
exports.Token = Token;
//# sourceMappingURL=index.cjs.map


/***/ }),

/***/ "./ast.ts":
/*!****************!*\
  !*** ./ast.ts ***!
  \****************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isuniOp = exports.issameOp = exports.isboolOp = exports.isintOp = exports.isOp = void 0;
var int_ops = { "+": true, "-": true, "*": true, "//": true, "%": true,
    ">": true, "<": true, ">=": true, "<=": true };
var same_ops = { "==": true, "!=": true };
var bool_ops = { "and": true, "or": true };
var spec_ops = { "is": true };
var uni_ops = { "not": true, "-": true };
function isOp(maybeOp) {
    return maybeOp in int_ops || maybeOp in bool_ops || maybeOp in same_ops || maybeOp in spec_ops;
}
exports.isOp = isOp;
function isintOp(maybeOp) {
    return maybeOp in int_ops;
}
exports.isintOp = isintOp;
function isboolOp(maybeOp) {
    return maybeOp in bool_ops;
}
exports.isboolOp = isboolOp;
function issameOp(maybeOp) {
    return maybeOp in same_ops;
}
exports.issameOp = issameOp;
function isuniOp(maybeOp) {
    return maybeOp in uni_ops;
}
exports.isuniOp = isuniOp;


/***/ }),

/***/ "./compiler.ts":
/*!*********************!*\
  !*** ./compiler.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compile = exports.codeGenStmt = exports.codeGenClass = exports.codeGenFunDef = exports.codeGenExpr = exports.opStmts = exports.runwatsrc = void 0;
var wabt_1 = __importDefault(__webpack_require__(/*! wabt */ "wabt"));
var parser_1 = __webpack_require__(/*! ./parser */ "./parser.ts");
var tc_1 = __webpack_require__(/*! ./tc */ "./tc.ts");
var loop_counter = 0;
var obj_field_type_idx;
var classes = new Map();
var obj_name_reg = "none";
var tmp_vars = [];
var unassigned_cls = 0;
var decl_of_funcs = [];
function variableNames(stmts, class_name) {
    if (class_name === void 0) { class_name = ""; }
    var vars = [];
    stmts.forEach(function (stmt) {
        if (stmt.tag === "assign" && !(vars.includes(stmt.name))) {
            if (class_name != "") {
                vars.push("".concat(class_name, ".").concat(stmt.name));
            }
            else {
                vars.push(stmt.name);
            }
        }
    });
    return vars;
}
function funs(stmts) {
    return stmts.filter(function (stmt) { return stmt.tag === "define"; });
}
function nonFuns(stmts) {
    return stmts.filter(function (stmt) { return stmt.tag !== "define"; });
}
function varsFunsStmts(stmts) {
    return [variableNames(stmts), funs(stmts), nonFuns(stmts)];
}
function runwatsrc(watSource, config) {
    return __awaiter(this, void 0, void 0, function () {
        var wabtApi, parsed, binary, wasmModule;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, wabt_1.default)()];
                case 1:
                    wabtApi = _a.sent();
                    parsed = wabtApi.parseWat("example", watSource);
                    binary = parsed.toBinary({});
                    return [4 /*yield*/, WebAssembly.instantiate(binary.buffer, config)];
                case 2:
                    wasmModule = _a.sent();
                    return [2 /*return*/, wasmModule.instance.exports._start()];
            }
        });
    });
}
exports.runwatsrc = runwatsrc;
function opStmts(op) {
    switch (op) {
        case "+": return ["i32.add"];
        case "-": return ["i32.sub"];
        case "*": return ["i32.mul"];
        case "//": return ["i32.div_s"];
        case "%": return ["i32.rem_s"];
        case ">": return ["i32.gt_s"];
        case "<": return ["i32.lt_s"];
        case ">=": return ["i32.ge_s"];
        case "<=": return ["i32.le_s"];
        case "==": return ["i32.eq"];
        case "!=": return ["i32.ne"];
        case "and": return ["i32.and"];
        case "or": return ["i32.or"];
        default:
            throw new Error("[Compiler.ts]Unhandled or unknown op: ".concat(op));
    }
}
exports.opStmts = opStmts;
function codeGenExpr(expr, locals) {
    var emptyEnv = new Map();
    switch (expr.tag) {
        case "number": return ["(i32.const ".concat(expr.value, ")")];
        case "true": return ["(i32.const 1)"];
        case "false": return ["(i32.const 0)"];
        case "none": return ["(i32.const 0)"];
        case "id":
            // Since we type-checked for making sure all variable exist, here we
            // just check if it's a local variable and assume it is global if not
            if (locals.has(expr.name)) {
                return ["(local.get $".concat(expr.name, ")")];
            }
            else {
                return ["(global.get $".concat(expr.name, ")")];
            }
        case "binop": {
            var lhsExprs = codeGenExpr(expr.lhs, locals);
            var rhsExprs = codeGenExpr(expr.rhs, locals);
            if (expr.op == 'is') {
                console.log("compiler lhs/rhs: ", expr.lhs, expr.rhs);
                console.log(expr.lhs.a == expr.rhs.a, expr.lhs.a === expr.rhs.a);
                if (expr.lhs.a === expr.rhs.a) {
                    // Same like return true
                    return ["(i32.const 1)"];
                }
                else {
                    return ["(i32.const 0)"];
                }
            }
            var opstmts = opStmts(expr.op);
            return __spreadArray(__spreadArray(__spreadArray([], lhsExprs, true), rhsExprs, true), opstmts, true);
        }
        case "call":
            console.log("classes:", classes);
            if (classes.has(expr.name)) {
                // Instantiate a new obj of class 'expr.name'
                var initvals = [];
                var classdata = classes.get(expr.name);
                if (classdata.tag != "class") {
                    throw new Error("Classdata has an non-class tag");
                }
                else {
                    // First we compile its field
                    if (obj_name_reg == "none") {
                        // Call class without an obj assignment
                        var tmp_obj_name = "RESERVED_".concat(unassigned_cls);
                        console.log("Creating tmp var ".concat(tmp_obj_name));
                        console.log("TMP_VARS: ".concat(tmp_vars));
                        tmp_vars.push(tmp_obj_name);
                        var str_push_tmp_name = "global.set $".concat(tmp_obj_name);
                        var prev_obj_name_reg = obj_name_reg;
                        obj_name_reg = tmp_obj_name;
                    }
                    classdata.fields.forEach(function (f, index) {
                        var offset = index * 4;
                        if (f.tag != "assign") {
                            throw new Error("field ".concat(f, " does not have an 'assign' tag"));
                        }
                        else {
                            var valToBe = codeGenExpr(f.value, locals);
                            if (valToBe.length > 1) {
                                throw new Error("The compiled fields is not a literal");
                            }
                            if (obj_field_type_idx.get(expr.name) === undefined) {
                                console.log("detect undefind for OFI: ".concat(expr.name));
                                obj_field_type_idx.set(expr.name, new Map());
                            }
                            if (obj_field_type_idx.get(obj_name_reg) === undefined) {
                                obj_field_type_idx.set(obj_name_reg, new Map());
                            }
                            console.log("adding this entry:".concat(f.name, ",").concat(index));
                            obj_field_type_idx.get(expr.name).set(f.name, [f.a, index]);
                            obj_field_type_idx.get(obj_name_reg).set(f.name, [f.a, index]);
                        }
                        initvals = __spreadArray(__spreadArray([], initvals, true), [
                            "(global.get $heap)",
                            "(i32.add (i32.const ".concat(offset, "))"),
                            valToBe[0],
                            "i32.store"
                        ], false);
                    });
                    console.log("ONR:", obj_name_reg);
                    classdata.methods.forEach(function (func, f_name) {
                        var new_name = "".concat(f_name, "$").concat(obj_name_reg);
                        var func_string = codeGenFunDef(__assign(__assign({}, func), { name: new_name }));
                        decl_of_funcs = [decl_of_funcs.join() + func_string.join()];
                        console.log("DOF:", decl_of_funcs);
                    });
                    decl_of_funcs = decl_of_funcs.flat();
                    console.log("DOF after flat:", decl_of_funcs);
                    if (prev_obj_name_reg !== undefined) {
                        obj_name_reg = prev_obj_name_reg;
                    }
                    var return_str;
                    console.log("STR TO PUSH", str_push_tmp_name);
                    if (str_push_tmp_name !== undefined) {
                        return_str = __spreadArray(__spreadArray([], initvals, true), [
                            "(global.get $heap)",
                            "(global.set $heap (i32.add (global.get $heap) (i32.const ".concat(classdata.fields.length * 4, ")))"),
                            str_push_tmp_name
                        ], false);
                    }
                    else {
                        return_str = __spreadArray(__spreadArray([], initvals, true), [
                            "(global.get $heap)",
                            "(global.set $heap (i32.add (global.get $heap) (i32.const ".concat(classdata.fields.length * 4, ")))")
                        ], false);
                    }
                    return return_str;
                }
            }
            var valStmts = expr.args.map(function (e) { return codeGenExpr(e, locals); }).flat();
            var toCall = expr.name;
            if (expr.name === "print") {
                console.log("parse print, a = " + expr.args[0]);
                switch (expr.args[0].a) {
                    case "bool":
                        toCall = "print_bool";
                        break;
                    case "int":
                        toCall = "print_num";
                        break;
                    case "none":
                        toCall = "print_none";
                        break;
                    default:
                        throw new Error("PRINT ERROR: annotation = ".concat(expr.args[0].a));
                        break;
                }
            }
            valStmts.push("(call $".concat(toCall, ")"));
            console.log(valStmts);
            return valStmts;
        case "method":
            if (expr.tag == "method") {
                //Tricky here, use empty env to init
                var argInstrs = expr.args.map(function (a) { return codeGenExpr(a, emptyEnv); }).flat();
                var anno_obj = expr.obj.a;
                var method_support_type = void 0;
                (function (method_support_type) {
                    method_support_type[method_support_type["id"] = 0] = "id";
                    method_support_type[method_support_type["method"] = 1] = "method";
                    method_support_type[method_support_type["getfield"] = 2] = "getfield";
                    method_support_type[method_support_type["call"] = 3] = "call";
                })(method_support_type || (method_support_type = {}));
                if (anno_obj != "int" && anno_obj != "none" && anno_obj != "bool") {
                    var eobj = expr.obj;
                    var eobj_stmt = [];
                    var tmp_name = obj_name_reg;
                    if (eobj.tag == "id") {
                    }
                    else {
                        // Currently it can be a call
                        var prev_length = tmp_vars.length;
                        var eobj_stmt = codeGenExpr(eobj, locals);
                        if (prev_length != tmp_vars.length) {
                            tmp_name = tmp_vars[tmp_vars.length - 1];
                        }
                    }
                    if (eobj.tag == 'self') {
                        eobj = { tag: 'id', name: obj_name_reg, a: eobj.a };
                    }
                    if (eobj.tag == "id" || eobj.tag == "method" || eobj.tag == "getfield" || eobj.tag == "call") {
                        var method_stmts;
                        if (eobj_stmt.length > 0) {
                            console.log("Got recursive expr in obj: tmp_name", tmp_name);
                            method_stmts = __spreadArray(__spreadArray(__spreadArray([], eobj_stmt, true), argInstrs, true), ["call $".concat(expr.name, "$").concat(tmp_name)], false);
                        }
                        else {
                            method_stmts = __spreadArray(__spreadArray([], argInstrs, true), ["call $".concat(expr.name, "$").concat(eobj.name)], false);
                        }
                    }
                    else {
                        throw new Error("Here obj tag must be supported");
                    }
                }
            }
            console.log("method_stmts:", method_stmts);
            return method_stmts;
        case "getfield":
            var anno = expr.obj.a;
            if (anno != "int" && anno != "none" && anno != "bool") {
                var objexprs = codeGenExpr(expr.obj, locals);
                // if (expr.obj.tag=="self"){
                //   //donothing
                // }else{
                // }
                if (expr.obj.tag != 'id') {
                    if (expr.obj.tag == 'self') {
                        expr.a = obj_field_type_idx.get(obj_name_reg).get(expr.name)[0];
                        expr.obj = { tag: 'id', name: obj_name_reg, a: expr.obj.a };
                    }
                    else {
                        throw new Error("obj tag is not 'id' or 'self', instead it's ".concat(expr.obj.tag));
                    }
                }
                var objdata = obj_field_type_idx.get(expr.obj.name);
                if (objdata === undefined) {
                    throw new Error("RUNTIME ERROR: objdata of ".concat(expr.obj.name, " is undefined"));
                }
                console.log("getfield ".concat(expr.name, " of ").concat(expr.obj.name, ", objdata"));
                var iof = objdata.get(expr.name)[1];
                return ["(global.get $".concat(expr.obj.name, ")"), "(i32.add (i32.const ".concat(iof * 4, "))"), "(i32.load)"];
            }
            else {
                throw new Error("obj get an annotation of ".concat(anno));
            }
        case "self":
            if (locals.has(obj_name_reg)) {
                return ["(local.get $".concat(obj_name_reg, ")")];
            }
            else {
                return ["(global.get $".concat(obj_name_reg, ")")];
            }
        default:
            throw new Error("Expr ".concat(expr, " not implemented!"));
    }
}
exports.codeGenExpr = codeGenExpr;
function codeGenFunDef(m) {
    var emptyEnv = new Map();
    var withParamsAndVariables = new Map(emptyEnv.entries());
    var i = m.name.indexOf('$');
    if (i != -1) {
        var prev_obj_name_reg = obj_name_reg;
        obj_name_reg = m.name.slice(i + 1);
    }
    // Construct the environment for the function body
    var variables = variableNames(m.body);
    variables.forEach(function (v) { return withParamsAndVariables.set(v, true); });
    m.params.forEach(function (p) { return withParamsAndVariables.set(p.name, true); });
    // Construct the code for params and variable declarations in the body
    var params = m.params.map(function (p) {
        //Ignore self
        if (p.name != "self") {
            return "(param $".concat(p.name, " i32)");
        }
    }).join(" ");
    var varDecls = variables.map(function (v) { return "(local $".concat(v, " i32)"); }).join("\n");
    // Very Tricky here, we ignore the global variable
    var stmts = m.body.map(function (s) { return codeGenStmt(s, withParamsAndVariables, emptyEnv); }).flat();
    var stmtsBody = stmts.join("\n");
    if (prev_obj_name_reg !== undefined && prev_obj_name_reg != obj_name_reg) {
        obj_name_reg = prev_obj_name_reg;
    }
    return ["(func $".concat(m.name, " ").concat(params, " (result i32)\n        (local $scratch i32)\n        ").concat(varDecls, "\n        ").concat(stmtsBody, "\n        (i32.const 0))")];
}
exports.codeGenFunDef = codeGenFunDef;
function codeGenClass(c) {
    // Currently do not want add any globals when generating class
    var methods = [];
    if (c.tag != "class") {
        throw new Error("CGC ERROR: Statement tag is not 'class', should not call CGC");
    }
    else {
        c.methods.forEach(function (m, i) {
            var this_fun = codeGenFunDef(__assign(__assign({}, m), { name: "$".concat(m.name, "$").concat(c.name) }));
            methods.concat(this_fun);
        });
        methods = methods.flat();
    }
    return methods;
}
exports.codeGenClass = codeGenClass;
function codeGenStmt(stmt, locals, global_vars) {
    var withParamsAndVariables = new Map(locals.entries());
    var emptyEnv = new Map();
    switch (stmt.tag) {
        case "class":
            // push class_name to classes
            classes.set(stmt.name, stmt);
            // set class name reg to enable self-parsing
            // cls_name_reg = stmt.name;
            // // construct class variables
            // const cls_vars = variableNames(stmt.fields,stmt.name);
            // cls_vars.forEach(v => withParamsAndVariables.set(v, true));
            // //Construct methods for each class
            // const varDeclCls = cls_vars.map(cv => `local $${cv} i32`).join("\n");
            // // NOTE: very tricky here, we just don't pass global env to code gen when gen class methods
            // // NOTE: 0426, even more tricky, have to convert map into a list
            // const funcCls = codeGenClass(stmt)
            // const funcClsBody = funcCls.join("\n");
            // //Reset class name reg
            // cls_name_reg = "none";
            return;
        case "define":
            // Construct the environment for the function body
            var variables = variableNames(stmt.body);
            variables.forEach(function (v) { return withParamsAndVariables.set(v, true); });
            stmt.params.forEach(function (p) { return withParamsAndVariables.set(p.name, true); });
            // Construct the code for params and variable declarations in the body
            var params = stmt.params.map(function (p) { return "(param $".concat(p.name, " i32)"); }).join(" ");
            var varDecls = variables.map(function (v) { return "(local $".concat(v, " i32)"); }).join("\n");
            var stmts = stmt.body.map(function (s) { return codeGenStmt(s, withParamsAndVariables, global_vars); }).flat();
            var stmtsBody = stmts.join("\n");
            return ["(func $".concat(stmt.name, " ").concat(params, " (result i32)\n        (local $scratch i32)\n        ").concat(varDecls, "\n        ").concat(stmtsBody, "\n        (i32.const 0))")];
        case "return":
            var valStmts = codeGenExpr(stmt.value, locals);
            valStmts.push("return");
            return valStmts;
        case "assign":
            var ofi = obj_field_type_idx;
            if (stmt.value.tag == 'call' && classes.has(stmt.value.name)) {
                // We are creating an object
                console.log("Creating object ".concat(stmt.name, " from ").concat(stmt.value.name));
                var prev_obj_name_reg = obj_name_reg;
                obj_name_reg = stmt.name;
                console.log("prev_obj", prev_obj_name_reg, "obj", obj_name_reg);
                var svn = stmt.value.name;
                ofi.set(stmt.name, ofi.get(svn));
                ofi.delete(svn);
            }
            else {
                if (stmt.value.hasOwnProperty('a') && (0, tc_1.isObject)(stmt.value.a)) {
                    // shallow copy object to object
                    if (stmt.value.tag == 'id' && ofi.has(stmt.value.name)) {
                        var svn = stmt.value.name;
                        ofi.set(stmt.name, ofi.get(svn));
                    }
                    else {
                        throw new Error("try to copy object,but ".concat(stmt.value, " is NOT an object"));
                    }
                }
            }
            var valStmts = codeGenExpr(stmt.value, locals);
            if (stmt.name.includes(".")) {
                // Deal with Setfield
                var obj_name = stmt.name.split('.', 2)[0];
                if (obj_name == 'self') {
                    obj_name = obj_name_reg;
                }
                var fld_name = stmt.name.split('.', 2)[1];
                var iof = obj_field_type_idx.get(obj_name).get(fld_name)[1];
                var lst_of_stmts = __spreadArray(__spreadArray([
                    "(global.get $".concat(obj_name, ")"),
                    "(i32.add (i32.const ".concat(iof * 4, "))")
                ], valStmts, true), [
                    "i32.store"
                ], false);
                valStmts = lst_of_stmts;
            }
            else {
                if (locals.has(stmt.name)) {
                    valStmts.push("(local.set $".concat(stmt.name, ")"));
                }
                else {
                    // Dealing with globals
                    valStmts.push("(global.set $".concat(stmt.name, ")"));
                }
            }
            if (prev_obj_name_reg !== undefined && prev_obj_name_reg != obj_name_reg) {
                obj_name_reg = prev_obj_name_reg;
            }
            console.log("AFTER: prev_obj", prev_obj_name_reg, "obj", obj_name_reg);
            return valStmts;
        case "expr":
            var result = codeGenExpr(stmt.expr, locals);
            result.push("(local.set $scratch)");
            return result;
        case "pass":
            var donothing = [];
            return donothing;
        case "if":
            //  { a?: A, tag: "if", cond: Expr<A>, body: Stmt<A>[], else_body: Stmt<A>[]}
            var condExpr = codeGenExpr(stmt.cond, locals); //generate condition
            var out = condExpr.concat(["(if"]).concat(["(then"]);
            var body_stmts = stmt.body.map(function (s) { return (codeGenStmt(s, locals, global_vars)).flat().join("\n"); }); //generate then body
            out = out.concat(body_stmts).concat([")"]);
            if (stmt.else_body.length > 0) {
                out = out.concat("(else");
                var else_stmts = stmt.else_body.map(function (s) { return (codeGenStmt(s, locals, global_vars)).flat().join("\n"); }); //generate the else body
                out = out.concat(else_stmts).concat(")");
            }
            //end the if statement
            out = out.concat([")"]);
            return out;
        case "while":
            // { a?: A, tag: "while",cond: Expr <A>, body: Stmt<A>[]}
            var condwhile = codeGenExpr(stmt.cond, locals);
            var whileout = condwhile.concat(["(if"]).concat(["(then"]);
            // Need to check the cond before enter this loop
            whileout = whileout.concat(["(loop $myLoop".concat(loop_counter)]);
            var body_stmts = stmt.body.map(function (s) { return (codeGenStmt(s, locals, global_vars)).flat().join("\n"); });
            whileout = whileout.concat(body_stmts);
            whileout = whileout.concat(condwhile).concat(["br_if $myLoop".concat(loop_counter)]);
            //Endloop
            whileout = whileout.concat([")"]);
            //Endwhile(
            whileout = whileout.concat([")"]).concat([")"]);
            loop_counter += 1;
            return whileout;
    }
}
exports.codeGenStmt = codeGenStmt;
function compile(source) {
    var ast = (0, parser_1.parseProgram)(source);
    obj_field_type_idx = new Map();
    console.log("parsed program, ast:", ast);
    ast = (0, tc_1.tcProgram)(ast);
    console.log("after tc, ast:", ast);
    decl_of_funcs = [];
    var emptyEnv = new Map();
    tmp_vars = [];
    var _a = varsFunsStmts(ast), vars = _a[0], funs = _a[1], stmts = _a[2];
    var funsCode = funs.map(function (f) { return codeGenStmt(f, emptyEnv, emptyEnv); }).map(function (f) { return f.join("\n"); });
    var allFuns = funsCode.join("\n\n");
    var varDecls = vars.map(function (v) { return "(global $".concat(v, " (mut i32) (i32.const 0))"); }).join("\n");
    console.log("compile-stmts:", stmts);
    var allStmts = stmts.map(function (s) { return codeGenStmt(s, emptyEnv, emptyEnv); }).flat();
    var main = __spreadArray(["(local $scratch i32)"], allStmts, true).join("\n");
    var lastStmt = ast[ast.length - 1];
    var isExpr = lastStmt.tag === "expr";
    var retType = "";
    var retVal = "";
    if (isExpr) {
        retType = "(result i32)";
        retVal = "(local.get $scratch)";
    }
    var tmpvarDecls = tmp_vars.map(function (v) { return "(global $".concat(v, " (mut i32) (i32.const 0))"); }).join("\n");
    return "\n    (module\n      (func $print_num (import \"imports\" \"print_num\") (param i32) (result i32))\n      (func $print_bool (import \"imports\" \"print_bool\") (param i32) (result i32))\n      (func $print_none (import \"imports\" \"print_none\") (param i32) (result i32))\n      (memory (import \"imports\" \"mem\") 1)\n      (global $heap (mut i32) (i32.const 4))\n      ".concat(varDecls, "\n      ").concat(tmpvarDecls, "\n      ").concat(decl_of_funcs, "\n      ").concat(allFuns, "\n      (func (export \"_start\") ").concat(retType, "\n        ").concat(main, "\n        ").concat(retVal, "\n      )\n    ) \n  ");
}
exports.compile = compile;


/***/ }),

/***/ "./parser.ts":
/*!*******************!*\
  !*** ./parser.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = exports.traverse = exports.traverseArguments = exports.traverseExpr = exports.traverseParameters = exports.traverseType = exports.traverseStmt = exports.traverseStmts = exports.parseProgram = void 0;
var lezer_python_1 = __webpack_require__(/*! lezer-python */ "./node_modules/lezer-python/dist/index.cjs");
var ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
var supportedTypes = ["int", "none", "bool"];
var cls_name_reg = "none";
function parseProgram(source) {
    var t = lezer_python_1.parser.parse(source).cursor();
    return traverseStmts(source, t);
}
exports.parseProgram = parseProgram;
function traverseStmts(s, t) {
    // The top node in the program is a Script node with a list of children
    // that are various statements
    t.firstChild();
    var stmts = [];
    do {
        stmts.push(traverseStmt(s, t));
    } while (t.nextSibling()); // t.nextSibling() returns false when it reaches
    //  the end of the list of children
    t.parent();
    return stmts;
}
exports.traverseStmts = traverseStmts;
/*
  Invariant – t must focus on the same node at the end of the traversal
*/
function traverseStmt(s, t) {
    switch (t.type.name) {
        case "ReturnStatement":
            t.firstChild(); // Focus return keyword
            t.nextSibling(); // Focus expression
            var value = traverseExpr(s, t);
            t.parent();
            return { tag: "return", value: value };
        case "AssignStatement":
            t.firstChild(); // focused on name (the first child)
            var name = s.substring(t.from, t.to);
            t.nextSibling(); // focused on :type part, explained in Chocopy
            var anno = s.substring(t.from + 1, t.to).trim(); // Use +2 to skip the :
            t.nextSibling(); // focused on = sign. May need this for complex tasks, like +=!
            t.nextSibling(); // focused on the value expression
            var value = traverseExpr(s, t);
            t.parent();
            console.log("Assign-return:", { a: anno, tag: "assign", name: name, value: value });
            return { a: anno, tag: "assign", name: name, value: value };
        case "ExpressionStatement":
            t.firstChild(); // The child is some kind of expression, the
            // ExpressionStatement is just a wrapper with no information
            var expr = traverseExpr(s, t);
            t.parent();
            return { tag: "expr", expr: expr };
        case "FunctionDefinition":
            t.firstChild(); // Focus on def
            t.nextSibling(); // Focus on name of function
            var name = s.substring(t.from, t.to);
            t.nextSibling(); // Focus on ParamList
            var params = traverseParameters(s, t);
            t.nextSibling(); // Focus on Body or TypeDef
            var ret = "none";
            var maybeTD = t;
            if (maybeTD.type.name === "TypeDef") {
                t.firstChild();
                ret = traverseType(s, t);
                t.parent();
            }
            t.nextSibling(); // Focus on single statement (for now)
            t.firstChild(); // Focus on :
            var body = [];
            while (t.nextSibling()) {
                body.push(traverseStmt(s, t));
            }
            t.parent(); // Pop to Body
            t.parent(); // Pop to FunctionDefinition
            return {
                tag: "define",
                name: name,
                params: params,
                body: body,
                ret: ret
            };
        case "ClassDefinition":
            t.firstChild(); // Focus on def
            t.nextSibling(); // Focus on name of function
            var name = s.substring(t.from, t.to);
            supportedTypes.push(name);
            cls_name_reg = name;
            t.nextSibling(); // Focus on object, the original param list
            //no params here, as only "object" is allowed
            t.nextSibling(); // Focus on Body or TypeDef
            t.nextSibling(); // Focus on single statement (for now)
            t.firstChild(); // Focus on :
            var varInits = [];
            var clsBody = new Map();
            while (t.nextSibling()) {
                var cls_stmt = traverseStmt(s, t);
                if (cls_stmt.tag == "define") {
                    // { a?: A, tag: "class", name:string, fields: Stmt<A>[], methods: Map <string, FunDef<A>>}
                    clsBody.set(cls_stmt.name, { name: cls_stmt.name, params: cls_stmt.params,
                        ret: cls_stmt.ret, inits: varInits, body: cls_stmt.body });
                }
                else {
                    if (cls_stmt.tag == "assign") {
                        varInits.push(cls_stmt);
                    }
                    else {
                        throw new Error("PARSER ERROR: unsupported statements type for class definition");
                    }
                }
            }
            t.parent(); // Pop to Body
            t.parent(); // Pop to FunctionDefinition
            console.log("class_name", name);
            cls_name_reg = "none";
            return {
                a: name,
                tag: "class",
                name: name,
                fields: varInits,
                methods: clsBody
            };
        case "PassStatement":
            return { tag: "pass" };
        case "IfStatement":
            t.firstChild();
            t.nextSibling();
            var cond_expr = traverseExpr(s, t);
            t.nextSibling(); //focus on body
            t.firstChild(); //focus on :
            var stmt_b = [];
            var else_stmt_b = [];
            while (t.nextSibling()) {
                stmt_b.push(traverseStmt(s, t));
            }
            t.parent();
            t.nextSibling();
            if (t.node.type.name === "else") {
                t.nextSibling(); //focus on body
                t.firstChild(); //focus on :
                while (t.nextSibling()) {
                    else_stmt_b.push(traverseStmt(s, t));
                }
                t.parent();
                t.parent();
                return { tag: "if", cond: cond_expr, body: stmt_b, else_body: else_stmt_b };
            }
            else {
                t.parent();
                return { tag: "if", cond: cond_expr, body: stmt_b, else_body: else_stmt_b };
            }
        case "WhileStatement":
            t.firstChild();
            t.nextSibling();
            var cond_while = traverseExpr(s, t);
            t.nextSibling(); //focus on body
            t.firstChild(); //focus on :
            var stmt_w = [];
            while (t.nextSibling()) {
                stmt_w.push(traverseStmt(s, t));
            }
            t.parent();
            t.parent();
            return { tag: "while", cond: cond_while, body: stmt_w };
    }
}
exports.traverseStmt = traverseStmt;
function traverseType(s, t) {
    switch (t.type.name) {
        case "VariableName":
            var name_1 = s.substring(t.from, t.to);
            // // if(name !== "int" && name !=="none" && name !== "bool") {
            // if (!supportedTypes.includes(name)){
            //   throw new Error("Unknown VariableName type: " + name)
            // }
            var return_name = name_1;
            return return_name;
        default:
            throw new Error("Unknown non-VariableName type: " + t.type.name);
    }
}
exports.traverseType = traverseType;
function traverseParameters(s, t) {
    t.firstChild(); // Focuses on open paren
    var parameters = [];
    t.nextSibling(); // Focuses on a VariableName
    while (t.type.name !== ")") {
        var name_2 = s.substring(t.from, t.to);
        t.nextSibling(); // Focuses on "TypeDef", hopefully, or "," if mistake
        var nextTagName = t.type.name; // NOTE(joe): a bit of a hack so the next line doesn't if-split
        if (nextTagName !== "TypeDef") {
            throw new Error("Missed type annotation for parameter " + name_2);
        }
        ;
        t.firstChild(); // Enter TypeDef
        t.nextSibling(); // Focuses on type itself
        var typ = traverseType(s, t);
        t.parent();
        t.nextSibling(); // Move on to comma or ")"
        parameters.push({ name: name_2, typ: typ });
        t.nextSibling(); // Focuses on a VariableName
    }
    t.parent(); // Pop to ParamList
    return parameters;
}
exports.traverseParameters = traverseParameters;
function traverseExpr(s, t) {
    switch (t.type.name) {
        case "None":
            return { tag: "none" };
        case "Boolean":
            if (s.substring(t.from, t.to) === "True") {
                return { tag: "true" };
            }
            else {
                return { tag: "false" };
            }
        case "Number":
            return { tag: "number", value: Number(s.substring(t.from, t.to)) };
        case "VariableName":
            return { tag: "id", name: s.substring(t.from, t.to) };
        case "CallExpression":
            t.firstChild(); // Focus name
            var name = s.substring(t.from, t.to);
            if (name.includes('.')) {
                var obj_parsed = traverseExpr(s, t);
            }
            var result;
            t.nextSibling(); // Focus ArgList
            t.firstChild(); // Focus open paren
            var args = traverseArguments(t, s);
            t.prevSibling();
            if (name.includes('.')) {
                if (obj_parsed.tag == "getfield") {
                    result = { tag: "method", obj: obj_parsed.obj, name: obj_parsed.name, args: args };
                }
            }
            else {
                result = { tag: "call", name: name, args: args };
            }
            t.parent();
            return result;
        case "UnaryExpression":
            t.firstChild();
            var uop = s.substring(t.from, t.to);
            switch (uop) {
                case '-':
                    t.nextSibling();
                    var this_var = traverseExpr(s, t);
                    if (this_var.tag == "id") {
                        t.parent();
                        return { tag: 'binop', op: '*', lhs: { a: "int", tag: "number", value: -1 }, rhs: this_var };
                    }
                    var num = Number(uop + s.substring(t.from, t.to));
                    if (isNaN(num)) {
                        throw new Error("PARSE ERROR: unary operation failed");
                    }
                    t.parent();
                    return { tag: "number", value: num };
                case '+':
                    t.nextSibling();
                    var this_var = traverseExpr(s, t);
                    if (this_var.tag == "id") {
                        t.parent();
                        return { tag: 'binop', op: '*', lhs: { a: "int", tag: "number", value: 1 }, rhs: this_var };
                    }
                    var num = Number(uop + s.substring(t.from, t.to));
                    if (isNaN(num)) {
                        throw new Error("PARSE ERROR: unary operation failed");
                    }
                    t.parent();
                    return { tag: "number", value: num };
                case "not":
                    var not_result;
                    t.nextSibling();
                    if (s.substring(t.from, t.to) === "True") {
                        not_result = { tag: "false" };
                    }
                    else {
                        not_result = { tag: "true" };
                    }
                    t.parent();
                    return not_result;
                case "default":
                    throw new Error("PARSE ERROR: unimplemented unary op");
            }
        case "BinaryExpression":
            t.firstChild(); // go to lhs
            var lhsExpr = traverseExpr(s, t);
            t.nextSibling(); // go to op
            var opStr = s.substring(t.from, t.to);
            if (!(0, ast_1.isOp)(opStr)) {
                throw new Error("Unknown or unhandled op: ".concat(opStr));
            }
            t.nextSibling(); // go to rhs
            var rhsExpr = traverseExpr(s, t);
            t.parent();
            return {
                tag: "binop",
                op: opStr,
                lhs: lhsExpr,
                rhs: rhsExpr
            };
        case "ParenthesizedExpression":
            t.firstChild(); // focus on (
            t.nextSibling();
            var paren_exp = traverseExpr(s, t);
            t.nextSibling(); // focus on )
            t.parent();
            return paren_exp;
        case "MemberExpression":
            t.firstChild(); //focus on variable name like "c","self"
            var cls_name = s.substring(t.from, t.to);
            var cls_obj = traverseExpr(s, t);
            t.nextSibling();
            t.nextSibling(); // focus on property name
            var property_name = s.substring(t.from, t.to);
            var result;
            // Try to parse self with a register
            if (cls_name == "self") {
                if (cls_name_reg == "none") {
                    throw new Error("Illegal self here");
                }
                else {
                    cls_name = cls_name_reg;
                }
            }
            t.parent();
            console.log("Member Expression, obj:".concat(cls_obj, ", name:").concat(property_name));
            result = { tag: "getfield", obj: cls_obj, name: property_name };
            return result;
        case "self":
            return { tag: "self", a: { tag: "object", class: cls_name_reg } };
        default:
            throw new Error("Expression not included in traverseExpr: ".concat(t.type.name, ", ").concat(s.substring(t.from, t.to)));
    }
}
exports.traverseExpr = traverseExpr;
function traverseArguments(c, s) {
    c.firstChild(); // Focuses on open paren
    var args = [];
    c.nextSibling();
    while (c.type.name !== ")") {
        var expr = traverseExpr(s, c);
        args.push(expr);
        c.nextSibling(); // Focuses on either "," or ")"
        c.nextSibling(); // Focuses on a VariableName
    }
    c.parent(); // Pop to ArgList
    return args;
}
exports.traverseArguments = traverseArguments;
function traverse(c, s) {
    switch (c.node.type.name) {
        case "Script":
            var stmts = [];
            c.firstChild();
            do {
                stmts.push(traverseStmt(s, c));
            } while (c.nextSibling());
            console.log("traversed " + stmts.length + " statements ", stmts, "stopped at ", c.node);
            return stmts;
        default:
            throw new Error("Could not parse program at " + c.node.from + " " + c.node.to);
    }
}
exports.traverse = traverse;
function parse(source) {
    var t = lezer_python_1.parser.parse(source);
    return traverse(t.cursor(), source);
}
exports.parse = parse;


/***/ }),

/***/ "./tc.ts":
/*!***************!*\
  !*** ./tc.ts ***!
  \***************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CLASS = exports.assignableTo = exports.isObject = exports.tcLiteral = exports.tcProgram = exports.tcStmt = exports.tcExpr = exports.tcParams = exports.tcVarInits = void 0;
var ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
var ast_2 = __webpack_require__(/*! ./ast */ "./ast.ts");
var objEnv;
var obj_name_reg = "none";
function duplicateEnv(env) {
    return { vars: new Map(env.vars), funs: new Map(env.funs), retType: env.retType };
}
function tcVarInits(inits, env) {
    var typedInits = [];
    inits.forEach(function (init) {
        var typedInit = tcLiteral(init.init);
        if (typedInit.a !== init.type)
            throw new Error("TYPE ERROR: init type does not match literal type");
        env.vars.set(init.name, init.type);
        typedInits.push(__assign(__assign({}, init), { a: init.type, init: typedInit }));
    });
    return typedInits;
}
exports.tcVarInits = tcVarInits;
function tcParams(params) {
    return params.map(function (param) {
        return __assign(__assign({}, param), { a: param.type });
    });
}
exports.tcParams = tcParams;
// export function tcFunDef(fun:FunDef<any>, cls : ClassEnv, env: TypeEnv): FunDef<Type>{
//   const localEnv = duplicateEnv(env)
//   //add params to env
//   fun.params.forEach(param=>{
//     localEnv.vars.set(param.name,param.type);
//   })
//   const typedParams = tcParams(fun.params);
//   //Add inits
//   const typedInits = tcVarInits(fun.inits, env);
//   fun.inits.forEach(init=>{
//     localEnv.vars.set(init.name,init.type);
//   })
//   localEnv.funs.set(fun.name,[fun.params.map(param=>param.type), fun.ret]);
//   //Check body
//   const typedStmts = tcStmt(fun.body,cls,localEnv.funs,localEnv.vars,localEnv.retType);
//   return {...fun,params: typedParams, inits:typedInits, body:typedStmts};
// }
function tcExpr(e, classes, functions, variables) {
    var emptyEnv = new Map();
    switch (e.tag) {
        case "number": return __assign(__assign({}, e), { a: "int" });
        case "true": return __assign(__assign({}, e), { a: "bool" });
        case "false": return __assign(__assign({}, e), { a: "bool" });
        case "none": return __assign(__assign({}, e), { a: "none" });
        case "binop": {
            // We currently enforce the lhs and rhs must be int
            var left = tcExpr(e.lhs, classes, functions, variables);
            var right = tcExpr(e.rhs, classes, functions, variables);
            e.lhs = left;
            e.rhs = right;
            if (e.op == 'is') {
                // "is" operator logic
                console.log("is op, left, right", left, right);
                if (left.a == "int" || left.a == "bool") {
                    throw new Error("TYPE ERROR: LHS of 'is' must be an object");
                }
                if (right.a == "int" || right.a == "bool") {
                    throw new Error("TYPE ERROR: RHS of 'is' must be an object");
                }
                return __assign(__assign({}, e), { a: "bool" });
            }
            if ((0, ast_2.isintOp)(e.op)) {
                if (e.lhs.a != "int" || e.rhs.a != "int") {
                    console.log("TC Variables", variables);
                    throw new Error("TYPE ERROR: LHS,RHS of ".concat(e.op, " must be both int, instead, we have ").concat(e.lhs.a, ",").concat(e.rhs.a));
                }
                var return_bool_ops = [">", "<", ">=", "<="];
                console.log(return_bool_ops.includes(e.op));
                if (return_bool_ops.includes(e.op)) {
                    return __assign(__assign({}, e), { a: "bool" });
                }
                return __assign(__assign({}, e), { a: "int" });
            }
            else {
                if ((0, ast_2.isboolOp)(e.op)) {
                    if (e.lhs.a != "bool" || e.rhs.a != "bool") {
                        throw new Error("TYPE ERROR: LHS,RHS of ".concat(e.op, " must be both bool, instead, we have ").concat(e.lhs.a, ",").concat(e.rhs.a));
                    }
                    return __assign(__assign({}, e), { a: "bool" });
                }
                else {
                    if ((0, ast_1.issameOp)(e.op)) {
                        if (e.lhs.a == e.rhs.a) {
                            return __assign(__assign({}, e), { a: "bool" });
                        }
                        else {
                            throw new Error("TYPE ERROR: LHS,RHS of ".concat(e.op, " must be of same type, instead, we have ").concat(e.lhs.a, ",").concat(e.rhs.a));
                        }
                    }
                    else {
                        throw new Error("TYPE ERROR: [tc.ts]Unhandled binary op ".concat(e.op));
                    }
                }
            }
        }
        case "id": return __assign(__assign({}, e), { a: variables.get(e.name) });
        case "call":
            var result;
            if (e.name === "print") {
                if (e.args.length !== 1) {
                    throw new Error("TYPE ERROR: print expects a single argument");
                }
                var newArgs_1 = [tcExpr(e.args[0], classes, functions, variables)];
                var res = __assign(__assign({}, e), { a: "none", args: newArgs_1 });
                return res;
            }
            if (classes.has(e.name)) {
                // Calling class()
                var class_stmt = classes.get(e.name);
                if (class_stmt.tag != "class") {
                    throw new Error("TYPE ERROR: Variable ".concat(e.name, " should be a class, however its tag is not"));
                }
                else {
                    class_stmt.fields.forEach(function (vi) {
                        if (vi.tag != "assign") {
                            throw new Error("TYPE ERROR: fields with non-assign tag");
                        }
                        else {
                            if (obj_name_reg == "none") {
                                //Comeon!
                            }
                            else {
                                variables.set("".concat(obj_name_reg, ".").concat(vi.name), vi.a);
                                console.log("Append this entry: ".concat(obj_name_reg, ".").concat(vi.name, " to variables"));
                            }
                        }
                    });
                    return __assign(__assign({}, e), { a: { tag: "object", class: class_stmt.name } });
                }
            }
            else {
                if (!functions.has(e.name)) {
                    throw new Error("TYPE ERROR: function ".concat(e.name, " not found"));
                }
                var _a = functions.get(e.name), args = _a[0], ret = _a[1];
                if (args.length !== e.args.length) {
                    throw new Error("TYPE ERROR: TC-call-function:Expected ".concat(args.length, " arguments but got ").concat(e.args.length));
                }
                var newArgs_2 = args.map(function (a, i) {
                    var argtyp = tcExpr(e.args[i], classes, functions, variables);
                    if (a !== argtyp.a) {
                        throw new Error("TYPE ERROR: Got ".concat(argtyp, " as argument ").concat(i + 1, ", expected ").concat(a));
                    }
                    return argtyp;
                });
                result = __assign(__assign({}, e), { a: ret, args: newArgs_2 });
            }
            return result;
        case "literal":
            e.literal = tcLiteral(e.literal);
            return __assign(__assign({}, e), { a: e.literal.a });
        case "builtin2":
            var arg1 = tcExpr(e.arg1, classes, functions, variables);
            var arg2 = tcExpr(e.arg2, classes, functions, variables);
            if (arg1.a != "int") {
                throw new Error("TYPE ERROR: Left must be int");
            }
            if (arg2.a != "int") {
                throw new Error("TYPE ERROR: Right must be int");
            }
            return __assign(__assign({}, e), { a: "int" });
        case "method":
            var newObj = tcExpr(e.obj, classes, functions, variables);
            var newArgs;
            if (newObj.a != "int" && newObj.a != "bool" && newObj.a != "none") {
                if (newObj.a.tag !== "object") {
                    throw "Non-object type in method call";
                }
                if (!classes.has(newObj.a.class)) {
                    throw "Compiler error, no such class";
                }
                var classdata = classes.get(newObj.a.class);
                if (classdata.tag == "class") {
                    if (!classdata.methods.has(e.name)) {
                        throw "No such method";
                    }
                    newArgs = e.args.map(function (a) { return tcExpr(a, classes, functions, variables); });
                    var thisfun = classdata.methods.get(e.name);
                    var argTyps = thisfun.params;
                    var retType = thisfun.ret;
                    // Here we must ignore self by adding 1 to the rhs
                    if (argTyps.length !== newArgs.length + 1) {
                        throw "tc: method arg mismatch";
                    }
                    argTyps.forEach(function (t, i) {
                        if (isObject(t.typ) && !t.typ.hasOwnProperty('tag')) {
                            t.typ = { tag: "object", class: String(t.typ) };
                        }
                        if (t.name != "self" && !assignableTo(t.typ, newArgs[i - 1].a)) {
                            throw new Error("TYPE ERROR: Arg Types mismatch for ".concat(t.typ, " and ").concat(newArgs[i - 1].a));
                        }
                    });
                }
                else {
                    throw "Tag says ".concat(e.name, " is a method, but annotation says it isn't an object");
                }
            }
            else {
                if (newObj.a == "bool" || newObj.a == "int" || newObj.a == "none") {
                    throw new Error("RUNTIME ERROR: The Type of ".concat(e.obj, " should be an obj, instead it is a ").concat(newObj.a));
                }
            }
            if (isObject(retType) && !retType.hasOwnProperty('tag')) {
                //Just a normal string
                retType = { tag: "object", class: String(retType) };
            }
            return __assign(__assign({}, e), { a: retType, obj: newObj, args: newArgs });
        case "getfield":
            var cls_name;
            switch (e.obj.tag) {
                case "id":
                    var obj_type = objEnv.get(e.obj.name);
                    if (obj_type == "bool" || obj_type == "int" || obj_type == "none") {
                        throw new Error("RUNTIME ERROR: The Type of ".concat(e.obj.name, " should be an obj"));
                    }
                    else {
                        cls_name = obj_type.class;
                    }
                    break;
                case "self":
                    cls_name = e.obj.a.class;
                    break;
                case "getfield":
                    if (e.obj.a === undefined) {
                        var get_class = objEnv.get(e.obj.name);
                        if (get_class == "bool" || get_class == "int" || get_class == "none") {
                            throw new Error("TYPE ERROR: Weird. Class Statement ".concat(cls_stmt, " has tag ").concat(cls_stmt.tag));
                        }
                        else {
                            cls_name = get_class.class;
                        }
                    }
                    else {
                        cls_name = e.obj.a.class;
                    }
                    break;
                case "method":
                    cls_name = e.obj.a.class;
                    break;
                default:
                    throw new Error("TYPE ERROR: tc: getfield, not a supported datatype,but ".concat(e.obj.tag));
            }
            var cls_stmt = classes.get(cls_name);
            while (cls_stmt.tag == "assign") {
                // Parse cls_stmt
                cls_stmt = classes.get(cls_stmt.a.class);
            }
            if (cls_stmt.tag != "class") {
                throw new Error('TYPE ERROR: tc: statement is not class');
            }
            var anno;
            console.log("try to find type from this cls st_mt ".concat(cls_stmt));
            cls_stmt.fields.forEach(function (fld) {
                if (fld.tag == "assign" && fld.name == e.name) {
                    console.log(fld);
                    console.log("find type ".concat(fld.a, " for ").concat(e.name));
                    anno = fld.a;
                }
            });
            return __assign(__assign({}, e), { a: anno });
        case "self":
            return __assign({}, e);
    }
}
exports.tcExpr = tcExpr;
function tcStmt(s, classes, functions, variables, currentReturn) {
    console.log("tcStmt", s);
    switch (s.tag) {
        case "assign": {
            var self_flag = 0;
            if (s.value.tag == "call" && classes.has(s.value.name)) {
                console.log("Set ONR to ".concat(s.name));
                obj_name_reg = s.name;
                var obj_type = classes.get(s.value.name).a;
                if (isObject(obj_type) && !obj_type.hasOwnProperty('tag')) {
                    obj_type = CLASS(obj_type);
                }
                objEnv.set(s.name, obj_type);
            }
            console.log("pass the call class check");
            var rhs = tcExpr(s.value, classes, functions, variables);
            if (s.a === '') {
                if (s.name.startsWith('self.')) {
                    s.name = s.name.split('.', 2)[1];
                    self_flag = 1;
                }
                if (variables.has(s.name)) {
                    console.log("get_name", variables.get(s.name));
                    s.a = variables.get(s.name);
                }
                else {
                    throw new Error("RUNTIME ERROR: Cannot change the value of ".concat(s.name, " before its declaration"));
                }
            }
            console.log("tcStmt-assign", s.a, rhs.a);
            console.log("Assignable?", assignableTo(s.a, rhs.a));
            if (s.a == "none" && isObject(rhs.a)) {
                // check class type of lhs,rhs
                console.log("Assign class to none, with classes", classes);
                var cls_typ = objEnv.get(s.name);
                if (!assignableTo(cls_typ, rhs.a)) {
                    throw new Error("TYPE ERROR: Class Mismatch: Try to assign ".concat(rhs.a, " to ").concat(s.name, ", which is type ").concat(cls_typ));
                }
            }
            if (!assignableTo(s.a, rhs.a)) {
                // Make an exemption for assign "none" to "obj"
                throw new Error("TYPE ERROR: Cannot assign ".concat(rhs.a, " to ").concat(s.name, ", which requires ").concat(s.a));
            }
            else {
                if (rhs.a == "none" && isObject(s.a)) {
                    s.a = { tag: "object", class: s.a };
                    objEnv.set(s.name, s.a);
                }
            }
            if (variables.has(s.name) && !assignableTo(variables.get(s.name), rhs.a)) {
                throw new Error("TYPE ERROR: ".concat(s.name, " already declared, which requires ").concat(s.a));
            }
            else {
                if (rhs.a == "none") {
                    console.log("Assign None Result", variables.get(s.name));
                    variables.set(s.name, rhs.a);
                    // we don't want to change s.a here
                }
                else {
                    variables.set(s.name, rhs.a);
                }
                console.log(variables);
            }
            // classes.set(s.name,s);
            if (self_flag == 1) {
                s.name = 'self.' + s.name;
            }
            self_flag = 0;
            obj_name_reg = "none";
            return __assign(__assign({}, s), { value: rhs });
        }
        case "define": {
            var bodyvars_1 = new Map(variables.entries());
            s.params.forEach(function (p) { bodyvars_1.set(p.name, p.typ); });
            console.log("define-s.body", s.body);
            var return_flag = 0;
            var newStmts = s.body.map(function (bs) { return tcStmt(bs, classes, functions, bodyvars_1, s.ret); });
            if (s.ret != "none") {
                s.body.forEach(function (bs) {
                    if (bs.tag == "return") {
                        return_flag = 1;
                    }
                });
                if (return_flag == 0) {
                    throw new Error("TYPE ERROR: ".concat(s.ret, " never returns"));
                }
            }
            return __assign(__assign({}, s), { body: newStmts });
        }
        case "class": {
            var bodyvars = new Map(variables.entries());
            s.fields.forEach(function (vi) {
                var tc_vi = tcStmt(vi, classes, functions, bodyvars, "none");
                if (vi.tag != "assign") {
                    throw new Error("TYPE ERROR: vi ".concat(vi, "'s tag is not assign"));
                }
                else {
                    bodyvars.set(vi.name, tc_vi.a);
                }
            });
            console.log("s-fields:", s.fields);
            var new_methods = new Map();
            s.methods.forEach(function (mds, name) {
                // Trickey Here,mds here is the FunDef
                console.log(mds);
                console.log(mds.body);
                var stmt_from_mds = { a: mds.a, tag: "define", name: mds.name, params: mds.params, ret: mds.ret, body: mds.body };
                var result = tcStmt(stmt_from_mds, classes, functions, bodyvars, mds.ret);
                var mds_from_stmt = { a: result.a, name: mds.name, params: mds.params, ret: mds.ret, inits: mds.inits, body: mds.body };
                new_methods.set(name, mds_from_stmt);
            });
            s.methods = new_methods;
            return __assign(__assign({}, s), { a: "none" });
        }
        case "expr": {
            var ret = tcExpr(s.expr, classes, functions, variables);
            return __assign(__assign({}, s), { expr: ret, a: ret.a });
        }
        case "return": {
            var valTyp = tcExpr(s.value, classes, functions, variables);
            if (isObject(currentReturn)) {
                currentReturn = { tag: "object", class: String(currentReturn) };
            }
            if (!assignableTo(currentReturn, valTyp.a)) {
                throw new Error("TYPE ERROR: ".concat(valTyp, " returned but ").concat(currentReturn, " expected."));
            }
            return __assign(__assign({}, s), { value: valTyp });
        }
        case "pass": {
            return __assign({}, s);
        }
        case "if": {
            var cond = tcExpr(s.cond, classes, functions, variables);
            if (cond.a != "bool") {
                throw new Error("TYPE ERROR: ".concat(cond, " must be a bool, instead it is now ").concat(cond.a));
            }
            var new_bd_st = s.body.map(function (bs) { return tcStmt(bs, classes, functions, variables, currentReturn); });
            if (s.else_body.length === 0) {
                return __assign(__assign({}, s), { cond: cond, body: new_bd_st });
            }
            else {
                var new_elsebd_st = s.else_body.map(function (bs) { return tcStmt(bs, classes, functions, variables, currentReturn); });
                return __assign(__assign({}, s), { cond: cond, body: new_bd_st, else_body: new_elsebd_st });
            }
        }
        case "while": {
            var cond = tcExpr(s.cond, classes, functions, variables);
            if (cond.a != "bool") {
                throw new Error("TYPE ERROR: ".concat(cond, " must be a bool, instead it is now ").concat(cond.a));
            }
            var new_bd_st = s.body.map(function (bs) { return tcStmt(bs, classes, functions, variables, currentReturn); });
            return __assign(__assign({}, s), { cond: cond, body: new_bd_st });
        }
    }
}
exports.tcStmt = tcStmt;
function tcProgram(p) {
    console.log("tcprogram,p", p);
    var functions = new Map();
    var classes = new Map();
    objEnv = new Map();
    p.forEach(function (s) {
        if (s.tag === "define") {
            functions.set(s.name, [s.params.map(function (p) { return p.typ; }), s.ret]);
        }
        if (s.tag === "class") {
            classes.set(s.name, s);
        }
    });
    var globals = new Map();
    return p.map(function (s) {
        if (s.tag === "assign") {
            console.log("psmap, check assign", s.value);
            var rhs = tcExpr(s.value, classes, functions, globals);
            console.log("psmap, rhs:", rhs);
            var tc_s = tcStmt(s, classes, functions, globals, rhs.a);
            // globals.set(s.name, rhs.a);
            return __assign(__assign({}, s), { value: rhs });
        }
        else {
            var res = tcStmt(s, classes, functions, globals, "none");
            return res;
        }
    });
}
exports.tcProgram = tcProgram;
function tcLiteral(literal) {
    switch (literal.tag) {
        case "number":
            return __assign(__assign({}, literal), { a: "int" });
        case "bool":
            return __assign(__assign({}, literal), { a: "bool" });
        case "none":
            return __assign(__assign({}, literal), { a: "none" });
    }
}
exports.tcLiteral = tcLiteral;
function isObject(tp) {
    return !(tp == "int" || tp == "bool" || tp == "none");
}
exports.isObject = isObject;
function assignableTo(type_a, type_b) {
    // Rule No.0: if strictly equal, allow!
    if (type_b === type_a) {
        return true;
    }
    // Rule No.1: None is able to be assigned to everyone.
    if (type_b == "none") {
        // Very Tricky here,must be fixed later
        return isObject(type_a);
    }
    // Rule No1.5 Object is assignable to None
    if (type_a == "none" && isObject(type_b)) {
        return true;
    }
    // Rule No.2: Only Object is allowed to assign object.
    if (type_b != "int" && type_b != "bool") {
        if (type_a != "int" && type_a != "none" && type_a != "bool") {
            return type_a.class == type_b.class;
        }
    }
    return false;
}
exports.assignableTo = assignableTo;
function CLASS(name) {
    return { tag: "object", class: name };
}
exports.CLASS = CLASS;
;


/***/ }),

/***/ "./webstart.ts":
/*!*********************!*\
  !*** ./webstart.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var compiler_1 = __webpack_require__(/*! ./compiler */ "./compiler.ts");
document.addEventListener("DOMContentLoaded", function () { return __awaiter(void 0, void 0, void 0, function () {
    function display(arg) {
        var elt = document.createElement("pre");
        document.getElementById("output").appendChild(elt);
        elt.innerText = arg;
    }
    var memory, importObject, runButton, userCode;
    return __generator(this, function (_a) {
        memory = new WebAssembly.Memory({ initial: 10, maximum: 100 });
        importObject = {
            imports: {
                mem: memory,
                print_num: function (arg) {
                    console.log("Logging from WASM: ", arg);
                    display(String(arg));
                    return arg;
                },
                print_bool: function (arg) {
                    if (arg === 0) {
                        display("False");
                    }
                    else {
                        display("True");
                    }
                    return arg;
                },
                print_none: function (arg) {
                    display("None");
                    return arg;
                }
            },
        };
        runButton = document.getElementById("run");
        userCode = document.getElementById("user-code");
        runButton.addEventListener("click", function () { return __awaiter(void 0, void 0, void 0, function () {
            var program, output, wat, code, result, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        program = userCode.value;
                        output = document.getElementById("output");
                        output.innerHTML = '';
                        display("Program Output:");
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        wat = (0, compiler_1.compile)(program);
                        code = document.getElementById("generated-code");
                        code.textContent = 'Code Generated:' + wat;
                        return [4 /*yield*/, (0, compiler_1.runwatsrc)(wat, importObject)];
                    case 2:
                        result = _a.sent();
                        //output.textContent += (String(result));
                        // display(String(result));
                        output.setAttribute("style", "color: black");
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        console.error(e_1);
                        output.textContent = String(e_1);
                        output.setAttribute("style", "color: red");
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
        userCode.value = localStorage.getItem("program");
        userCode.addEventListener("keypress", function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                localStorage.setItem("program", userCode.value);
                return [2 /*return*/];
            });
        }); });
        return [2 /*return*/];
    });
}); });


/***/ }),

/***/ "wabt":
/*!***********************!*\
  !*** external "wabt" ***!
  \***********************/
/***/ ((module) => {

module.exports = wabt;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./webstart.ts");
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9sZXplci1weXRob24vZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvbGV6ZXItdHJlZS9kaXN0L3RyZWUuY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL2xlemVyL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vYXN0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vY29tcGlsZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9wYXJzZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi90Yy50cyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL3dlYnN0YXJ0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0L2V4dGVybmFsIFwid2FidFwiIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxZQUFZLG1CQUFPLENBQUMsa0RBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0FBbUM7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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eUNBQXlDLDRCQUE0QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVMsRUFBRSxFQUFFO0FBQ2I7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVMsRUFBRSxFQUFFO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQyxFQUFFLEVBQUU7Ozs7Ozs7Ozs7O0FDbEhMLHNCOzs7Ozs7VUNBQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7O1VDckJBO1VBQ0E7VUFDQTtVQUNBIiwiZmlsZSI6IndlYnN0YXJ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbGV6ZXIgPSByZXF1aXJlKCdsZXplcicpO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IFxuICBwcmludEtleXdvcmQgPSAxLFxuICBuZXdsaW5lID0gMTY0LFxuICBuZXdsaW5lQnJhY2tldGVkID0gMTY1LFxuICBuZXdsaW5lRW1wdHkgPSAxNjYsXG4gIGVvZiA9IDE2NyxcbiAgY29udGludWVCb2R5ID0gMTY4LFxuICBlbmRCb2R5ID0gMTY5LFxuICBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IDIxLFxuICBUdXBsZUV4cHJlc3Npb24gPSA0OCxcbiAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA0OSxcbiAgQXJyYXlFeHByZXNzaW9uID0gNTMsXG4gIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA1NixcbiAgRGljdGlvbmFyeUV4cHJlc3Npb24gPSA1NyxcbiAgRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uID0gNjAsXG4gIFNldEV4cHJlc3Npb24gPSA2MSxcbiAgU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA2MixcbiAgY29tcG91bmRTdGF0ZW1lbnQgPSAyMzE7XG5cbmNvbnN0IG5ld2xpbmUkMSA9IDEwLCBjYXJyaWFnZVJldHVybiA9IDEzLCBzcGFjZSA9IDMyLCB0YWIgPSA5LCBoYXNoID0gMzUsIHBhcmVuT3BlbiA9IDQwLCBkb3QgPSA0NjtcblxuY29uc3QgYnJhY2tldGVkID0gW1xuICBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiwgVHVwbGVFeHByZXNzaW9uLCBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiwgQXJyYXlFeHByZXNzaW9uLCBBcnJheUNvbXByZWhlbnNpb25FeHByZXNzaW9uLFxuICBEaWN0aW9uYXJ5RXhwcmVzc2lvbiwgRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uLCBTZXRFeHByZXNzaW9uLCBTZXRDb21wcmVoZW5zaW9uRXhwcmVzc2lvblxuXSwgcGFyZW50U3RhdGVtZW50ID0gW2NvbXBvdW5kU3RhdGVtZW50XTtcblxuY29uc3QgY2FjaGVzID0gbmV3IFdlYWtNYXA7XG5cbi8vIFBlci1pbnB1dC1zdHJlYW0gaW5kZW50YXRpb24gY2FjaGUuIGBwcmV2YCBtYXBzIGluZGVudGF0aW9uIGRlcHRoc1xuLy8gdG8gdGhlIGxhc3QgcG9zaXRpb24gYXQgd2hpY2ggYSBzdGF0ZW1lbnQgaW5kZW50ZWQgdG8gdGhhdCBkZXB0aFxuLy8gd2FzIHNlZW4uIFRoZXJlJ3MgYW4gZXh0cmEgc2V0IG9mIHNsb3RzIGZvciB0aGUgX2N1cnJlbnRfXG4vLyBpbmRlbnRhdGlvbiwgc2luY2UgdGhhdCBuZWVkcyB0byBiZSBhdmFpbGFibGUgYWxvbmdzaWRlIGEgcHJldmlvdXNcbi8vIGluZGVudGF0aW9uIHBvc2l0aW9uIGF0IHRoZSBzYW1lIGxldmVsLlxuY2xhc3MgQ2FjaGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxhc3QgPSB0aGlzLmxhc3RJbmRlbnQgPSAtMTtcbiAgICB0aGlzLnByZXYgPSBbXTtcbiAgfVxuXG4gIGdldChwb3MpIHtcbiAgICBpZiAodGhpcy5sYXN0ID09IHBvcykgcmV0dXJuIHRoaXMubGFzdEluZGVudFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wcmV2Lmxlbmd0aDsgaSsrKSBpZiAodGhpcy5wcmV2W2ldID09IHBvcykgcmV0dXJuIGlcbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHNldChwb3MsIGluZGVudCkge1xuICAgIGlmIChwb3MgPT0gdGhpcy5sYXN0KSByZXR1cm5cbiAgICBpZiAodGhpcy5sYXN0ID4gLTEpIHRoaXMuc2V0UHJldih0aGlzLmxhc3QsIHRoaXMubGFzdEluZGVudCk7XG4gICAgdGhpcy5sYXN0ID0gcG9zO1xuICAgIHRoaXMubGFzdEluZGVudCA9IGluZGVudDtcbiAgfVxuXG4gIHNldFByZXYocG9zLCBpbmRlbnQpIHtcbiAgICB3aGlsZSAodGhpcy5wcmV2Lmxlbmd0aCA8IGluZGVudCkgdGhpcy5wcmV2LnB1c2goLTEpO1xuICAgIHRoaXMucHJldltpbmRlbnRdID0gcG9zO1xuICB9XG5cbiAgc3RhdGljIGZvcihpbnB1dCkge1xuICAgIGxldCBmb3VuZCA9IGNhY2hlcy5nZXQoaW5wdXQpO1xuICAgIGlmICghZm91bmQpIGNhY2hlcy5zZXQoaW5wdXQsIGZvdW5kID0gbmV3IENhY2hlKTtcbiAgICByZXR1cm4gZm91bmRcbiAgfVxufVxuXG5jb25zdCBtYXhJbmRlbnQgPSA1MDtcblxuZnVuY3Rpb24gZ2V0SW5kZW50KGlucHV0LCBwb3MpIHtcbiAgbGV0IGNhY2hlID0gQ2FjaGUuZm9yKGlucHV0KSwgZm91bmQgPSBjYWNoZS5nZXQocG9zKTtcbiAgaWYgKGZvdW5kID4gLTEpIHJldHVybiBmb3VuZFxuXG4gIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiB2ZXJ5IG9mdGVuIChvciBldmVuIGF0IGFsbCkgaW4gbm9ybWFsXG4gIC8vIHBhcnNpbmcsIHNpbmNlIHRoZSBpbmRlbnRhdGlvbnMgYXJlIHN0b3JlZCBieSB0aGUgbmV3bGluZVxuICAvLyB0b2tlbml6ZXIgYWhlYWQgb2YgdGltZS4gQnV0IGl0J3Mga2luZCBvZiB0cmlja3kgdG8gcHJvdmUgd2hldGhlclxuICAvLyB0aGF0IGFsd2F5cyBoYXBwZW5zIGluIGluY3JlbWVudGFsIHBhcnNpbmcgc2NlbmFyaW9zLCBzbyBoZXJlJ3MgYVxuICAvLyBmYWxsYmFjayBhbnl3YXkuXG4gIGxldCBiZWZvcmUgPSBpbnB1dC5yZWFkKE1hdGgubWF4KDAsIHBvcyAtIG1heEluZGVudCksIHBvcyk7XG4gIGxldCBjb3VudCA9IDAsIHN0YXJ0ID0gYmVmb3JlLmxlbmd0aDtcbiAgZm9yICg7IHN0YXJ0ID4gMDsgc3RhcnQtLSkge1xuICAgIGxldCBuZXh0ID0gYmVmb3JlLmNoYXJDb2RlQXQoc3RhcnQgLSAxKTtcbiAgICBpZiAobmV4dCA9PSBuZXdsaW5lJDEgfHwgbmV4dCA9PSBjYXJyaWFnZVJldHVybikgYnJlYWtcbiAgfVxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBiZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2ggPSBiZWZvcmUuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY2ggPT0gc3BhY2UpIGNvdW50Kys7XG4gICAgZWxzZSBpZiAoY2ggPT0gdGFiKSBjb3VudCArPSA4IC0gKGNvdW50ICUgOCk7XG4gICAgZWxzZSBicmVha1xuICB9XG4gIGNhY2hlLnNldFByZXYocG9zLCBjb3VudCk7XG4gIHJldHVybiBjb3VudFxufVxuXG5jb25zdCBuZXdsaW5lcyA9IG5ldyBsZXplci5FeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHRva2VuLCBzdGFjaykgPT4ge1xuICBsZXQgbmV4dCA9IGlucHV0LmdldCh0b2tlbi5zdGFydCk7XG4gIGlmIChuZXh0IDwgMCkge1xuICAgIHRva2VuLmFjY2VwdChlb2YsIHRva2VuLnN0YXJ0KTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobmV4dCAhPSBuZXdsaW5lJDEgJiYgbmV4dCAhPSBjYXJyaWFnZVJldHVybikgcmV0dXJuXG4gIGlmIChzdGFjay5zdGFydE9mKGJyYWNrZXRlZCkgIT0gbnVsbCkge1xuICAgIHRva2VuLmFjY2VwdChuZXdsaW5lQnJhY2tldGVkLCB0b2tlbi5zdGFydCArIDEpO1xuICAgIHJldHVyblxuICB9XG4gIGxldCBzY2FuID0gdG9rZW4uc3RhcnQgKyAxLCBpbmRlbnQgPSAwO1xuICBmb3IgKDsgc2NhbiA8IGlucHV0Lmxlbmd0aDsgc2NhbisrKSB7XG4gICAgbGV0IGNoID0gaW5wdXQuZ2V0KHNjYW4pO1xuICAgIGlmIChjaCA9PSBzcGFjZSkgaW5kZW50Kys7XG4gICAgZWxzZSBpZiAoY2ggPT0gdGFiKSBpbmRlbnQgKz0gOCAtIChpbmRlbnQgJSA4KTtcbiAgICBlbHNlIGlmIChjaCA9PSBuZXdsaW5lJDEgfHwgaW5kZW50ID09IGNhcnJpYWdlUmV0dXJuIHx8IGNoID09IGhhc2gpIHtcbiAgICAgIHRva2VuLmFjY2VwdChuZXdsaW5lRW1wdHksIHRva2VuLnN0YXJ0ICsgMSk7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgdG9rZW4uYWNjZXB0KG5ld2xpbmUsIHRva2VuLnN0YXJ0ICsgMSk7XG4gIENhY2hlLmZvcihpbnB1dCkuc2V0KHNjYW4sIGluZGVudCk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZSwgZmFsbGJhY2s6IHRydWV9KTtcblxuY29uc3QgYm9keUNvbnRpbnVlID0gbmV3IGxlemVyLkV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgdG9rZW4sIHN0YWNrKSA9PiB7XG4gIGxldCBwYXJlbnQgPSBzdGFjay5zdGFydE9mKHBhcmVudFN0YXRlbWVudCk7XG4gIGxldCBwYXJlbnRJbmRlbnQgPSBwYXJlbnQgPT0gbnVsbCA/IDAgOiBnZXRJbmRlbnQoaW5wdXQsIHBhcmVudCk7XG4gIGxldCBpbmRlbnRIZXJlID0gZ2V0SW5kZW50KGlucHV0LCB0b2tlbi5zdGFydCk7XG4gIHRva2VuLmFjY2VwdChpbmRlbnRIZXJlIDw9IHBhcmVudEluZGVudCA/IGVuZEJvZHkgOiBjb250aW51ZUJvZHksIHRva2VuLnN0YXJ0KTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlLCBmYWxsYmFjazogdHJ1ZX0pO1xuXG5jb25zdCBsZWdhY3lQcmludCA9IG5ldyBsZXplci5FeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHRva2VuKSA9PiB7XG4gIGxldCBwb3MgPSB0b2tlbi5zdGFydDtcbiAgZm9yIChsZXQgcHJpbnQgPSBcInByaW50XCIsIGkgPSAwOyBpIDwgcHJpbnQubGVuZ3RoOyBpKyssIHBvcysrKVxuICAgIGlmIChpbnB1dC5nZXQocG9zKSAhPSBwcmludC5jaGFyQ29kZUF0KGkpKSByZXR1cm5cbiAgbGV0IGVuZCA9IHBvcztcbiAgaWYgKC9cXHcvLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShpbnB1dC5nZXQocG9zKSkpKSByZXR1cm5cbiAgZm9yICg7OyBwb3MrKykge1xuICAgIGxldCBuZXh0ID0gaW5wdXQuZ2V0KHBvcyk7XG4gICAgaWYgKG5leHQgPT0gc3BhY2UgfHwgbmV4dCA9PSB0YWIpIGNvbnRpbnVlXG4gICAgaWYgKG5leHQgIT0gcGFyZW5PcGVuICYmIG5leHQgIT0gZG90ICYmIG5leHQgIT0gbmV3bGluZSQxICYmIG5leHQgIT0gY2FycmlhZ2VSZXR1cm4gJiYgbmV4dCAhPSBoYXNoKVxuICAgICAgdG9rZW4uYWNjZXB0KHByaW50S2V5d29yZCwgZW5kKTtcbiAgICByZXR1cm5cbiAgfVxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgc3BlY19pZGVudGlmaWVyID0ge19fcHJvdG9fXzpudWxsLGF3YWl0OjQwLCBvcjo0OCwgYW5kOjUwLCBpbjo1NCwgbm90OjU2LCBpczo1OCwgaWY6NjQsIGVsc2U6NjYsIGxhbWJkYTo3MCwgc2VsZjo3NCwgeWllbGQ6OTAsIGZyb206OTIsIGFzeW5jOjEwMCwgZm9yOjEwMiwgTm9uZToxNTQsIFRydWU6MTU2LCBGYWxzZToxNTYsIGRlbDoxNzAsIHBhc3M6MTc0LCBicmVhazoxNzgsIGNvbnRpbnVlOjE4MiwgcmV0dXJuOjE4NiwgcmFpc2U6MTk0LCBpbXBvcnQ6MTk4LCBhczoyMDAsIGdsb2JhbDoyMDQsIG5vbmxvY2FsOjIwNiwgYXNzZXJ0OjIxMCwgZWxpZjoyMjAsIHdoaWxlOjIyNCwgdHJ5OjIzMCwgZXhjZXB0OjIzMiwgZmluYWxseToyMzQsIHdpdGg6MjM4LCBkZWY6MjQyLCBjbGFzczoyNTJ9O1xuY29uc3QgcGFyc2VyID0gbGV6ZXIuUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTMsXG4gIHN0YXRlczogXCIhO1tPYFEhTFRPT08lZlEhTFVPJyNHY09PUSFMUScjQ20nI0NtT09RIUxRJyNDbicjQ25PJ1VRIUxTTycjQ2xPKHpRIUxVTycjR2JPT1EhTFEnI0djJyNHY09PUSFMUScjRFMnI0RTT09RIUxRJyNHYicjR2JPKWhRIUxTTycjQ3FPKXhRIUxTTycjRGNPKllRIUxTTycjRGdPT1EhTFEnI0R0JyNEdE8qbU9XTycjRHRPKnVPYE8nI0R0Typ9T3BPJyNEdU8rWU8hYk8nI0R1TytlTyN0TycjRHVPK3BPJmpPJyNEdU8tclEhTFVPJyNHU09PUSFMUScjR1MnI0dTTydVUSFMU08nI0dSTy9VUSFMVU8nI0dST09RIUxRJyNFXicjRV5PL21RIUxTTycjRV9PT1EhTFEnI0dRJyNHUU8vd1EhTFNPJyNHUE9PUSZGVicjR1AnI0dQTzBTUSFMU08nI0ZRT09RIUxRJyNGdCcjRnRPMFhRIUxTTycjRlBPT1EmRlYnI0hdJyNIXU9PUSZGVicjR08nI0dPT09RIUxSJyNGUycjRlNRYFEhTFRPT08nVVEhTFNPJyNDb08wZ1EhTFNPJyNDek8wblEhTFNPJyNET08xUFEhTFNPJyNHZ08xYVEhTFVPJyNFUk8nVVEhTFNPJyNFU09PUSFMUScjRVUnI0VVT09RIUxRJyNFVycjRVdPT1EhTFEnI0VZJyNFWU8xdVEhTFNPJyNFW08yU1EhTFNPJyNFYE8wU1EhTFNPJyNFYk8yZ1EhTFVPJyNFYk8wU1EhTFNPJyNFZU8vbVEhTFNPJyNFaE8vbVEhTFNPJyNFbE8vbVEhTFNPJyNFb08yclEhTFNPJyNFcU8yeVEhTFNPJyNFdk8zVVEhTFNPJyNFck8vbVEhTFNPJyNFdk8wU1EhTFNPJyNFeE8wU1EhTFNPJyNFfU9PUSFMUScjQ2MnI0NjT09RIUxRJyNDZCcjQ2RPT1EhTFEnI0NlJyNDZU9PUSFMUScjQ2YnI0NmT09RIUxRJyNDZycjQ2dPT1EhTFEnI0NoJyNDaE9PUSFMUScjQ2onI0NqTydVUSFMU08sNTh8TydVUSFMU08sNTh8TydVUSFMU08sNTh8TydVUSFMU08sNTh8TydVUSFMU08sNTh8TydVUSFMU08sNTh8TydVUSFMU08sNTh8TzNaUSFMU08nI0RuT09RIUxRLDU6WCw1OlhPM25RIUxTTyw1OltPM3tRIylXTyw1OltPNFFRIUxVTyw1OVdPMGdRIUxTTyw1OV9PMGdRIUxTTyw1OV9PMGdRIUxTTyw1OV9PNnBRIUxTTyw1OV9PNnVRIUxTTyw1OV9PNnxRIUxTTyw1OWdPN1RRIUxTTycjR2JPOFpRIUxTTycjR2FPT1EhTFEnI0dhJyNHYU9PUSFMUScjRFknI0RZTzhyUSFMU08sNTldTydVUSFMU08sNTldTzlRUSFMU08sNTldTzlWUSFMU08sNTpRTydVUSFMU08sNTpRT09RIUxRLDU5fSw1OX1POWVRIUxTTyw1OX1POWpRIUxTTyw1OldPJ1VRIUxTTyw1OldPJ1VRIUxTTyw1OlVPT1EhTFEsNTpSLDU6Uk85e1EhTFNPLDU6Uk86UVEhTFNPLDU6Vk9PT08nI0ZdJyNGXU86Vk9XTyw1OmBPT1EhTFEsNTpgLDU6YE9PT08nI0ZeJyNGXk86X09gTyw1OmBPOmdRIUxTTycjRHZPT09PJyNGXycjRl9POndPcE8sNTphT09RIUxRLDU6YSw1OmFPT09PJyNGYicjRmJPO1NPIWJPLDU6YU9PT08nI0ZjJyNGY087X08jdE8sNTphT09PTycjRmQnI0ZkTztqTyZqTyw1OmFPT1EhTFEnI0ZlJyNGZU87dVEhTFVPLDU6ZU8+Z1EhTFVPLDU8bU8/UVEjNF5PJyNGZk8/dFEhTFVPLDU8bU9PUSFMUSw1OnksNTp5T0BdUSFMVE8nI0ZtT0FsUSFMU08sNTtVT09RJkZWLDU8ayw1PGtPQXdRIUxVTycjSFlPQmBRIUxTTyw1O2xPT1EhTFEtRTlyLUU5ck9PUSZGViw1O2ssNTtrTzNQUSFMU08nI0V4T09RIUxSLUU5US1FOVFPQmhRIUxVTyw1OVpPRG9RIUxVTyw1OWZPRVlRIUxTTycjR2RPRWVRIUxTTycjR2RPMFNRIUxTTycjR2RPRXBRIUxTTycjRFFPRXhRIUxTTyw1OWpPRX1RIUxTTycjR2hPJ1VRIUxTTycjR2hPL21RIUxTTyw1PVJPT1EhTFEsNT1SLDU9Uk8vbVEhTFNPJyNEfU9PUSFMUScjRU8nI0VPT0ZsUSFMU08nI0ZnT0Z8USFMU08sNTh6T0dbUSFMU08sNTh6TylrUSFMU08sNTprT0dhUSFMVU8nI0dqT09RIUxRLDU6biw1Om5PT1EhTFEsNTp2LDU6dk9HdFEhTFNPLDU6ek9IVlEhTFNPLDU6fE9PUSFMUScjRmonI0ZqT0hlUSFMVU8sNTp8T0hzUSFMU08sNTp8T0h4USFMU08nI0hbT09RIUxRLDU7UCw1O1BPSVdRIUxTTycjSFhPT1EhTFEsNTtTLDU7U08zVVEhTFNPLDU7V08zVVEhTFNPLDU7Wk9JaVEhTFVPJyNIXk8nVVEhTFNPJyNIXk9Jc1EhTFNPLDU7XU8yclEhTFNPLDU7XU8vbVEhTFNPLDU7Yk8wU1EhTFNPLDU7ZE9JeFEhTFRPJyNFbU9LUlEmRlhPLDU7Xk9OalEhTFNPJyNIX08zVVEhTFNPLDU7Yk9OdVEhTFNPLDU7ZE9OelEhTFNPLDU7aU8hI29RIUxVTzFHLmhPISN2USFMVU8xRy5oTyEmZ1EhTFVPMUcuaE8hJnFRIUxVTzFHLmhPISlbUSFMVU8xRy5oTyEpb1EhTFVPMUcuaE8hKlNRIUxVTzFHLmhPISxyUSFMU08nI0dwTyEtUVEhTFVPJyNHU08vbVEhTFNPJyNHcE8hLVtRIUxTTycjR29PT1EhTFEsNTpZLDU6WU8hLWRRIUxTTyw1OllPIS1pUSFMU08nI0dxTyEtdFEhTFNPJyNHcU8hLlhRIUxTTzFHL3ZPT1EhTFEnI0RyJyNEck9PUSFMUTFHL3YxRy92T09RIUxRMUcueTFHLnlPIS9YUSFMVU8xRy55TyEvYFEhTFVPMUcueU8wZ1EhTFNPMUcueU8hL3tRIUxTTzFHL1JPT1EhTFEnI0RYJyNEWE8vbVEhTFNPLDU5ck9PUSFMUTFHLncxRy53TyEwU1EhTFNPMUcvZE8hMGRRIUxTTzFHL2RPITBsUSFMU08xRy9lTydVUSFMU08nI0dpTyEwcVEhTFNPJyNHaU8hMHZRIUxVTzFHLndPITFXUSFMU08sNTlmTyEyXlEhTFNPJyNGWE8hMnFRIUxTTyw1PVhPITJ5USFMU08xRy9sTyEzT1EhTFVPMUcvbE9PUSFMUTFHL2kxRy9pTyEzYFEhTFNPJyNGVU8hNFlRIUxTTyw1PVNPL21RIUxTTzFHL3BPITR3USFMU08xRy9yTyE0fFEhTFVPMUcvck8hNV5RIUxVTzFHL3BPT1EhTFExRy9tMUcvbU9PUSFMUTFHL3ExRy9xT09PTy1FOVotRTlaT09RIUxRMUcvejFHL3pPT09PLUU5Wy1FOVtPITVuUSFMU08nI0d8Ty9tUSFMU08nI0d8TyE1fFEhTFNPLDU6Yk9PT08tRTldLUU5XU9PUSFMUTFHL3sxRy97T09PTy1FOWAtRTlgT09PTy1FOWEtRTlhT09PTy1FOWItRTliT09RIUxRLUU5Yy1FOWNPITZYUSFMVU8xRzJYTydVUSFMU08sNTxRT09RIUxRLDU8USw1PFFPT1EhTFEtRTlkLUU5ZE9PUSFMUSw1PFgsNTxYT09RIUxRLUU5ay1FOWtPT1EmRlYxRzBwMUcwcE8wU1EhTFNPJyNGaU8hNnBRIUxVTyw1PXRPT1EhTFExRzFXMUcxV08hN1hRIUxTTzFHMVdPT1EhTFEnI0RUJyNEVE8vbVEhTFNPLDU9T09PUSFMUSw1PU8sNT1PTyE3XlEhTFNPJyNGVE8hN2xRIUxTTyw1OWxPITd0USFMU08xRy9VTyE4T1EhTFVPLDU9U09PUSFMUTFHMm0xRzJtT09RIUxRLDU6aSw1OmlPIThvUSFMU08nI0dST09RIUxRLDU8Uiw1PFJPT1EhTFEtRTllLUU5ZU8hOVFRIUxTTzFHLmZPT1EhTFExRzBWMUcwVk8hOWBRIUxTTycjRldPITlzUSFMU08sNT1VTy9tUSFMU08xRzBmTy9tUSFMU08xRzBmTzBTUSFMU08xRzBoT09RIUxRLUU5aC1FOWhPITpVUSFMU08xRzBoTyE6YVEhTFNPMUcwaE8hOmZRIUxTTycjRmxPITp3USFMU08sNT12TyE7VlEhTFNPJyNGaE8hO3BRIUxTTyw1PXNPITxSUSZGWE8xRzByTyE/Z1EmRlhPMUcwdU8hQnhRIUxTTycjRnBPIUNWUSFMU08sNT14TyFDX1EhTFVPLDU9eE8vbVEhTFNPMUcwd08hQ2lRIUxTTzFHMHdPM1VRIUxTTzFHMHxPTnVRIUxTTzFHMU9PT1EmRlYsNTtYLDU7WE8hQ25RIUxUTyw1O1hPIUVhUSZGWE8xRzB4TyFIeFEhTFNPJyNGcU8zVVEhTFNPMUcweE8zVVEhTFNPMUcweE8hSVZRIUxTTycjRnJPIUlnUSFMU08sNT15TzBTUSFMU08sNT15T09RJkZWMUcwfDFHMHxPIUpRUSFMU08nI0V6TyFKWFEjKVdPMUcxT09PUSZGVjFHMVQxRzFUTzNVUSFMU08xRzFUT09RIUxRLDU9Wyw1PVtPT1EhTFEnI0RvJyNEb08vbVEhTFNPLDU9W08hSmFRIUxTTycjRlpPIUp3USFMU08sNT1aT09RIUxRMUcvdDFHL3RPIUtQUSFMU08nI0ZbTyFLZFEhTFNPLDU9XU8hS2xRIUxTTyw1PV1PIUxQUSFMU08sNT1dTyFMYVEhTFNPLDU9XU9PUSFMUTcrJWI3KyViT09RIUxRNyskZTcrJGVPITd0USFMU083KyRtTyFOU1EhTFNPMUcueU8hTlpRIUxTTzFHLnlPT1EhTFExRy9eMUcvXk9PUSFMUSw1O3EsNTtxTydVUSFMU08sNTtxT09RIUxRNyslTzcrJU9PIU5iUSFMU083KyVPT09RIUxRLUU5VC1FOVRPT1EhTFE3KyVQNyslUE8hTnJRIUxTTyw1PVRPJ1VRIUxTTyw1PVRPT1EhTFE3KyRjNyskY08hTndRIUxTTzcrJU9PIyBQUSFMU083KyVQT09RIUxRLDU7cyw1O3NPJ1VRIUxTTyw1O3NPT1EhTFEtRTlWLUU5Vk9PUSFMUTcrJVc3KyVXTyMgVVEhTFNPMUcyc08jIF5RIUxTTzcrJVdPT1EhTFEsNTtwLDU7cE8nVVEhTFNPLDU7cE9PUSFMUS1FOVMtRTlTTyMgY1EhTFNPNyslW09PUSFMUTcrJV43KyVeTyMgcVEhTFNPMUcybk8jIWBRIUxTTzcrJV5PIyFlUSFMU08nI0ZZTyMheFEhTFNPMUcydE8jI1FRIUxTTzcrJVtPIyNWUSFMU08nI0ZgTyMjcFEhTFNPLDU9aE8jI3BRIUxTTyw1PWhPIyRPT01oTycjRHhPIyRaT1FPJyNHfU9PT08xRy98MUcvfE8jJGBRIUxTTzFHL3xPIyRoUSFMVU8xRzFsT09RIUxRLDU8VCw1PFRPT1EhTFEtRTlnLUU5Z09PUSFMUTcrJnI3KyZyT09RIUxRMUcyajFHMmpPT1EhTFEsNTtvLDU7b09PUSFMUS1FOVItRTlST09RIUxRNyskcDcrJHBPIyVSUSFMU08nI0ZmTyMlb1EhTFNPLDU8bU8jJlFRIUxVTyw1O3JPT1EhTFEtRTlVLUU5VU9PUSFMUTcrJlE3KyZRTyMmZVEhTFNPNysmUU9PUSFMUTcrJlM3KyZTTyMmc1EhTFNPJyNIWk8wU1EhTFNPNysmU08jJ1hRIUxTTzcrJlNPT1EhTFEsNTxXLDU8V09PUSFMUS1FOWotRTlqT09RIUxRLDU8Uyw1PFNPT1EhTFEtRTlmLUU5Zk8jJ2RRJkZYTzcrJl5PIUh4USFMU08nI0ZvTzNVUSFMU083KyZeTzNVUSFMU083KyZhTyMqeFEhTFVPLDU8W08nVVEhTFNPLDU8W09PUSFMUS1FOW4tRTluTyMrU1EhTFNPMUczZE8zVVEhTFNPNysmY08vbVEhTFNPNysmY09PUSZGVjcrJmg3KyZoTyFKWFEjKVdPNysmak8jK1tRJkZXTzFHMHNPT1EmRlYtRTlvLUU5b08zVVEhTFNPNysmZE8zVVEhTFNPNysmZE9PUSZGViw1PF0sNTxdTyMrZ1EhTFNPLDU8XU9PUSZGVjcrJmQ3KyZkTyMrclEmRlhPNysmZE8jL1RRIUxTTyw1PF5PT1EhTFEtRTlwLUU5cE8jL2BRIUxTTzFHM2VPIy9oUSFMU08nI0hhTyMvdlEhTFNPJyNIYU8wU1EhTFNPJyNIYU9PUSFMUScjSGEnI0hhTyMwUlEhTFNPJyNIYE9PUSFMUSw1O2YsNTtmTyMwWlEhTFNPLDU7Zk8vbVEhTFNPJyNFfE9PUSZGVjcrJmo3KyZqTzNVUSFMU083KyZqT09RJkZWNysmbzcrJm9PT1EhTFExRzJ2MUcydk9PUSFMUSw1O3UsNTt1T09RIUxRLUU5WC1FOVhPIzBgUSFMU08sNTt2TyMwa1EhTFNPLDU7dk9PUSFMUS1FOVktRTlZTyMxT1EhTFNPMUcyd08jMVdRIUxTTzFHMndPIzFoUSFMU08xRzJ3TyMxT1EhTFNPMUcyd09PUSFMUTw8SFg8PEhYTyMxc1EhTFVPMUcxXU9PUSFMUTw8SGo8PEhqUCMxfVEhTFNPJyNGVk82fFEhTFNPMUcyb08jMltRIUxTTzFHMm9PIzJhUSFMU088PEhqT09RIUxRPDxIazw8SGtPIzJxUSFMVU8xRzFfT09RIUxRPDxIcjw8SHJPIzJ7USFMVU8xRzFbTyMzbFEhTFNPNysoYE8jM3RRIUxTTzw8SHZPT1EhTFE8PEh4PDxIeE8jM3lRIUxTTyw1O3RPJ1VRIUxTTyw1O3RPT1EhTFEtRTlXLUU5V09PUSFMUTw8SHY8PEh2T09RIUxRLDU7eiw1O3pPL21RIUxTTyw1O3pPT1EhTFEtRTleLUU5Xk8jNE9RIUxTTzFHM1NPT09PJyNGYScjRmFPIzReT01oTyw1OmRPT09PLDU9aSw1PWlPT09PNyslaDcrJWhPIzRpUSFMU08xRzJYTy9tUSFMU088PElsTyM0elEhTFNPJyNGa08jNWBRIUxTTyw1PXVPMFNRIUxTTyw1PXVPIzVxUSFMU088PEluT09RIUxRPDxJbjw8SW5PMFNRIUxTTzw8SW5PT1EmRlYtRTltLUU5bU8zVVEhTFNPPDxJeE9PUSZGViw1PFosNTxaTzNVUSFMU08sNTxaT09RJkZWPDxJeDw8SXhPT1EmRlY8PEl7PDxJe08jNXZRIUxVTzFHMXZPIzZRUSZGWE88PEl9TzNVUSFMU088PEl9T09RJkZWPDxKVTw8SlVPM1VRIUxTTzw8SlVPIUNuUSFMVE8nI0ZuTyM5Y1EmRldPNysmX09PUSZGVjcrJl83KyZfT09RJkZWPDxKTzw8Sk9PIzluUSZGWE88PEpPT09RJkZWMUcxdzFHMXdPMFNRIUxTTzFHMXdPM1VRIUxTTzw8Sk9PMFNRIUxTTzFHMXhPIz1QUSFMU083KylQT09RIUxRJyNFeycjRXtPL21RIUxTTyw1PXtPIz1YUSFMU08sNT17T09RIUxRLDU9eyw1PXtPIz1kUSFMU08nI0ZzTyM9blEhTFNPLDU9ek9PUSFMUTFHMVExRzFRT09RIUxRLDU7aCw1O2hPIz12USFMU08xRzFiTyM+WlEhTFNPMUcxYk8jPmtRIUxTTzFHMWJPIz52USFMU083KyhjTyM+dlEhTFNPNysoY08jP09RIUxTTzcrKGNPIz9gUSFMU083KyhaTzZ8USFMU083KyhaT09RIUxRQU4+VUFOPlVPT1EhTFFBTj5iQU4+Yk8vbVEhTFNPMUcxYE8jP3lRIUxVTzFHMWBPT1EhTFExRzFmMUcxZk9PT08tRTlfLUU5X09PUSFMUUFOP1dBTj9XTyNAVFEhTFNPLDU8Vk9PUSFMUS1FOWktRTlpTyNAaVEhTFNPMUczYU9PUSFMUUFOP1lBTj9ZTyNAelEhTFNPQU4/WU9PUSZGVkFOP2RBTj9kT09RJkZWMUcxdTFHMXVPM1VRIUxTT0FOP2lPI0FQUSZGWE9BTj9pT09RJkZWQU4/cEFOP3BPT1EmRlUsNTxZLDU8WU9PUSZGVS1FOWwtRTlsT09RJkZWPDxJeTw8SXlPM1VRIUxTT0FOP2pPM1VRIUxTTzcrJ2NPT1EmRlZBTj9qQU4/ak9PUSFMUTcrJ2Q3KydkT09RIUxRMUczZzFHM2dPL21RIUxTTzFHM2dPT1EhTFEsNTxfLDU8X09PUSFMUS1FOXEtRTlxTyNEYlEhTFNPNysmfE8jRHJRIUxTTzcrJnxPT1EhTFE3KyZ8NysmfE8jRH1RIUxTTzw8S31PI0R9USFMU088PEt9TyNFVlEhTFNPJyNHa09PUSFMUTw8S3U8PEt1TyNFYVEhTFNPPDxLdU9PUSFMUTcrJno3KyZ6TzBTUSFMU08xRzFxTyNFelEhTFNPNysoe09PUSFMUUcyNHRHMjR0T09RJkZWRzI1VEcyNVRPM1VRIUxTT0cyNVRPT1EmRlZHMjVVRzI1VU9PUSZGVjw8Sn08PEp9T09RIUxRNyspUjcrKVJPT1EhTFE8PEpoPDxKaE8jRl1RIUxTTzw8SmhPI0ZtUSFMU09BTkFpTyNGdVEhTFNPJyNHbE9PUSFMUScjR2wnI0dsTzBuUSFMU08nI0RiTyNHYFEhTFNPLDU9Vk9PUSFMUUFOQWFBTkFhT09RIUxRNysnXTcrJ11PT1EmRlZMRCpvTEQqb09PUSFMUUFOQFNBTkBTTyNHd1EhTFNPLDU5fE9PUSFMUTFHMnExRzJxTyNFVlEhTFNPMUcvaE9PUSFMUTcrJVM3KyVTTzZ8USFMU08nI0N6TzZ8USFMU08sNTlfTzZ8USFMU08sNTlfTzZ8USFMU08sNTlfTyNHfFEhTFVPLDU8bU82fFEhTFNPMUcueU8vbVEhTFNPMUcvVU8vbVEhTFNPNyskbU8nVVEhTFNPJyNHUk8jSGFRIUxTTyw1OV9PI0hmUSFMU08sNTlfTyNIbVEhTFNPLDU5ak8jSHJRIUxTTzFHL1JPMG5RIUxTTycjRE9PNnxRIUxTTyw1OWdcIixcbiAgc3RhdGVEYXRhOiBcIiNJVH5PJHFPUyRsT1Mka09TUU9Tfk9QaE9UZU9kc09mWE9sdE9wIVNPc3VPdWRPfXZPIU8hUE8hUyFWTyFUIVVPIVdZTyFbWk8hZ2RPIW5kTyFvZE8hcGRPIXd4TyF5eU8he3pPIX17TyNQfE8jVH1PI1YhT08jWSFRTyNaIVFPI10hUk8jZCFUTyNnIVdPI2shWE8jbSFZTyNyIVpPI3VsTyRqcU8kfFFPJH1RTyVSUk8lU1ZPJWdbTyVoXU8la15PJW5fTyV0YE8ld2FPJXliT35PVCFhT10hYU9fIWJPZiFqTyFXIWxPIWUhbU8kdyFbTyR4IV1PJHkhXk8keiFfTyR7IV9PJHwhYE8kfSFgTyVPIWFPJVAhYU8lUSFhT35PaCVWWGklVlhqJVZYayVWWGwlVlhtJVZYcCVWWHglVlh5JVZYIXQlVlgjXyVWWCRqJVZYJG0lVlglWCVWWCFQJVZYIVMlVlghVCVWWCVZJVZYIVglVlghXSVWWCFPJVZYI1clVlhxJVZYIWslVlh+UCRiT2RzT2ZYT3VkTyFXWU8hW1pPIWdkTyFuZE8hb2RPIXBkTyR8UU8kfVFPJVJSTyVTVk8lZ1tPJWhdTyVrXk8lbl9PJXRgTyV3YU8leWJPfk94JVVYeSVVWCNfJVVYJGolVVgkbSVVWCVYJVVYfk9oIXBPaSFxT2ohb09rIW9PbCFyT20hc09wIXRPIXQlVVh+UChmT1Qhek9sLHFPcy1PT312T35QJ1VPVCF9T2wscU9zLU9PIVgjT09+UCdVT1QjUk9fI1NPbCxxT3MtT08hXSNUT35QJ1VPJWkjV08laiNZT35PJWwjWk8lbSNZT35PIVsjXU8lbyNeTyVzI2BPfk8hWyNdTyV1I2FPJXYjYE9+TyFbI11PJWojYE8leCNjT35PIVsjXU8lbSNgTyV6I2VPfk9UJHZYXSR2WF8kdlhmJHZYaCR2WGkkdlhqJHZYayR2WGwkdlhtJHZYcCR2WHgkdlghVyR2WCFlJHZYJHckdlgkeCR2WCR5JHZYJHokdlgkeyR2WCR8JHZYJH0kdlglTyR2WCVQJHZYJVEkdlghUCR2WCFTJHZYIVQkdlh+TyVnW08laF1PJWteTyVuX08ldGBPJXdhTyV5Yk95JHZYIXQkdlgjXyR2WCRqJHZYJG0kdlglWCR2WCVZJHZYIVgkdlghXSR2WCFPJHZYI1ckdlhxJHZYIWskdlh+UCt7T3gjak95JHVYIXQkdVgjXyR1WCRqJHVYJG0kdVglWCR1WH5PbCxxT3MtT09+UCdVTyNfI21PJGojb08kbSNvT35PJVNWT35PIVMjdE8jbSFZTyNyIVpPI3VsT35PbHRPflAnVU9UI3lPXyN6T3UjeE8lU1ZPeXRQfk9UJE9PbCxxT3MtT08hTyRQT35QJ1VPeSRSTyF0JFdPJVgkU08jXyF1WCRqIXVYJG0hdVh+T1QkT09sLHFPcy1PT35QJ1VPbCxxT3MtT08jXyNTWCRqI1NYJG0jU1h+UCdVTyFlJF5PIW4kXk8lU1ZPfk9UJGhPflAnVU8hVCRqTyNrJGtPI20kbE9+T3kkbU9+T1QkfE9fJHxPbCxxT3MtT08hUCVPT35QJ1VPbCxxT3MtT095JVJPflAnVU8lZiVUT35PXyFiT2Yhak8hVyFsTyFlIW1PVGBhXWBhaGBhaWBhamBha2BhbGBhbWBhcGBheGBheWBhIXRgYSNfYGEkamBhJG1gYSR3YGEkeGBhJHlgYSR6YGEke2BhJHxgYSR9YGElT2BhJVBgYSVRYGElWGBhIVBgYSFTYGEhVGBhJVlgYSFYYGEhXWBhIU9gYSNXYGFxYGEha2Bhfk9rJVlPfk9sJVlPflAnVU9sLHFPflAnVU9oLHNPaSx0T2osck9rLHJPbCx6T20se09wLVBPIVAlVVghUyVVWCFUJVVYJVklVVghWCVVWCFdJVVYIU8lVVgjVyVVWCFrJVVYflAoZk8lWSVbT3glVFghUCVUWCFTJVRYIVQlVFghWCVUWHklVFh+T3glX08hUCVeTyFTJWNPIVQlYk9+TyFQJV5Pfk94JWZPIVMlY08hVCViTyFYJWFYfk8hWCVqT35PeCVrT3klbU8hUyVjTyFUJWJPIV0lW1h+TyFdJXFPfk8hXSVyT35PJWkjV08laiV0T35PJWwjWk8lbSV0T35PVCV3T2wscU9zLU9PfXZPflAnVU8hWyNdTyVvI15PJXMlek9+TyFbI11PJXUjYU8ldiV6T35PIVsjXU8laiV6TyV4I2NPfk8hWyNdTyVtJXpPJXojZU9+T1QhbWFdIW1hXyFtYWYhbWFoIW1haSFtYWohbWFrIW1hbCFtYW0hbWFwIW1heCFtYXkhbWEhVyFtYSFlIW1hIXQhbWEjXyFtYSRqIW1hJG0hbWEkdyFtYSR4IW1hJHkhbWEkeiFtYSR7IW1hJHwhbWEkfSFtYSVPIW1hJVAhbWElUSFtYSVYIW1hIVAhbWEhUyFtYSFUIW1hJVkhbWEhWCFtYSFdIW1hIU8hbWEjVyFtYXEhbWEhayFtYX5QI3lPeCNqT3kkdWEhdCR1YSNfJHVhJGokdWEkbSR1YSVYJHVhflAkYk9UJlFPbHRPc3VPeCRZWHkkWVghdCRZWCNfJFlYJGokWVgkbSRZWCVYJFlYflAnVU94I2pPeSR1YSF0JHVhI18kdWEkaiR1YSRtJHVhJVgkdWF+T1BoT1RlT2x0T3N1T312TyFPIVBPIXd4TyF5eU8he3pPIX17TyNQfE8jVH1PI1YhT08jWSFRTyNaIVFPI10hUk8jXyRhWCRqJGFYJG0kYVh+UCdVTyNfI21PJGomVk8kbSZWT35PIWUmV09mJXxYJGolfFgjVyV8WCNfJXxYJG0lfFgjViV8WH5PZiFqTyRqJllPfk9oY2FpY2FqY2FrY2FsY2FtY2FwY2F4Y2F5Y2EhdGNhI19jYSRqY2EkbWNhJVhjYSFQY2EhU2NhIVRjYSVZY2EhWGNhIV1jYSFPY2EjV2NhcWNhIWtjYX5QJGJPcG5heG5heW5hI19uYSRqbmEkbW5hJVhuYX5PaCFwT2khcU9qIW9PayFvT2whck9tIXNPIXRuYX5QRFdPJVgmW094JVdYeSVXWH5PJVNWT3glV1h5JVdYfk94Jl9PeXRYfk95JmFPfk94JWtPI18lW1gkaiVbWCRtJVtYIVAlW1h5JVtYIV0lW1ghayVbWCVYJVtYfk9ULHlPbCxxT3MtT099dk9+UCdVTyVYJFNPI19TYSRqU2EkbVNhfk8lWCRTT35PeCZqTyNfJV5YJGolXlgkbSVeWGslXlh+UCRiT3gmbU8hTyZsTyNfI1NhJGojU2EkbSNTYX5PI1cmbk8jXyNVYSRqI1VhJG0jVWF+TyFlJF5PIW4kXk8jViZwTyVTVk9+TyNWJnBPfk94JnJPI18mT1gkaiZPWCRtJk9Yfk94JnRPI18le1gkaiV7WCRtJXtYeSV7WH5PeCZ4T2smUVh+UCRiT2sme09+T1BoT1RlT2x0T3N1T312TyFPIVBPIXd4TyF5eU8he3pPIX17TyNQfE8jVH1PI1YhT08jWSFRTyNaIVFPI10hUk8kaidRT35QJ1VPcSdVTyNoJ1NPI2knVE9QI2ZhVCNmYWQjZmFmI2ZhbCNmYXAjZmFzI2ZhdSNmYX0jZmEhTyNmYSFTI2ZhIVQjZmEhVyNmYSFbI2ZhIWcjZmEhbiNmYSFvI2ZhIXAjZmEhdyNmYSF5I2ZhIXsjZmEhfSNmYSNQI2ZhI1QjZmEjViNmYSNZI2ZhI1ojZmEjXSNmYSNkI2ZhI2cjZmEjayNmYSNtI2ZhI3IjZmEjdSNmYSRpI2ZhJGojZmEkfCNmYSR9I2ZhJVIjZmElUyNmYSVnI2ZhJWgjZmElayNmYSVuI2ZhJXQjZmEldyNmYSV5I2ZhJG0jZmEkbiNmYSRvI2Zhfk94J1ZPI1cnWE95JlJYfk9mJ1pPfk9mIWpPeSRtT35PVCFhT10hYU9fIWJPZiFqTyFXIWxPIWUhbU8keSFeTyR6IV9PJHshX08kfCFgTyR9IWBPJU8hYU8lUCFhTyVRIWFPaFVpaVVpalVpa1VpbFVpbVVpcFVpeFVpeVVpIXRVaSNfVWkkalVpJG1VaSR3VWklWFVpIVBVaSFTVWkhVFVpJVlVaSFYVWkhXVVpIU9VaSNXVWlxVWkha1Vpfk8keCFdT35QISBTTyR4VWl+UCEgU09UIWFPXSFhT18hYk9mIWpPIVchbE8hZSFtTyR8IWBPJH0hYE8lTyFhTyVQIWFPJVEhYU9oVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSR4VWkkeVVpJVhVaSFQVWkhU1VpIVRVaSVZVWkhWFVpIV1VaSFPVWkjV1VpcVVpIWtVaX5PJHohX08keyFfT35QISN9TyR6VWkke1VpflAhI31PXyFiT2Yhak8hVyFsTyFlIW1PaFVpaVVpalVpa1VpbFVpbVVpcFVpeFVpeVVpIXRVaSNfVWkkalVpJG1VaSR3VWkkeFVpJHlVaSR6VWkke1VpJHxVaSR9VWklWFVpIVBVaSFTVWkhVFVpJVlVaSFYVWkhXVVpIU9VaSNXVWlxVWkha1Vpfk9UIWFPXSFhTyVPIWFPJVAhYU8lUSFhT35QISZ7T1RVaV1VaSVPVWklUFVpJVFVaX5QISZ7T2Yhak8hVyFsTyFlIW1PVFVpXVVpX1VpaFVpaVVpalVpa1VpbFVpbVVpcFVpeFVpeVVpIXRVaSNfVWkkalVpJG1VaSR3VWkkeFVpJHlVaSR6VWkke1VpJHxVaSR9VWklT1VpJVBVaSVRVWklWFVpIVBVaSFTVWkhVFVpJVlVaSFYVWkhXVVpIU9VaSNXVWlxVWkha1Vpfk8hUyVjTyFUJWJPeCVkWCFQJWRYfk8lWCdgTyVZJ2BPflAre094J2JPIVAlY1h+TyFQJ2RPfk94J2VPeSdnTyFYJWVYfk9sLHFPcy1PT3gnZU95J2hPIVglZVh+UCdVTyFYJ2pPfk9qIW9PayFvT2whck9tIXNPaGdpcGdpeGdpeWdpIXRnaSNfZ2kkamdpJG1naSVYZ2l+T2khcU9+UCEuXk9pZ2l+UCEuXk9oLHNPaSx0T2osck9rLHJPbCx6T20se09+T3EnbE9+UCEvZ09UJ3FPbCxxT3MtT08hUCdyT35QJ1VPeCdzTyFQJ3JPfk8hUCd1T35PIVQnd09+T3gnc08hUCd4TyFTJWNPIVQlYk9+UCRiT2gsc09pLHRPaixyT2ssck9sLHpPbSx7TyFQbmEhU25hIVRuYSVZbmEhWG5hIV1uYSFPbmEjV25hcW5hIWtuYX5QRFdPVCd8T2wscU9zLU9PeCN7WCFYI3tYflAnVU94JWZPIVglYWF+TyFYKE9Pfk94JWZPIVMlY08hVCViTyFYJWFhflAkYk9UKFNPbCxxT3MtT094I3hYIV0jeFgjXyN4WCRqI3hYJG0jeFghUCN4WHkjeFghayN4WCVYI3hYflAnVU94JWtPIV0lW2EjXyVbYSRqJVthJG0lW2EhUCVbYXklW2EhayVbYSVYJVthfk8hXShWT35PeCVrTyFTJWNPIVQlYk8hXSVbYX5QJGJPeChZTyFTJWNPIVQlYk8hXSViYX5QJGJPeChdT3klcFghXSVwWCFrJXBYfk95KGBPIV0oYk8hayhjT35PeCNqT3kkdWkhdCR1aSNfJHVpJGokdWkkbSR1aSVYJHVpfk8hZSZXT2YlfGEkaiV8YSNXJXxhI18lfGEkbSV8YSNWJXxhfk8kaihnT35PVCN5T18jek91I3hPJVNWT35PeCZfT3l0YX5PbHRPc3VPflAnVU94JWtPI18lW2EkaiVbYSRtJVthIVAlW2F5JVthIV0lW2EhayVbYSVYJVthflAkYk94KGxPI18kdVgkaiR1WCRtJHVYJVgkdVh+TyVYJFNPI19TaSRqU2kkbVNpfk94I3pYI18jelgkaiN6WCRtI3pYayN6WH5QJ1VPeCZqTyNfJV5hJGolXmEkbSVeYWslXmF+T1Qock9mKHRPJVNWT35PI1YodU9+TyVTVk94JGBYI18kYFgkaiRgWCRtJGBYfk94JnJPI18mT2EkaiZPYSRtJk9hfk9sLHFPcy1PT3gkW1gjXyRbWCRqJFtYJG0kW1h5JFtYflAnVU94JnRPI18le2EkaiV7YSRtJXtheSV7YX5PcSh8TyNiKHtPUCNgaVQjYGlkI2BpZiNgaWwjYGlwI2BpcyNgaXUjYGl9I2BpIU8jYGkhUyNgaSFUI2BpIVcjYGkhWyNgaSFnI2BpIW4jYGkhbyNgaSFwI2BpIXcjYGkheSNgaSF7I2BpIX0jYGkjUCNgaSNUI2BpI1YjYGkjWSNgaSNaI2BpI10jYGkjZCNgaSNnI2BpI2sjYGkjbSNgaSNyI2BpI3UjYGkkaSNgaSRqI2BpJHwjYGkkfSNgaSVSI2BpJVMjYGklZyNgaSVoI2BpJWsjYGklbiNgaSV0I2BpJXcjYGkleSNgaSRtI2BpJG4jYGkkbyNgaX5PcSh9T1AjY2lUI2NpZCNjaWYjY2lsI2NpcCNjaXMjY2l1I2NpfSNjaSFPI2NpIVMjY2khVCNjaSFXI2NpIVsjY2khZyNjaSFuI2NpIW8jY2khcCNjaSF3I2NpIXkjY2kheyNjaSF9I2NpI1AjY2kjVCNjaSNWI2NpI1kjY2kjWiNjaSNdI2NpI2QjY2kjZyNjaSNrI2NpI20jY2kjciNjaSN1I2NpJGkjY2kkaiNjaSR8I2NpJH0jY2klUiNjaSVTI2NpJWcjY2klaCNjaSVrI2NpJW4jY2kldCNjaSV3I2NpJXkjY2kkbSNjaSRuI2NpJG8jY2l+T1QpUE9rJGRYeCRkWH5QJ1VPeCZ4T2smUWF+T3gmeE9rJlFhflAkYk9rKVRPfk9QaE9UZU9sdE9wIVNPc3VPfXZPIU8hUE8hUyFWTyFUIVVPIXd4TyF5eU8he3pPIX17TyNQfE8jVH1PI1YhT08jWSFRTyNaIVFPI10hUk8jZCFUTyNnIVdPI2shWE8jbSFZTyNyIVpPI3VsT35QJ1VPcSlaTyNoJ1NPI2kpWU9QI2ZpVCNmaWQjZmlmI2ZpbCNmaXAjZmlzI2ZpdSNmaX0jZmkhTyNmaSFTI2ZpIVQjZmkhVyNmaSFbI2ZpIWcjZmkhbiNmaSFvI2ZpIXAjZmkhdyNmaSF5I2ZpIXsjZmkhfSNmaSNQI2ZpI1QjZmkjViNmaSNZI2ZpI1ojZmkjXSNmaSNkI2ZpI2cjZmkjayNmaSNtI2ZpI3IjZmkjdSNmaSRpI2ZpJGojZmkkfCNmaSR9I2ZpJVIjZmklUyNmaSVnI2ZpJWgjZmklayNmaSVuI2ZpJXQjZmkldyNmaSV5I2ZpJG0jZmkkbiNmaSRvI2Zpfk9sLHFPcy1PT3kkbU9+UCdVT2wscU9zLU9PeCRmWHkkZlh+UCdVT3gnVk95JlJhfk9UKWRPXyllT3UpY08lTylmTyVTVk9+TyFQKWhPflAhSW9PeSRtTyZVKWpPfk9UJHxPXyR8T2wscU9zLU9PeCN9WCFQI31YflAnVU94J2JPIVAlY2F+T2wscU9zLU9PeSlyT3gkT1ghWCRPWH5QJ1VPeCdlTyFYJWVhfk9sLHFPcy1PT3gnZU95KXVPIVglZWF+UCdVT2wscU9zLU9PeCdlTyFYJWVhflAnVU94J2VPeSl1TyFYJWVhfk9qLHJPayxyT2wsek9tLHtPaGdpcGdpeGdpIVBnaSFTZ2khVGdpJVlnaSFYZ2l5Z2khXWdpI19naSRqZ2kkbWdpIU9naSNXZ2lxZ2kha2dpJVhnaX5PaSx0T35QIUxsT2lnaX5QIUxsT1QncU9sLHFPcy1PTyFQKXpPflAnVU9rKXxPfk94Kk9PIVApek9+TyFQKlBPfk94JWZPIVglYWl+TyFYKlJPfk94KFlPIVMlY08hVCViTyFdJWJpfk94JWtPIV0lW2kjXyVbaSRqJVtpJG0lW2khUCVbaXklW2khayVbaSVYJVtpfk8hXSpWT35PXypYT2wscU9zLU9PeCN8WCFdI3xYflAnVU94KFlPIV0lYml+TyFdKlpPfk9UKl1PbCxxT3MtT094JFNYeSRTWCFdJFNYIWskU1h+UCdVT3goXU95JXBhIV0lcGEhayVwYX5PIVsjXU8lcipgTyFdIWxYfk8hXSpiT35PeShgTyFdKmNPfk94JFlpeSRZaSF0JFlpI18kWWkkaiRZaSRtJFlpJVgkWWl+UCRiT1QmUU9sLHFPcy1PT3gkWVgjXyRZWCRqJFlYJG0kWVglWCRZWH5QJ1VPeChsTyNfJHVhJGokdWEkbSR1YSVYJHVhfk94I3phI18jemEkaiN6YSRtI3phayN6YX5QJGJPeCplTyNfI1NxJGojU3EkbSNTcX5PeCpmTyNXKmhPI18lfVgkaiV9WCRtJX1YIVAlfVh+T1Qqak9mKmtPJVNWT35PcSptTyNiKHtPUCNgcVQjYHFkI2BxZiNgcWwjYHFwI2BxcyNgcXUjYHF9I2BxIU8jYHEhUyNgcSFUI2BxIVcjYHEhWyNgcSFnI2BxIW4jYHEhbyNgcSFwI2BxIXcjYHEheSNgcSF7I2BxIX0jYHEjUCNgcSNUI2BxI1YjYHEjWSNgcSNaI2BxI10jYHEjZCNgcSNnI2BxI2sjYHEjbSNgcSNyI2BxI3UjYHEkaSNgcSRqI2BxJHwjYHEkfSNgcSVSI2BxJVMjYHElZyNgcSVoI2BxJWsjYHElbiNgcSV0I2BxJXcjYHEleSNgcSRtI2BxJG4jYHEkbyNgcX5PayRkYXgkZGF+UCRiT3gmeE9rJlFpfk8kbSp5TyRuKndPJG8qeU9+T3gqfU95JG1PI1cqfU9+TyNpK09PUCNmcVQjZnFkI2ZxZiNmcWwjZnFwI2ZxcyNmcXUjZnF9I2ZxIU8jZnEhUyNmcSFUI2ZxIVcjZnEhWyNmcSFnI2ZxIW4jZnEhbyNmcSFwI2ZxIXcjZnEheSNmcSF7I2ZxIX0jZnEjUCNmcSNUI2ZxI1YjZnEjWSNmcSNaI2ZxI10jZnEjZCNmcSNnI2ZxI2sjZnEjbSNmcSNyI2ZxI3UjZnEkaSNmcSRqI2ZxJHwjZnEkfSNmcSVSI2ZxJVMjZnElZyNmcSVoI2ZxJWsjZnElbiNmcSV0I2ZxJXcjZnEleSNmcSRtI2ZxJG4jZnEkbyNmcX5PI1crUE94JGZheSRmYX5PeCdWT3kmUml+T3kkUk8lWCtST3gmVFghUCZUWH5PJVNWT3gmVFghUCZUWH5PeCtWTyFQJlNYfk8hUCtYT35PeStaT3gkT2EhWCRPYX5PbCxxT3MtT095K1tPeCRPYSFYJE9hflAnVU94J2VPIVglZWl+T2wscU9zLU9PeCdlTyFYJWVpflAnVU94J2VPeStgTyFYJWVpfk94I3lpIVAjeWl+UCRiT1QncU9sLHFPcy1PT35QJ1VPaytiT35PVCdxT2wscU9zLU9PIVArY09+UCdVT3gje2khWCN7aX5QJGJPeCN4aSFdI3hpI18jeGkkaiN4aSRtI3hpIVAjeGl5I3hpIWsjeGklWCN4aX5QJGJPeChZTyFdJWJxfk8hXStkT35PeStlT35PeChdT3klcGkhXSVwaSFrJXBpfk8hWyNdTyVyKmBPIV0hbGF+T3gobE8jXyR1aSRqJHVpJG0kdWklWCR1aX5PJVNWT3gkX1gjXyRfWCRqJF9YJG0kX1ghUCRfWH5PeCpmTyNfJX1hJGolfWEkbSV9YSFQJX1hfk8hUCttT35PayRkaXgkZGl+UCRiT3ErcU9QI2V5VCNleWQjZXlmI2V5bCNleXAjZXlzI2V5dSNleX0jZXkhTyNleSFTI2V5IVQjZXkhVyNleSFbI2V5IWcjZXkhbiNleSFvI2V5IXAjZXkhdyNleSF5I2V5IXsjZXkhfSNleSNQI2V5I1QjZXkjViNleSNZI2V5I1ojZXkjXSNleSNkI2V5I2cjZXkjayNleSNtI2V5I3IjZXkjdSNleSRpI2V5JGojZXkkfCNleSR9I2V5JVIjZXklUyNleSVnI2V5JWgjZXklayNleSVuI2V5JXQjZXkldyNleSV5I2V5JG0jZXkkbiNleSRvI2V5fk8kbSt2TyRuKndPJG8rdk9+TyNpK3dPUCNmeVQjZnlkI2Z5ZiNmeWwjZnlwI2Z5cyNmeXUjZnl9I2Z5IU8jZnkhUyNmeSFUI2Z5IVcjZnkhWyNmeSFnI2Z5IW4jZnkhbyNmeSFwI2Z5IXcjZnkheSNmeSF7I2Z5IX0jZnkjUCNmeSNUI2Z5I1YjZnkjWSNmeSNaI2Z5I10jZnkjZCNmeSNnI2Z5I2sjZnkjbSNmeSNyI2Z5I3UjZnkkaSNmeSRqI2Z5JHwjZnkkfSNmeSVSI2Z5JVMjZnklZyNmeSVoI2Z5JWsjZnklbiNmeSV0I2Z5JXcjZnkleSNmeSRtI2Z5JG4jZnkkbyNmeX5PeCdWT3kmUnF+TyVYK1JPeCZUYSFQJlRhfk94JGdYIVAkZ1h+UCFJb094K1ZPIVAmU2F+T2wscU9zLU9PeSxQT3gkT2khWCRPaX5QJ1VPbCxxT3MtT094JE9pIVgkT2l+UCdVT3ksUE94JE9pIVgkT2l+T3gnZU8hWCVlcX5PbCxxT3MtT094J2VPIVglZXF+UCdVT3AsVU8hUyVjTyFUJWJPIVAlXXEhWCVdcSFdJV1xeCVdcX5QIS9nT3gjfGkhXSN8aX5QJGJPI1csWU94JF9hI18kX2EkaiRfYSRtJF9hIVAkX2F+T3gqZk8jXyV9aSRqJX1pJG0lfWkhUCV9aX5PIVAsW09+T3EsXk9QI2UhUlQjZSFSZCNlIVJmI2UhUmwjZSFScCNlIVJzI2UhUnUjZSFSfSNlIVIhTyNlIVIhUyNlIVIhVCNlIVIhVyNlIVIhWyNlIVIhZyNlIVIhbiNlIVIhbyNlIVIhcCNlIVIhdyNlIVIheSNlIVIheyNlIVIhfSNlIVIjUCNlIVIjVCNlIVIjViNlIVIjWSNlIVIjWiNlIVIjXSNlIVIjZCNlIVIjZyNlIVIjayNlIVIjbSNlIVIjciNlIVIjdSNlIVIkaSNlIVIkaiNlIVIkfCNlIVIkfSNlIVIlUiNlIVIlUyNlIVIlZyNlIVIlaCNlIVIlayNlIVIlbiNlIVIldCNlIVIldyNlIVIleSNlIVIkbSNlIVIkbiNlIVIkbyNlIVJ+T2wscU9zLU9PeCRPcSFYJE9xflAnVU95LGNPeCRPcSFYJE9xfk94J2VPIVglZXl+T2wscU9zLGdPflAnVU9wLFVPIVMlY08hVCViTyFQJV15IVglXXkhXSVdeXglXXl+UCEvZ094KmZPI18lfXEkaiV9cSRtJX1xIVAlfXF+T2wscU9zLU9PeCRPeSFYJE95flAnVU94J2VPIVglZSFSfk9wJWBYIVAlYFghUyVgWCFUJWBYIVglYFghXSVgWHglYFh+UCEvZ09wLFVPIVMlY08hVCViTyFQJV9hIVglX2EhXSVfYXglX2F+T3ksb09+T3gobE8jXyR1YSRqJHVhJG0kdWElWCR1YX5QJGJPayx2T35PbCx2T35QJ1VPeSx3T35PcSx4T35QIS9nTyVoJWsldyV5JWclbiV0JVMlZ35cIixcbiAgZ290bzogXCIhJmgmVVBQUFAmVlAmXyh8KWQpeyplK08ralAsVlAmXyx0LHQmX1AmX1AvY1BQUFBQUC9jMWJQUDFiUDJ9UDNXN2BQUDdjN283clBQUCZfJl9QUDhPJl9QUCZfJl9QUCZfJl8mXyZfOFM4eCZfUDh7UDlPOU87cVA8ViZfUFBQPFo8YSZWUCZWJlZQJlZQJlZQJlZQJlZQJlYmViZWUCZWUFAmVlBQJlZQPGdQPG48dFA8blA8bjxuUFBQPG5QPm1QPnY+fD9TPm1QPG4/WVA/YT9nP20/eUBUQFpAZUBvQHVBY0FpQW9BdUJQQlZCXUJjQmlCb0NSQ11DY0NpQ29DeURQRFZEXURjRG1Ec0R9RVRQUFBQUFBQUFBFXkVoRXFFe0ZXUFBQUFBQUFBQUFBQSX1KZ05VISFxUFAhIXkhI1ghI2IhJFchI30hJGEhJGchJGohJG0hJHAhJHZQUFBQUFBQUFBQISR5ISR8UFBQUFBQUFBQISVTISVgISVsISV4ISV7ISZSISZYISZfISZiXWlPciNtJG0nUSp3JlhkT1NYWVplaHJzdHZ4fH0hUiFTIVQhVSFYIWMhZCFlIWYhZyFoIWkhaiFsIW8hcCFxIXMhdCF6IX0jUiNTI10jaiNtJE8kUCRSJFQkVyRoJGokayRtJHwlUiVZJV0lXyViJWYlayVtJXcmUSZdJmEmaiZsJm0mdCZ4JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncSdzJ3cnfChTKFkoXShsKHspUClUKWopcil1KXspfCpPKlgqXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgseSx7LVB5IWNQI2kjdiRYJGclZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHV7IWRQI2kjdiRYJGckcyVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdX0hZVAjaSN2JFgkZyRzJHQlZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUhUCFmUCNpI3YkWCRnJHMkdCR1JWQlaSVvJXAmYiZ6KGQobilPKXkqUSpTKnIrZix1IVIhZ1AjaSN2JFgkZyRzJHQkdSR2JWQlaSVvJXAmYiZ6KGQobilPKXkqUSpTKnIrZix1IVQhaFAjaSN2JFgkZyRzJHQkdSR2JHclZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUhWCFpUCFuI2kjdiRYJGckcyR0JHUkdiR3JHglZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUmWFNPU1hZWmVocnN0dnh8fSFSIVMhVCFVIVghYyFkIWUhZiFnIWghaSFqIWwhbyFwIXEhcyF0IXohfSNSI1MjXSNqI20kTyRQJFIkVCRXJGgkaiRrJG0kfCVSJVklXSVfJWIlZiVrJW0ldyZRJl0mYSZqJmwmbSZ0JngmeydRJ1MnVidhJ2InZSdnJ2gnbCdxJ3Mndyd8KFMoWShdKGwoeylQKVQpailyKXUpeyl8Kk8qWCpdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx5LHstUCR5VU9YWVpocnR2fH0hUiFTIVQhWCFqIWwhbyFwIXEhcyF0I10jaiNtJFAkUiRUJFckayRtJHwlUiVZJV0lXyVmJWslbSV3Jl0mYSZsJm0mdCZ7J1EnUydWJ2EnYidlJ2cnaCdsJ3MoWShdKGwoeylUKWopcil1KXspfCpPKl0qZSp3K1MrWitbK2ArYitlK3wsUCxVLGMsbyxxLHIscyx0LHYsdyx4LHstUCRUV09YWVpocnZ8fSFSIVMhVCFYIWohbCNdI2ojbSRQJFIkVCRXJGskbSR8JVIlXSVfJWYlayVtJXcmXSZhJmwmbSZ0JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncyhZKF0obCh7KVQpailyKXUpeypPKl0qZSp3K1MrWitbK2ArZSt8LFAsYyx3LHhRI3x1USxtLGdSLHwtTyZTZE9TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWwhbyFwIXEhcyF0IXohfSNSI1MjXSNqI20kTyRQJFIkVCRXJGgkaiRrJG0kfCVSJVklXSVfJWIlZiVrJW0ldyZRJl0mYSZqJmwmbSZ0JngmeydRJ1MnVidhJ2UnZydoJ2wncSdzJ3cnfChTKFkoXShsKHspUClUKWopcil1KXspfCpPKlgqXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgseSx7LVBXI3BsIU8hUCRfVyN4dSZfLGctT1EkYSFRUSRxIVlRJHIhWlMkeyFqJ2JTJl4jeSN6USdPJGxRKGUmV1EociZuVyhzJnAodCh1KmtRKHYmclEpYidYUyljJ1orVlMrVSlkKWVRK2oqZlErbCpoUSt4Kn1RK3orUFIsaixZUiZdI3hlIXdYWSFTIVQlXyVmJ3Moeyl7Kk9SJV0hdlEhe1hRJXgjXVEmZiRUUiZpJFdULGYsVSxvIVkha1AhbiNpI3YkWCRnJHMkdCR1JHYkdyR4JHklZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHVRJlojcVInXiRyUidhJHtSJVUhbSZXY09TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWohbCFvIXAhcSFzIXQheiF9I1IjUyNdI2ojbSRPJFAkUiRUJFckaCRqJGskbSR8JVIlWSVdJV8lYiVmJWslbSV3JlEmXSZhJmombCZtJnQmeCZ7J1EnUydWJ2EnYidlJ2cnaCdsJ3Encyd3J3woUyhZKF0obCh7KVApVClqKXIpdSl7KXwqTypYKl0qZSp3K1MrWitbK2ArYitlK3wsUCxVLGMsbyxxLHIscyx0LHYsdyx4LHksey1QVCNnYyNoUyNeXyNfUyNhYCNiUyNjYSNkUyNlYiNmVCpgKGAqYVQoYSV4KGNRJFZ3UitUKWNYJFR3JFUkViZoWmtPciRtJ1Eqd1hvT3InUSp3USRuIVdRJnYkZVEmdyRmUSdZJHBRJ10kclEpVSZ9USlbJ1NRKV4nVFEpXydVUSlrJ1tRKW0nXlEqbih7USpwKHxRKnEofVEqcylTUyp1KVYpbFEqeilZUSp7KVpRKnwpXVErbyptUStwKm9RK3IqdFErcyp2USt5K09RLF0rcVEsXyt3USxgK3hSLGssXldvT3InUSp3UiNzblEnWyRxUilWJ09RK1MpY1IrfCtUUSlsJ1tSKnYpVlptT25yJ1Eqd1FyT1IjdXJRJmAje1IoaiZgUyVsI1EjfVMoVCVsKFdUKFclbyZiUSVgIXlTJ3QlYCd5Uid5JWRRJmskWFIobyZrUSVnIXxTJ30lZyhQUihQJWlRKFolcFEqVChVVCpZKFoqVFEnYyR9UilwJ2NTJ2YlUSVSWSlzJ2YpdCteLFMsZFUpdCdnJ2gnaVUrXil1KXYpd1MsUytfK2BSLGQsVFEjWF1SJXMjWFEjW15SJXUjW1EjX19SJXkjX1EoXiV2UypeKF4qX1IqXyhfUSphKGBSK2gqYVEjYmBSJXsjYlEjZGFSJXwjZFEjZmJSJX0jZlEjaGNSJk8jaFEja2ZRJlAjaVcmUyNrJlAobSpkUShtJmVSKmQsdVEkVXdTJmckVSZoUiZoJFZRJnUkY1IoeSZ1USZYI3BSKGYmWFEkXyFQUiZvJF9RKmcoc1MraypnLFpSLForbFEmcyRhUih3JnNRI25qUiZVI25RKngpV1IrdSp4USh6JnZSKmwoelEmeSRnUylRJnkpUlIpUiZ6USdSJG5SKVgnUlEnVyRvUylhJ1crUVIrUSliUStXKWdSLE8rV1duT3InUSp3UiNyblNxT3JRKVcnUVIrdCp3V3BPcidRKndSJ1AkbVlqT3IkbSdRKndSJlQjbVt3T3IjbSRtJ1Eqd1ImZiRUJHhQT1hZWmhydHZ8fSFSIVMhVCFYIWohbCFvIXAhcSFzIXQjXSNqI20kUCRSJFQkVyRrJG0kfCVSJVklXSVfJWYlayVtJXcmXSZhJmwmbSZ0JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncyhZKF0obCh7KVQpailyKXUpeyl8Kk8qXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgsey1QUSFuU1EjaWVRI3ZzVSRYeCViJ3dTJGchVSRqUSRzIWNRJHQhZFEkdSFlUSR2IWZRJHchZ1EkeCFoUSR5IWlRJWQhelElaSF9USVvI1JRJXAjU1EmYiRPUSZ6JGhRKGQmUVEobiZqUSlPJnhRKXkncVEqUSd8USpTKFNRKnIpUFErZipYUix1LHlRIXlYUSF8WVEkZSFTUSRmIVRXJ3AlXydzKXsqT1EneyVmUipvKHtbZk9yI20kbSdRKndkIXZYWSFTIVQlXyVmJ3Moeyl7Kk9RI1FaUSNsaFMjfXZ8USRbfVckYyFSJFcmeylUUyRvIVgka1MkeiFqJ2JRJVEhbFEldiNdUyZSI2oobFEmYyRQUSZkJFJRJmUkVFEnXyR8USdpJVJRJ28lXVEoUiVrUShVJW1RKF8ld1EoaCZdUyhrJmEsd1EocCZsUShxJm1RKHgmdFEpXSdTUSlgJ1ZRKW4nYVEpcSdlUSl2J2dRKXcnaFMpeCdsLHhRKlcoWVEqWyhdUStZKWpRK10pclErXyl1UStnKl1RK2kqZVEreytTUSxRK1pRLFIrW1EsVCtgUSxYK2VRLGErfFEsYixQUixsLGNiVE9yI2ojbSRtJmEnUSdsKncjcCF1WFlaaHZ8fSFSIVMhVCFYIWohbCNdJFAkUiRUJFckayR8JVIlXSVfJWYlayVtJXcmXSZsJm0mdCZ7J1MnVidhJ2InZSdnJ2gncyhZKF0obCh7KVQpailyKXUpeypPKl0qZStTK1orWytgK2UrfCxQLGMsdyx4USN3dFclViFvIXMscix7USVXIXBRJVghcVElWiF0USVlLHFTJ2slWSx2USdtLHNRJ24sdFErYSl8USxXK2JTLGUsVSxvUix9LVBVI3t1LGctT1IoaSZfW2dPciNtJG0nUSp3WCF4WCNdJFQkV1EjVlpRJFF2UiRafFElYSF5USVoIXxRJW4jUVEnXyR6USd6JWRRKFElaVEoWCVvUShbJXBRKlUoVVEsVithUSxpLFdSLG4saFEkWXhRJ3YlYlIpfSd3USxoLFVSLHAsb1IjUFlSI1VaUiVQIWpRJH0halIpbydiUiVTIWxSJXgjXVEoYiV4UipjKGNRJGQhUlEmaSRXUSlTJntSKnQpVFEjcWxRJF0hT1EkYCFQUiZxJF9RKHImcFEqaSh0USpqKHVSK24qa1IkYiFRWHBPcidRKndRJGkhVVImfCRqUSRwIVhSJn0ka1IpaSdaUSlnJ1pSK30rVlwiLFxuICBub2RlTmFtZXM6IFwi4pqgIHByaW50IENvbW1lbnQgU2NyaXB0IEFzc2lnblN0YXRlbWVudCAqIEJpbmFyeUV4cHJlc3Npb24gQml0T3AgQml0T3AgQml0T3AgQml0T3AgQXJpdGhPcCBBcml0aE9wIEAgQXJpdGhPcCAqKiBVbmFyeUV4cHJlc3Npb24gQXJpdGhPcCBCaXRPcCBBd2FpdEV4cHJlc3Npb24gYXdhaXQgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gKCBCaW5hcnlFeHByZXNzaW9uIG9yIGFuZCBDb21wYXJlT3AgaW4gbm90IGlzIFVuYXJ5RXhwcmVzc2lvbiBDb25kaXRpb25hbEV4cHJlc3Npb24gaWYgZWxzZSBMYW1iZGFFeHByZXNzaW9uIGxhbWJkYSBQYXJhbUxpc3Qgc2VsZiBWYXJpYWJsZU5hbWUgQXNzaWduT3AgLCA6IE5hbWVkRXhwcmVzc2lvbiBBc3NpZ25PcCBZaWVsZEV4cHJlc3Npb24geWllbGQgZnJvbSApIFR1cGxlRXhwcmVzc2lvbiBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBhc3luYyBmb3IgTGFtYmRhRXhwcmVzc2lvbiBBcnJheUV4cHJlc3Npb24gWyBdIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gRGljdGlvbmFyeUV4cHJlc3Npb24geyB9IERpY3Rpb25hcnlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBTZXRFeHByZXNzaW9uIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uIENhbGxFeHByZXNzaW9uIEFyZ0xpc3QgQXNzaWduT3AgTWVtYmVyRXhwcmVzc2lvbiAuIFByb3BlcnR5TmFtZSBOdW1iZXIgU3RyaW5nIEZvcm1hdFN0cmluZyBGb3JtYXRSZXBsYWNlbWVudCBGb3JtYXRDb252ZXJzaW9uIEZvcm1hdFNwZWMgQ29udGludWVkU3RyaW5nIEVsbGlwc2lzIE5vbmUgQm9vbGVhbiBUeXBlRGVmIEFzc2lnbk9wIFVwZGF0ZVN0YXRlbWVudCBVcGRhdGVPcCBFeHByZXNzaW9uU3RhdGVtZW50IERlbGV0ZVN0YXRlbWVudCBkZWwgUGFzc1N0YXRlbWVudCBwYXNzIEJyZWFrU3RhdGVtZW50IGJyZWFrIENvbnRpbnVlU3RhdGVtZW50IGNvbnRpbnVlIFJldHVyblN0YXRlbWVudCByZXR1cm4gWWllbGRTdGF0ZW1lbnQgUHJpbnRTdGF0ZW1lbnQgUmFpc2VTdGF0ZW1lbnQgcmFpc2UgSW1wb3J0U3RhdGVtZW50IGltcG9ydCBhcyBTY29wZVN0YXRlbWVudCBnbG9iYWwgbm9ubG9jYWwgQXNzZXJ0U3RhdGVtZW50IGFzc2VydCBTdGF0ZW1lbnRHcm91cCA7IElmU3RhdGVtZW50IEJvZHkgZWxpZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBGb3JTdGF0ZW1lbnQgVHJ5U3RhdGVtZW50IHRyeSBleGNlcHQgZmluYWxseSBXaXRoU3RhdGVtZW50IHdpdGggRnVuY3Rpb25EZWZpbml0aW9uIGRlZiBQYXJhbUxpc3QgQXNzaWduT3AgVHlwZURlZiBDbGFzc0RlZmluaXRpb24gY2xhc3MgRGVjb3JhdGVkU3RhdGVtZW50IERlY29yYXRvciBBdFwiLFxuICBtYXhUZXJtOiAyMzYsXG4gIG5vZGVQcm9wczogW1xuICAgIFtsZXplci5Ob2RlUHJvcC5ncm91cCwgLTE0LDQsODEsODMsODQsODYsODgsOTAsOTIsOTQsOTUsOTYsOTgsMTAxLDEwNCxcIlN0YXRlbWVudCBTdGF0ZW1lbnRcIiwtMjMsNiwxNiwxOSwyMSwzNywzOCw0OCw0OSw1Myw1Niw1Nyw2MCw2MSw2Miw2Myw2Niw2OSw3MCw3MSw3NSw3Niw3Nyw3OCxcIkV4cHJlc3Npb25cIiwtOSwxMDYsMTA4LDExMSwxMTMsMTE0LDExOCwxMjAsMTI1LDEyNyxcIlN0YXRlbWVudFwiXVxuICBdLFxuICBza2lwcGVkTm9kZXM6IFswLDJdLFxuICByZXBlYXROb2RlQ291bnQ6IDMzLFxuICB0b2tlbkRhdGE6IFwiIUV9TWdSIV5PWCR9WFkld1lbJH1bXSV3XXAkfXBxJXdxcihjcnMqVXN0Mk90dSR9dXY0UXZ3NVV3eDV4eHlBV3l6QXR6e0Jie3xDcnx9RGZ9IU9FUyFPIVBGWiFQIVFLYSFRIVJMcSFSIVshKFAhWyFdISlpIV0hXiEqbSFeIV8hK1ohXyFgISxrIWAhYSEtXyFhIWIkfSFiIWMhLmwhYyFkIS9iIWQhZSExZiFlIWghL2IhaCFpIThPIWkhdCEvYiF0IXUhPWIhdSF3IS9iIXcheCE/YCF4IX0hL2IhfSNPIUB0I08jUCFBYiNQI1EhQmMjUSNSIUNQI1IjUyEvYiNTI1QkfSNUI1UhL2IjVSNWITFmI1YjWSEvYiNZI1ohOE8jWiNmIS9iI2YjZyE9YiNnI2khL2IjaSNqIT9gI2ojbyEvYiNvI3AhQ3MjcCNxIURbI3EjciFFTyNyI3MhRWEjcyRnJH0kZ34hL2I8ciVgUiVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWk3WyVuUiVyN1tPI28laSNwI3ElaSNyfiVpTWcmW1olb2AldXAlcjdbJXghYiV6I3QlaVMlbFckcTFzT1glaVhZJn1ZWyVpW10mfV1wJWlwcSZ9cSNPJWkjTyNQJ3cjUCNvJWkjcCNxJWkjcn4laUhQJ1VaJXI3WyRxMXNPWCVpWFkmfVlbJWlbXSZ9XXAlaXBxJn1xI08laSNPI1AndyNQI28laSNwI3ElaSNyfiVpSFAnfFYlcjdbT1klaVlaJn1aXSVpXV4mfV4jbyVpI3AjcSVpI3J+JWk8dSh0WSVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYClkIWAjVCVpI1QjVSl0I1UjZiVpI2YjZyl0I2cjaCl0I2gjbyVpI3AjcSVpI3J+JWk3XylrUmpSJXI3W08jbyVpI3AjcSVpI3J+JWk3Xyl7UiFrUiVyN1tPI28laSNwI3ElaSNyfiVpR3sqZV0ldnAlb2AlcjdbJXghYiVpUyVnLFhPWSteWVoue1pdK15dXi57XnIrXnJzL11zI08rXiNPI1AwfCNQI28rXiNvI3AxYiNwI3ErXiNxI3IxYiNyfiteQm0rZ10lcjdbJWxXJWcsWE9ZLGBZWiVpWl0sYF1eJWlecixgcnMtYHMjTyxgI08jUC1wI1AjbyxgI28jcC5VI3AjcSxgI3Ejci5VI3J+LGBCZSxnXSVyN1slZyxYT1ksYFlaJWlaXSxgXV4laV5yLGBycy1gcyNPLGAjTyNQLXAjUCNvLGAjbyNwLlUjcCNxLGAjcSNyLlUjcn4sYEJlLWdSJXI3WyVnLFhPI28laSNwI3ElaSNyfiVpQmUtdVQlcjdbTyNvLGAjbyNwLlUjcCNxLGAjcSNyLlUjcn4sYCxYLlpWJWcsWE9ZLlVaXS5VXnIuVXJzLnBzI08uVSNPI1AudSNQfi5VLFgudU8lZyxYLFgueFBPfi5VN2QvU1IlcjdbJWxXTyNvJWkjcCNxJWkjcn4laUVjL2RYJXI3WyVnLFhPci57cnMwUHMjTy57I08jUDBjI1Ajby57I28jcDB3I3AjcS57I3EjcjB3I3J+LntFYzBZUiVtI3wlcjdbJWssWE8jbyVpI3AjcSVpI3J+JWk3ZDBoVCVyN1tPI28ueyNvI3AwdyNwI3EueyNxI3IwdyNyfi57VzB8TyVsV0JtMVJUJXI3W08jbyteI28jcDFiI3AjcSteI3EjcjFiI3J+K14sYTFpViVsVyVnLFhPWS5VWl0uVV5yLlVycy5wcyNPLlUjTyNQLnUjUH4uVU1nMmNYUTFzJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXT1kzT1laJWlaXTNPXV4laV4jbzNPI28jcDNyI3AjcTNPI3EjcjNyI3J+M09IUDNWWFExcyVyN1tPWTNPWVolaVpdM09dXiVpXiNvM08jbyNwM3IjcCNxM08jcSNyM3Ijcn4zTzFzM3dSUTFzT1kzclpdM3JefjNyR3o0ZVQlUFElb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpQmQ0e1IhdCxXJXI3W08jbyVpI3AjcSVpI3J+JWlHejVpVCR5USVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHezZYXyVzYCV1cCVyN1sleiN0JWxXJWcsWE9ZN1dZWjpkWl03V11eOmRecjdXcnM6eHN3N1d3eDt8eCNPN1cjTyNQPm4jUCNvN1cjbyNwP3QjcCNxN1cjcSNyP1Mjcn43V0ZxN2VdJXI3WyV4IWIleiN0JWlTJWcsWE9ZOF5ZWiVpWl04Xl1eJWledzhed3gtYHgjTzheI08jUDleI1AjbzheI28jcDlyI3AjcTheI3EjcjlyI3J+OF5CZThlXSVyN1slZyxYT1k4XllaJWlaXTheXV4laV53OF53eC1geCNPOF4jTyNQOV4jUCNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XkJlOWNUJXI3W08jbzheI28jcDlyI3AjcTheI3EjcjlyI3J+OF4sWDl3ViVnLFhPWTlyWl05cl53OXJ3eC5weCNPOXIjTyNQOl4jUH45cixYOmFQT345cjtoOm9SJXI3WyV4IWIleiN0JWlTTyNvJWkjcCNxJWkjcn4laUN7O1RdJXI3WyV4IWIlaVMlZyxYT1k4XllaJWlaXTheXV4laV53OF53eC1geCNPOF4jTyNQOV4jUCNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XkZxPFZaJXI3WyV6I3QlZyxYT3I6ZHJzPHhzdzpkd3g9W3gjTzpkI08jUD1wI1AjbzpkI28jcD5fI3AjcTpkI3Ejcj5VI3J+OmQ4cj1SUiVyN1sleCFiJWlTTyNvJWkjcCNxJWkjcn4laUZxPWdSJWohZiVyN1sleiN0JWgsWE8jbyVpI3AjcSVpI3J+JWk7aD11VCVyN1tPI286ZCNvI3A+VSNwI3E6ZCNxI3I+VSNyfjpkJVs+X08leCFiJXojdCVpUyVbPmRQJWlTI28jcD5nJVc+bk8leCFiJXojdEZxPnNUJXI3W08jbzdXI28jcD9TI3AjcTdXI3Ejcj9TI3J+N1cwZT9fViV4IWIleiN0JWlTJWcsWE9ZOXJaXTlyXnc5cnd4LnB4I085ciNPI1A6XiNQfjlyMGU/e1glaVMlZyxYT1k5clpdOXJedzlyd3gucHgjTzlyI08jUDpeI1AjbzlyI28jcEBoI3B+OXIwYUBxViV4IWIleiN0JWcsWE9ZOXJaXTlyXnc5cnd4LnB4I085ciNPI1A6XiNQfjlyR3tBa1JmLFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpPHVCWFIhUFIlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpR3tCdVZULFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPeiVpentDW3shXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlCZUNjVF9SJXI3W08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHe0RWVCR8LFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpR3tEeVJ4LFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpTWdFZ1UkfSxYJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCFhRXkhYSNvJWkjcCNxJWkjcn4laTx2RlFSJlUmaiVyN1tPI28laSNwI3ElaSNyfiVpR3tGblYhZVElb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIU8laSFPIVBHVCFQIVElaSFRIVtHeSFbI28laSNwI3ElaSNyfiVpQmVHWVQlcjdbTyFPJWkhTyFQR2khUCNvJWkjcCNxJWkjcn4laUJlR3BSIW4sWCVyN1tPI28laSNwI3ElaSNyfiVpQmNIUV8hZyxWJXI3W08hUSVpIVEhW0d5IVshZyVpIWchaElQIWghbCVpIWwhbUtQIW0jUiVpI1IjU0d5I1MjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCY0lVWCVyN1tPeyVpe3xJcXx9JWl9IU9JcSFPIVElaSFRIVtKViFbI28laSNwI3ElaSNyfiVpQmNJdlQlcjdbTyFRJWkhUSFbSlYhWyNvJWkjcCNxJWkjcn4laUJjSl5aIWcsViVyN1tPIVElaSFRIVtKViFbIWwlaSFsIW1LUCFtI1IlaSNSI1NKViNTI14laSNeI19LUCNfI28laSNwI3ElaSNyfiVpQmNLV1IhZyxWJXI3W08jbyVpI3AjcSVpI3J+JWlHe0t0ViVPUiVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hUCVpIVAhUUxaIVEhXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlCZExiVCVRUSVyN1tPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpR3lNVW0hZyxWJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFPJWkhTyFQISBQIVAhUSVpIVEhWyEhayFbIWQlaSFkIWUhI3chZSFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSFxJWkhcSFyISVWIXIheiVpIXoheyEmXyF7I1IlaSNSI1MhIWsjUyNVJWkjVSNWISN3I1YjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jYyVpI2MjZCElViNkI2wlaSNsI20hJl8jbSNvJWkjcCNxJWkjcn4laUJjISBVVCVyN1tPIVElaSFRIVshIGUhWyNvJWkjcCNxJWkjcn4laUJjISBsXyFnLFYlcjdbTyFRJWkhUSFbISBlIVshZyVpIWchaElQIWghbCVpIWwhbUtQIW0jUiVpI1IjUyEgZSNTI1glaSNYI1lJUCNZI14laSNeI19LUCNfI28laSNwI3ElaSNyfiVpQmMhIXJhIWcsViVyN1tPIU8laSFPIVAhIFAhUCFRJWkhUSFbISFrIVshZyVpIWchaElQIWghbCVpIWwhbUtQIW0jUiVpI1IjUyEhayNTI1glaSNYI1lJUCNZI14laSNeI19LUCNfI28laSNwI3ElaSNyfiVpQmMhI3xXJXI3W08hUSVpIVEhUiEkZiFSIVMhJGYhUyNSJWkjUiNTISRmI1MjbyVpI3AjcSVpI3J+JWlCYyEkbVchZyxWJXI3W08hUSVpIVEhUiEkZiFSIVMhJGYhUyNSJWkjUiNTISRmI1MjbyVpI3AjcSVpI3J+JWlCYyElW1YlcjdbTyFRJWkhUSFZISVxIVkjUiVpI1IjUyElcSNTI28laSNwI3ElaSNyfiVpQmMhJXhWIWcsViVyN1tPIVElaSFRIVkhJXEhWSNSJWkjUiNTISVxI1MjbyVpI3AjcSVpI3J+JWlCYyEmZFolcjdbTyFRJWkhUSFbISdWIVshYyVpIWMhaSEnViFpI1IlaSNSI1MhJ1YjUyNUJWkjVCNaISdWI1ojbyVpI3AjcSVpI3J+JWlCYyEnXlohZyxWJXI3W08hUSVpIVEhWyEnViFbIWMlaSFjIWkhJ1YhaSNSJWkjUiNTISdWI1MjVCVpI1QjWiEnViNaI28laSNwI3ElaSNyfiVpR3khKGRhIWcsViVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hTyVpIU8hUCEgUCFQIVElaSFRIVshIWshWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTISFrI1MjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlNZyEpfFR5MXMlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWAhKl0hYCNvJWkjcCNxJWkjcn4laTdfISpkUiVZUiVyN1tPI28laSNwI3ElaSNyfiVpR3shK1FSI18sWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlHeyErblZqUiVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXiVpIV4hXyEsVCFfIWApZCFgIWEpZCFhI28laSNwI3ElaSNyfiVpQmQhLFtUJHpRJXI3W08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHeyEtT1QlWCxYJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgKWQhYCNvJWkjcCNxJWkjcn4laUd7IS1yVWpSJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgKWQhYCFhIS5VIWEjbyVpI3AjcSVpI3J+JWlCZCEuXVQke1ElcjdbTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7IS9SVF1RI3VQJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laU1nIS93WiVvYCV1cCVyN1sleCFiJXojdCVpUyVsVyVmJmolUyxYTyFRJWkhUSFbITBqIVshYyVpIWMhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNvITBqI3AjcSVpI3IkZyVpJGd+ITBqSFAhMHNaJXI3WyVmJmolUyxYTyFRJWkhUSFbITBqIVshYyVpIWMhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNvITBqI3AjcSVpI3IkZyVpJGd+ITBqTWchMXtjJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXJWYmaiVTLFhPciVpcnMhM1dzdyVpd3ghNU94IVElaSFRIVshMGohWyFjJWkhYyF0ITBqIXQhdSE2diF1IX0hMGohfSNSJWkjUiNTITBqI1MjVCVpI1QjZiEwaiNmI2chNnYjZyNvITBqI3AjcSVpI3IkZyVpJGd+ITBqQmUhM19dJXI3WyVnLFhPWSxgWVolaVpdLGBdXiVpXnIsYHJzITRXcyNPLGAjTyNQLXAjUCNvLGAjbyNwLlUjcCNxLGAjcSNyLlUjcn4sYEJlITRfVCVyN1slZyxYT3IlaXJzITRucyNvJWkjcCNxJWkjcn4laUJlITR1UiVyN1slayxYTyNvJWkjcCNxJWkjcn4laUJlITVWXSVyN1slZyxYT1k4XllaJWlaXTheXV4laV53OF53eCE2T3gjTzheI08jUDleI1AjbzheI28jcDlyI3AjcTheI3EjcjlyI3J+OF5CZSE2VlQlcjdbJWcsWE93JWl3eCE2ZngjbyVpI3AjcSVpI3J+JWlCZSE2bVIlcjdbJWgsWE8jbyVpI3AjcSVpI3J+JWlIUCE3UF8lcjdbJWYmaiVTLFhPciVpcnMhM1dzdyVpd3ghNU94IVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpNZyE4ZWMlb2AldXAlcjdbJXghYiV6I3QlaVMlbFclZiZqJVMsWE9yJWlycyE5cHN3JWl3eCE6fHghUSVpIVEhWyEwaiFbIWMlaSFjIXQhMGohdCF1ITxZIXUhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNmITBqI2YjZyE8WSNnI28hMGojcCNxJWkjciRnJWkkZ34hMGpCZSE5d1QlcjdbJXQsWE9yJWlycyE6V3MjbyVpI3AjcSVpI3J+JWlCZSE6XVQlcjdbT3IlaXJzITpscyNvJWkjcCNxJWkjcn4laUJlITpzUiVyN1sleSxYTyNvJWkjcCNxJWkjcn4laUJlITtUVCVyN1slbixYT3claXd4ITtkeCNvJWkjcCNxJWkjcn4laUJlITtpVCVyN1tPdyVpd3ghO3h4I28laSNwI3ElaSNyfiVpQmUhPFBSJXI3WyV3LFhPI28laSNwI3ElaSNyfiVpSFAhPGNfJXI3WyVmJmolUyxYT3IlaXJzITlwc3claXd4ITp8eCFRJWkhUSFbITBqIVshYyVpIWMhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNvITBqI3AjcSVpI3IkZyVpJGd+ITBqTWchPXdnJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXJWYmaiVTLFhPciVpcnMhM1dzdyVpd3ghNU94IVElaSFRIVshMGohWyFjJWkhYyFoITBqIWghaSE8WSFpIXQhMGohdCF1ITZ2IXUhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNVITBqI1UjViE2diNWI1khMGojWSNaITxZI1ojbyEwaiNwI3ElaSNyJGclaSRnfiEwak1nIT91XyVvYCV1cCVyN1sleCFiJXojdCVpUyVsVyVmJmolUyxYT3IlaXJzITNXc3claXd4ITVPeCFRJWkhUSFbITBqIVshYyVpIWMhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNvITBqI3AjcSVpI3IkZyVpJGd+ITBqR3shQVhSIVcsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlNZyFBZ1glcjdbT1kkfVlaJXdaXSR9XV4ld14jbyR9I28jcCFCUyNwI3EkfSNxI3IhQlMjcn4kfSZmIUJjTyVvYCV1cCV4IWIleiN0JWlTJWxXPHUhQnZSIVhSJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laUd6IUNkVCR4USVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHeSFDfFAhW0dtJWlTJWxXI28jcCFEUCZZIURbTyVvYCV1cCV4IWIleiN0R3ohRG9UJHdRJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laTx1IUVhTyFdN18lb2AldXAleCFiJXojdCVpUyVsV0d5IUV0UiVSLFYlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpXCIsXG4gIHRva2VuaXplcnM6IFtsZWdhY3lQcmludCwgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIG5ld2xpbmVzLCBib2R5Q29udGludWVdLFxuICB0b3BSdWxlczoge1wiU2NyaXB0XCI6WzAsM119LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAxODgsIGdldDogdmFsdWUgPT4gc3BlY19pZGVudGlmaWVyW3ZhbHVlXSB8fCAtMX1dLFxuICB0b2tlblByZWM6IDYwNjdcbn0pO1xuXG5leHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8vIFRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG5jb25zdCBEZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTAyNDtcbmxldCBuZXh0UHJvcElEID0gMDtcbmNvbnN0IENhY2hlZE5vZGUgPSBuZXcgV2Vha01hcCgpO1xuLy8vIEVhY2ggW25vZGUgdHlwZV0oI3RyZWUuTm9kZVR5cGUpIGNhbiBoYXZlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aFxuLy8vIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbmNsYXNzIE5vZGVQcm9wIHtcbiAgICAvLy8gQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhXG4gICAgLy8vIGBkZXNlcmlhbGl6ZWAgZnVuY3Rpb24uXG4gICAgY29uc3RydWN0b3IoeyBkZXNlcmlhbGl6ZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG5vZGUgdHlwZSBkb2Vzbid0IGRlZmluZSBhIGRlc2VyaWFsaXplIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIHN0cmluZy12YWx1ZWQgbm9kZSBwcm9wIHdob3NlIGRlc2VyaWFsaXplIGZ1bmN0aW9uIGlzXG4gICAgLy8vIHRoZSBpZGVudGl0eSBmdW5jdGlvbi5cbiAgICBzdGF0aWMgc3RyaW5nKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIgfSk7IH1cbiAgICAvLy8gQ3JlYXRlIGEgbnVtYmVyLXZhbHVlZCBub2RlIHByb3Agd2hvc2UgZGVzZXJpYWxpemUgZnVuY3Rpb24gaXNcbiAgICAvLy8ganVzdCBgTnVtYmVyYC5cbiAgICBzdGF0aWMgbnVtYmVyKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IE51bWJlciB9KTsgfVxuICAgIC8vLyBDcmVhdGVzIGEgYm9vbGVhbi12YWx1ZWQgbm9kZSBwcm9wIHdob3NlIGRlc2VyaWFsaXplIGZ1bmN0aW9uXG4gICAgLy8vIHJldHVybnMgdHJ1ZSBmb3IgYW55IGlucHV0LlxuICAgIHN0YXRpYyBmbGFnKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6ICgpID0+IHRydWUgfSk7IH1cbiAgICAvLy8gU3RvcmUgYSB2YWx1ZSBmb3IgdGhpcyBwcm9wIGluIHRoZSBnaXZlbiBvYmplY3QuIFRoaXMgY2FuIGJlXG4gICAgLy8vIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIHVwIGEgcHJvcCBvYmplY3QgdG8gcGFzcyB0byB0aGVcbiAgICAvLy8gW2BOb2RlVHlwZWBdKCN0cmVlLk5vZGVUeXBlKSBjb25zdHJ1Y3Rvci4gUmV0dXJucyBpdHMgZmlyc3RcbiAgICAvLy8gYXJndW1lbnQuXG4gICAgc2V0KHByb3BPYmosIHZhbHVlKSB7XG4gICAgICAgIHByb3BPYmpbdGhpcy5pZF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHByb3BPYmo7XG4gICAgfVxuICAgIC8vLyBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVTZXQuZXh0ZW5kYF0oI3RyZWUuTm9kZVNldC5leHRlbmQpIG9yXG4gICAgLy8vIFtgUGFyc2VyLndpdGhQcm9wc2BdKCNsZXplci5QYXJzZXIud2l0aFByb3BzKSB0byBjb21wdXRlIHByb3BcbiAgICAvLy8gdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIC8vLyBvYmplY3RdKCN0cmVlLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgLy8vIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIC8vLyBpdCBkb2VzLlxuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbi8vLyBkZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbi8vLyBmb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYG9wZW5lZEJ5YF0oI3RyZWUuTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG4vLy8gYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbi8vLyBvZiB0eXBlcyBvZiBtYXRjaGluZyBvcGVuaW5nIGRlbGltaXRlcnMuXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBVc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG4vLy8gdHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuLy8vIGBcIkV4cHJlc3Npb25cImAgZ3JvdXApLlxuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vLyBFYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZS4gTm90IG5lY2Vzc2FyaWx5IHVuaXF1ZSwgYnV0IGlmIHRoZVxuICAgIC8vLyBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIC8vLyBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICAvLy8gcm9sZS5cbiAgICBuYW1lLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcHJvcHMsIFxuICAgIC8vLyBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIC8vLyB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgaWQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBUb3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIFNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKVxuICAgICAgICAgICAgICAgICAgICBzcmNbMF0uc2V0KHByb3BzLCBzcmNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIC8vLyB0aGUgcHJvcCBpc24ndCBwcmVzZW50IG9uIHRoaXMgbm9kZS5cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICBnZXQgaXNUb3AoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVG9wICovKSA+IDA7IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIFNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGFuIGVycm9yIG5vZGUuXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogRXJyb3IgKi8pID4gMDsgfVxuICAgIC8vLyBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICAvLy8gbmFtZWQgbm9kZSwgZm9yIGV4YW1wbGUgYmVjYXVzZSBpdCBpcyB1c2VkIHRvIGNhY2hlIHJlcGV0aXRpb24uXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIEFub255bW91cyAqLykgPiAwOyB9XG4gICAgLy8vIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIC8vLyBbZ3JvdXBzXSgjdHJlZS5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI3RyZWUuTm9kZVByb3BeZ3JvdXApIG5hbWVzLiBPZnRlbiB1c2VmdWwgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCN0cmVlLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgLy8vIG5hbWVzLCBzZXBhcmF0ZWQgYnkgc3BhY2VzLCBpbiBhIHNpbmdsZSBwcm9wZXJ0eSBuYW1lIHRvIG1hcFxuICAgIC8vLyBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbk5vZGVUeXBlLm5vbmUgPSBuZXcgTm9kZVR5cGUoXCJcIiwgT2JqZWN0LmNyZWF0ZShudWxsKSwgMCwgOCAvKiBBbm9ueW1vdXMgKi8pO1xuLy8vIEEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbi8vLyBjb21wYWN0bHkgcmVwcmVzZW50IHRyZWVzIGJ5IHN0b3JpbmcgdGhlaXIgdHlwZSBpZHMsIHJhdGhlciB0aGFuIGFcbi8vLyBmdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWJlciBhcnJheS4gRWFjaCBwYXJzZXJcbi8vLyBbaGFzXSgjbGV6ZXIuUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuLy8vIGJ1ZmZlcnNdKCN0cmVlLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpXG4vLy8gbm9kZSB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheVxuLy8vIHNsb3RzLlxuY2xhc3MgTm9kZVNldCB7XG4gICAgLy8vIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIC8vLyB0eXBlIHNob3VsZCBjb3JyZXNwb25kIHRvIGl0cyBwb3NpdGlvbiB3aXRoaW4gdGhlIGFycmF5LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgdHlwZXMpIHtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHR5cGVzW2ldLmlkICE9IGkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgaWRzIHNob3VsZCBjb3JyZXNwb25kIHRvIGFycmF5IHBvc2l0aW9ucyB3aGVuIGNyZWF0aW5nIGEgbm9kZSBzZXRcIik7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIC8vLyBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNyZWF0ZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCN0cmVlLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFswXS5zZXQobmV3UHJvcHMsIGFkZFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuLy8vIEEgcGllY2Ugb2Ygc3ludGF4IHRyZWUuIFRoZXJlIGFyZSB0d28gd2F5cyB0byBhcHByb2FjaCB0aGVzZVxuLy8vIHRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbi8vLyBjb252ZW5pZW50IHdheS5cbi8vL1xuLy8vIFN5bnRheCB0cmVlcyBhcmUgc3RvcmVkIGFzIGEgdHJlZSBvZiBgVHJlZWAgYW5kIGBUcmVlQnVmZmVyYFxuLy8vIG9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbi8vLyBub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuLy8vXG4vLy8gSG93ZXZlciwgd2hlbiB5b3Ugd2FudCB0byBhY3R1YWxseSB3b3JrIHdpdGggdHJlZSBub2RlcywgdGhpc1xuLy8vIHJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbi8vLyB1c2UgdGhlIGBUcmVlQ3Vyc29yYCBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXMgYSB2aWV3IG9uXG4vLy8gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0byBtb3ZlIGFyb3VuZFxuLy8vIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZSB7XG4gICAgLy8vIENvbnN0cnVjdCBhIG5ldyB0cmVlLiBZb3UgdXN1YWxseSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAvLy8gW2BUcmVlLmJ1aWxkYF0oI3RyZWUuVHJlZV5idWlsZCkgaW5zdGVhZC5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBcbiAgICAvLy8gVGhlIHRyZWUncyBjaGlsZCBub2Rlcy4gQ2hpbGRyZW4gc21hbGwgZW5vdWdoIHRvIGZpdCBpbiBhXG4gICAgLy8vIGBUcmVlQnVmZmVyIHdpbGwgYmUgcmVwcmVzZW50ZWQgYXMgc3VjaCwgb3RoZXIgY2hpbGRyZW4gY2FuIGJlXG4gICAgLy8vIGZ1cnRoZXIgYFRyZWVgIGluc3RhbmNlcyB3aXRoIHRoZWlyIG93biBpbnRlcm5hbCBzdHJ1Y3R1cmUuXG4gICAgY2hpbGRyZW4sIFxuICAgIC8vLyBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgLy8vIHRoZSBjaGlsZHJlbi5cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgIGxlbmd0aCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLm1hcChjID0+IGMudG9TdHJpbmcoKSkuam9pbigpO1xuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3RyZWUgY3Vyc29yXSgjdHJlZS5UcmVlQ3Vyc29yKSByb290ZWQgYXQgdGhpcyB0cmVlLiBXaGVuXG4gICAgLy8vIGBwb3NgIGlzIGdpdmVuLCB0aGUgY3Vyc29yIGlzIFttb3ZlZF0oI3RyZWUuVHJlZUN1cnNvci5tb3ZlVG8pXG4gICAgLy8vIHRvIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS5cbiAgICBjdXJzb3IocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSAocG9zICE9IG51bGwgJiYgQ2FjaGVkTm9kZS5nZXQodGhpcykpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCN0cmVlLlRyZWVDdXJzb3IpIHRoYXQsIHVubGlrZSByZWd1bGFyXG4gICAgLy8vIGN1cnNvcnMsIGRvZXNuJ3Qgc2tpcCBbYW5vbnltb3VzXSgjdHJlZS5Ob2RlVHlwZS5pc0Fub255bW91cylcbiAgICAvLy8gbm9kZXMuXG4gICAgZnVsbEN1cnNvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCN0cmVlLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICAvLy8gdHJlZS5cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgW3N5bnRheCBub2RlXSgjdHJlZS5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgLy8vIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgLy8vIGZyb20gYm90aCBzaWRlcy5cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yKHBvcywgc2lkZSkubm9kZTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIC8vLyBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgLy8vIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICAvLy8gbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhlIGdpdmVuIG5vZGVcbiAgICAvLy8gd2lsbCBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKTs7KSB7XG4gICAgICAgICAgICBsZXQgbXVzdExlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMudHlwZSwgYy5mcm9tLCBjLnRvKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjLnR5cGUsIGMuZnJvbSwgYy50byk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gYy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEJhbGFuY2UgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIHRyZWUuXG4gICAgYmFsYW5jZShtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSBCYWxhbmNlQnJhbmNoRmFjdG9yID8gdGhpc1xuICAgICAgICAgICAgOiBiYWxhbmNlUmFuZ2UodGhpcy50eXBlLCBOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIG1heEJ1ZmZlckxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICAvLy8gQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgLy8vIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICBzdGF0aWMgYnVpbGQoZGF0YSkgeyByZXR1cm4gYnVpbGRUcmVlKGRhdGEpOyB9XG59XG4vLy8gVGhlIGVtcHR5IHRyZWVcblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuLy8vIFRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbi8vLyBub2RlLiBJbiBzdWNoIGEgYnVmZmVyLCBub2RlcyBhcmUgc3RvcmVkIGluIHByZWZpeCBvcmRlciAocGFyZW50c1xuLy8vIGJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG4vLy8gY2hpbGRyZW4gYmVsb25nIHRvIGl0KVxuY2xhc3MgVHJlZUJ1ZmZlciB7XG4gICAgLy8vIENyZWF0ZSBhIHRyZWUgYnVmZmVyIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgc2V0LCB0eXBlID0gTm9kZVR5cGUubm9uZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmRDaGlsZChzdGFydEluZGV4LCBlbmRJbmRleCwgZGlyLCBhZnRlcikge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMsIHBpY2sgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgPSBidWZmZXJbaSArIDNdKSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgIT0gLTEwMDAwMDAwMCAvKiBOb25lICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gYnVmZmVyW2kgKyAxXSwgZW5kID0gYnVmZmVyW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID49IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH1cbn1cbmNsYXNzIFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBmcm9tLCBpbmRleCwgX3BhcmVudCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMubm9kZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLm5vZGUubGVuZ3RoOyB9XG4gICAgbmV4dENoaWxkKGksIGRpciwgYWZ0ZXIsIGZ1bGwgPSBmYWxzZSkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHsgY2hpbGRyZW4sIHBvc2l0aW9ucyB9ID0gcGFyZW50Lm5vZGUsIGUgPSBkaXIgPiAwID8gY2hpbGRyZW4ubGVuZ3RoIDogLTE7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2ldLCBzdGFydCA9IHBvc2l0aW9uc1tpXSArIHBhcmVudC5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlciAhPSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gJiYgKGRpciA8IDAgPyBzdGFydCA+PSBhZnRlciA6IHN0YXJ0ICsgbmV4dC5sZW5ndGggPD0gYWZ0ZXIpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIGFmdGVyID09IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA/IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA6IGFmdGVyIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmdWxsIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdWxsIHx8ICFpbm5lci50eXBlLmlzQW5vbnltb3VzID8gaW5uZXIgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdWxsIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCBwb3MpOyB9XG4gICAgbmV4dFNpZ25pZmljYW50UGFyZW50KCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHZhbC50eXBlLmlzQW5vbnltb3VzICYmIHZhbC5fcGFyZW50KVxuICAgICAgICAgICAgdmFsID0gdmFsLl9wYXJlbnQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAtMSkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgLTEpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGN1cnNvcigpIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMpOyB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKS5ub2RlO1xuICAgIH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMubm9kZS50b1N0cmluZygpOyB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlLCB0eXBlLCBiZWZvcmUsIGFmdGVyKSB7XG4gICAgbGV0IGN1ciA9IG5vZGUuY3Vyc29yLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICB3aGlsZSAoIWN1ci50eXBlLmlzKGJlZm9yZSkpXG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBfcGFyZW50LCBpbmRleCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbnRleHQuYnVmZmVyLnNldC50eXBlc1tjb250ZXh0LmJ1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDJdOyB9XG4gICAgY2hpbGQoZGlyLCBhZnRlcikge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgYWZ0ZXIgPT0gLTEwMDAwMDAwMCAvKiBOb25lICovID8gLTEwMDAwMDAwMCAvKiBOb25lICovIDogYWZ0ZXIgLSB0aGlzLmNvbnRleHQuc3RhcnQpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zKTsgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICB9XG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKHRoaXMuY29udGV4dC5pbmRleCArIGRpciwgZGlyLCAtMSk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLykpO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpLm5vZGU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxufVxuLy8vIEEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuLy8vIGFsbG93cyB5b3UgdG8gbW92ZSB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBmdWxsID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mdWxsID0gZnVsbDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBTaG9ydGhhbmQgZm9yIGAudHlwZS5uYW1lYC5cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgeWllbGROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl90cmVlID0gbm9kZTtcbiAgICAgICAgdGhpcy50eXBlID0gbm9kZS50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBub2RlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBub2RlLnRvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGRCdWYoaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgeyBzdGFydCwgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBidWZmZXIuc2V0LnR5cGVzW2J1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICAgICAgdGhpcy5mcm9tID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMV07XG4gICAgICAgIHRoaXMudG8gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAyXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpIDogdGhpcy5fdHJlZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW50ZXIoZGlyLCBhZnRlcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZGlyIDwgMCA/IHRoaXMuX3RyZWUubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBhZnRlciwgdGhpcy5mdWxsKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIGFmdGVyID09IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA/IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA6IGFmdGVyIC0gdGhpcy5idWZmZXIuc3RhcnQpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGluZGV4KTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZC4gV2hlbiB0aGlzIHJldHVybnNcbiAgICAvLy8gZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgIGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyKDEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlcigtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgc3RhcnRzIGF0IG9yIGFmdGVyIGBwb3NgLlxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyKDEsIHBvcyk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IGVuZHMgYXQgb3IgYmVmb3JlIGBwb3NgLlxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlcigtMSwgcG9zKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgIHBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZSh0aGlzLmZ1bGwgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5mdWxsID8gdGhpcy5idWZmZXIucGFyZW50IDogdGhpcy5idWZmZXIucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShwYXJlbnQpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIC0xMDAwMDAwMDAgLyogTm9uZSAqLywgdGhpcy5mdWxsKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8sIHRoaXMuZnVsbCkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIG5leHQgc2libGluZywgaWYgYW55LlxuICAgIG5leHRTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKDEpOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgIHByZXZTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKC0xKTsgfVxuICAgIGF0TGFzdE5vZGUoZGlyKSB7XG4gICAgICAgIGxldCBpbmRleCwgcGFyZW50LCB7IGJ1ZmZlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IGJ1ZmZlci5idWZmZXIuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnVmZmVyLmJ1ZmZlcltpICsgM10gPCB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHsgaW5kZXgsIHBhcmVudCB9ID0gYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHRoaXMuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBwYXJlbnQ7IHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gcGFyZW50KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyBkaXIsIGUgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQubm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQubm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mdWxsIHx8ICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbW92ZShkaXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZW50ZXIoZGlyLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgLy8vIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcl8oTkxSKSlcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHksIGl0cyBuZXh0IHNpYmxpbmcgb3IgdGhlIG5leHQgc2libGluZyBvZlxuICAgIC8vLyB0aGUgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBoYXMgb25lLlxuICAgIG5leHQoKSB7IHJldHVybiB0aGlzLm1vdmUoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpc3QgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldigpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBpbm5lcm1vc3Qgbm9kZSB0aGF0IGNvdmVycyBgcG9zYC4gSWZcbiAgICAvLy8gYHNpZGVgIGlzIC0xLCBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgZW5kIGF0IGBwb3NgLiBJZiBpdCBpcyAxLFxuICAgIC8vLyBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXG4gICAgbW92ZVRvKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxuICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUaGVuIHNjYW4gZG93biBpbnRvIGNoaWxkIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoc2lkZSA8IDAgPyAhdGhpcy5jaGlsZEJlZm9yZShwb3MpIDogIXRoaXMuY2hpbGRBZnRlcihwb3MpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCN0cmVlLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbdHJlZV0oI3RyZWUuVHJlZSkgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG5vZGUsIGlmXG4gICAgLy8vIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgICAvLy8gYnVmZmVyXSgjdHJlZS5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUubm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiAhY2gudHlwZS5pc0Fub255bW91cyB8fCBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmNsYXNzIEZsYXRCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIHRoaXMuaW5kZXg7IH1cbiAgICBuZXh0KCkgeyB0aGlzLmluZGV4IC09IDQ7IH1cbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XG59XG5jb25zdCBCYWxhbmNlQnJhbmNoRmFjdG9yID0gODtcbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgdG9wSUQgPSAwLCBtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoLCByZXVzZWQgPSBbXSwgbWluUmVwZWF0VHlwZSA9IG5vZGVTZXQudHlwZXMubGVuZ3RoIH0gPSBkYXRhO1xuICAgIGxldCBjdXJzb3IgPSBBcnJheS5pc0FycmF5KGJ1ZmZlcikgPyBuZXcgRmxhdEJ1ZmZlckN1cnNvcihidWZmZXIsIGJ1ZmZlci5sZW5ndGgpIDogYnVmZmVyO1xuICAgIGxldCB0eXBlcyA9IG5vZGVTZXQudHlwZXM7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgd2hpbGUgKGlkID09IGluUmVwZWF0KSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgKHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKHNpemUgPCAwKSB7IC8vIFJldXNlZCBub2RlXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHJldXNlZFtpZF0pO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2lkXSwgbm9kZSwgYnVmZmVyO1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPD0gbWF4QnVmZmVyTGVuZ3RoICYmIChidWZmZXIgPSBmaW5kQnVmZmVyU2l6ZShjdXJzb3IucG9zIC0gbWluUG9zLCBpblJlcGVhdCkpKSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBlbm91Z2ggZm9yIGEgYnVmZmVyLCBhbmQgbm8gcmV1c2VkIG5vZGVzIGluc2lkZVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIGJ1ZmZlci5zaXplLCBpbmRleCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCwgaW5SZXBlYXQpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCwgaW5SZXBlYXQgPCAwID8gTm9kZVR5cGUubm9uZSA6IHR5cGVzW2luUmVwZWF0XSk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoID4gQmFsYW5jZUJyYW5jaEZhY3RvcilcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgbWF4QnVmZmVyTGVuZ3RoLCBlbmQgLSBzdGFydCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBlbmQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplLCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCwgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKGlkID09IGluUmVwZWF0KVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAoc2l6ZSA+IDQpIHtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4LCBpblJlcGVhdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkIDwgbWluUmVwZWF0VHlwZSkgeyAvLyBEb24ndCBjb3B5IHJlcGVhdCBub2RlcyBpbnRvIGJ1ZmZlcnNcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBlbmQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEpO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1t0b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShvdXRlclR5cGUsIGlubmVyVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIHN0YXJ0LCBtYXhCdWZmZXJMZW5ndGgsIGxlbmd0aCkge1xuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgaWYgKGxlbmd0aCA8PSBtYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnNbaV0gLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBtYXhDaGlsZCA9IE1hdGgubWF4KG1heEJ1ZmZlckxlbmd0aCwgTWF0aC5jZWlsKGxlbmd0aCAqIDEuNSAvIEJhbGFuY2VCcmFuY2hGYWN0b3IpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRFbmQgPSBwb3NpdGlvbnNbaV0gKyBjaGlsZHJlbltpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRFbmQgLSBncm91cFN0YXJ0ID4gbWF4Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTtcbiAgICAgICAgICAgICAgICBpZiAob25seSBpbnN0YW5jZW9mIFRyZWUgJiYgb25seS50eXBlID09IGlubmVyVHlwZSAmJiBvbmx5Lmxlbmd0aCA+IG1heENoaWxkIDw8IDEpIHsgLy8gVG9vIGJpZywgY29sbGFwc2VcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvbmx5LmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2gob25seS5jaGlsZHJlbltqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKG9ubHkucG9zaXRpb25zW2pdICsgZ3JvdXBTdGFydCAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKG9ubHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2dyb3VwRnJvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gYmFsYW5jZVJhbmdlKGlubmVyVHlwZSwgaW5uZXJUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBncm91cEZyb20sIGksIGdyb3VwU3RhcnQsIG1heEJ1ZmZlckxlbmd0aCwgcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJUeXBlICE9IE5vZGVUeXBlLm5vbmUgJiYgIWNvbnRhaW5zVHlwZShpbm5lci5jaGlsZHJlbiwgaW5uZXJUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBpbm5lci5jaGlsZHJlbiwgaW5uZXIucG9zaXRpb25zLCBpbm5lci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChpbm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKGdyb3VwU3RhcnQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmVlKG91dGVyVHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxlbmd0aCk7XG59XG5mdW5jdGlvbiBjb250YWluc1R5cGUobm9kZXMsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBlbHQgb2Ygbm9kZXMpXG4gICAgICAgIGlmIChlbHQudHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8vIFRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbi8vLyBwYXJzaW5nXSgjbGV6ZXIuUGFyc2VPcHRpb25zLmZyYWdtZW50cykgdG8gdHJhY2sgcGFydHMgb2Ygb2xkXG4vLy8gdHJlZXMgdGhhdCBjYW4gYmUgcmV1c2VkIGluIGEgbmV3IHBhcnNlLiBBbiBhcnJheSBvZiBmcmFnbWVudHMgaXNcbi8vLyB1c2VkIHRvIHRyYWNrIHJlZ2lvbnMgb2YgYW4gb2xkIHRyZWUgd2hvc2Ugbm9kZXMgbWlnaHQgYmUgcmV1c2VkXG4vLy8gaW4gbmV3IHBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbi8vLyBbYGFwcGx5Q2hhbmdlc2BdKCN0cmVlLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0byB1cGRhdGVcbi8vLyBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgLy8vIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgIHRvLCBcbiAgICAvLy8gVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgIHRyZWUsIFxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICAvLy8gdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICAvLy8gZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgb2Zmc2V0LCBvcGVuKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBTdGFydCAqLykgPiAwOyB9XG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBFbmQgKi8pID4gMDsgfVxuICAgIC8vLyBBcHBseSBhIHNldCBvZiBlZGl0cyB0byBhbiBhcnJheSBvZiBmcmFnbWVudHMsIHJlbW92aW5nIG9yXG4gICAgLy8vIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICAvLy8gYWRqdXN0aW5nIG9mZnNldHMgZm9yIGZyYWdtZW50cyB0aGF0IG1vdmVkLlxuICAgIHN0YXRpYyBhcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBjaGFuZ2VzLCBtaW5HYXAgPSAxMjgpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGZJID0gMSwgbmV4dEYgPSBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgbGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRDID0gY0kgPCBjaGFuZ2VzLmxlbmd0aCA/IGNoYW5nZXNbY0krK10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIChjSSA+IDAgPyAxIC8qIFN0YXJ0ICovIDogMCkgfCAobmV4dEMgPyAyIC8qIEVuZCAqLyA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRGLnRvID4gbmV4dFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0RiA9IGZJIDwgZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1tmSSsrXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0QylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHRDLnRvQTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRDLnRvQSAtIG5leHRDLnRvQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgc2V0IG9mIGZyYWdtZW50cyBmcm9tIGEgZnJlc2hseSBwYXJzZWQgdHJlZSwgb3IgdXBkYXRlXG4gICAgLy8vIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIC8vLyB3aXRoIGEgdHJlZSB3aXRoIGNvbnRlbnQgZnJvbSB0aGUgbmV3IHRyZWUuIFdoZW4gYHBhcnRpYWxgIGlzXG4gICAgLy8vIHRydWUsIHRoZSBwYXJzZSBpcyB0cmVhdGVkIGFzIGluY29tcGxldGUsIGFuZCB0aGUgdG9rZW4gYXQgaXRzXG4gICAgLy8vIGVuZCBpcyBub3QgaW5jbHVkZWQgaW4gW2BzYWZlVG9gXSgjdHJlZS5UcmVlRnJhZ21lbnQuc2FmZVRvKS5cbiAgICBzdGF0aWMgYWRkVHJlZSh0cmVlLCBmcmFnbWVudHMgPSBbXSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbbmV3IFRyZWVGcmFnbWVudCgwLCB0cmVlLmxlbmd0aCwgdHJlZSwgMCwgcGFydGlhbCA/IDIgLyogRW5kICovIDogMCldO1xuICAgICAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cylcbiAgICAgICAgICAgIGlmIChmLnRvID4gdHJlZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8gQ3JlYXRlcyBhbiBgSW5wdXRgIHRoYXQgaXMgYmFja2VkIGJ5IGEgc2luZ2xlLCBmbGF0IHN0cmluZy5cbmZ1bmN0aW9uIHN0cmluZ0lucHV0KGlucHV0KSB7IHJldHVybiBuZXcgU3RyaW5nSW5wdXQoaW5wdXQpOyB9XG5jbGFzcyBTdHJpbmdJbnB1dCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgZ2V0KHBvcykge1xuICAgICAgICByZXR1cm4gcG9zIDwgMCB8fCBwb3MgPj0gdGhpcy5sZW5ndGggPyAtMSA6IHRoaXMuc3RyaW5nLmNoYXJDb2RlQXQocG9zKTtcbiAgICB9XG4gICAgbGluZUFmdGVyKHBvcykge1xuICAgICAgICBpZiAocG9zIDwgMClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihcIlxcblwiLCBwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBlbmQgPCAwID8gdGhpcy5sZW5ndGggOiBNYXRoLm1pbihlbmQsIHRoaXMubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykpOyB9XG4gICAgY2xpcChhdCkgeyByZXR1cm4gbmV3IFN0cmluZ0lucHV0KHRoaXMuc3RyaW5nLCBhdCk7IH1cbn1cblxuZXhwb3J0cy5EZWZhdWx0QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aDtcbmV4cG9ydHMuTm9kZVByb3AgPSBOb2RlUHJvcDtcbmV4cG9ydHMuTm9kZVNldCA9IE5vZGVTZXQ7XG5leHBvcnRzLk5vZGVUeXBlID0gTm9kZVR5cGU7XG5leHBvcnRzLlRyZWUgPSBUcmVlO1xuZXhwb3J0cy5UcmVlQnVmZmVyID0gVHJlZUJ1ZmZlcjtcbmV4cG9ydHMuVHJlZUN1cnNvciA9IFRyZWVDdXJzb3I7XG5leHBvcnRzLlRyZWVGcmFnbWVudCA9IFRyZWVGcmFnbWVudDtcbmV4cG9ydHMuc3RyaW5nSW5wdXQgPSBzdHJpbmdJbnB1dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyZWUuY2pzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbGV6ZXJUcmVlID0gcmVxdWlyZSgnbGV6ZXItdHJlZScpO1xuXG4vLy8gQSBwYXJzZSBzdGFjay4gVGhlc2UgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcGFyc2VyIHRvIHRyYWNrXG4vLy8gcGFyc2luZyBwcm9ncmVzcy4gVGhleSBhbHNvIHByb3ZpZGUgc29tZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG4vLy8gdGhhdCBleHRlcm5hbCBjb2RlIHN1Y2ggYXMgYSB0b2tlbml6ZXIgY2FuIHVzZSB0byBnZXQgaW5mb3JtYXRpb25cbi8vLyBhYm91dCB0aGUgcGFyc2Ugc3RhdGUuXG5jbGFzcyBTdGFjayB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBBIGdyb3VwIG9mIHZhbHVlcyB0aGF0IHRoZSBzdGFjayB3aWxsIHNoYXJlIHdpdGggYWxsXG4gICAgLy8vIHNwbGl0IGluc3RhbmNlc1xuICAgIC8vL0BpbnRlcm5hbFxuICAgIGN4LCBcbiAgICAvLy8gSG9sZHMgc3RhdGUsIHBvcywgdmFsdWUgc3RhY2sgcG9zICgxNSBiaXRzIGFycmF5IGluZGV4LCAxNSBiaXRzXG4gICAgLy8vIGJ1ZmZlciBpbmRleCkgdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlIHRvcCBzdGF0ZVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGFjaywgXG4gICAgLy8vIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2VQb3MsIFxuICAgIC8vLyBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgIHBvcywgXG4gICAgLy8vIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIC8vLyBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLy8gQSBwYXJlbnQgc3RhY2sgZnJvbSB3aGljaCB0aGlzIHdhcyBzcGxpdCBvZmYsIGlmIGFueS4gVGhpcyBpc1xuICAgIC8vIHNldCB1cCBzbyB0aGF0IGl0IGFsd2F5cyBwb2ludHMgdG8gYSBzdGFjayB0aGF0IGhhcyBzb21lXG4gICAgLy8gYWRkaXRpb25hbCBidWZmZXIgY29udGVudCwgbmV2ZXIgdG8gYSBzdGFjayB3aXRoIGFuIGVxdWFsXG4gICAgLy8gYGJ1ZmZlckJhc2VgLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5jeCA9IGN4O1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSByZWR1Y2VQb3M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJhc2UgPSBidWZmZXJCYXNlO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuc3RhY2suZmlsdGVyKChfLCBpKSA9PiBpICUgMyA9PSAwKS5jb25jYXQodGhpcy5zdGF0ZSl9XUAke3RoaXMucG9zfSR7dGhpcy5zY29yZSA/IFwiIVwiICsgdGhpcy5zY29yZSA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLy8gU3RhcnQgYW4gZW1wdHkgc3RhY2tcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGljIHN0YXJ0KGN4LCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKGN4LCBbXSwgc3RhdGUsIHBvcywgcG9zLCAwLCBbXSwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vIFB1c2ggYSBzdGF0ZSBvbnRvIHRoZSBzdGFjaywgdHJhY2tpbmcgaXRzIHN0YXJ0IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5jeDtcbiAgICAgICAgbGV0IGRQcmVjID0gcGFyc2VyLmR5bmFtaWNQcmVjZWRlbmNlKHR5cGUpO1xuICAgICAgICBpZiAoZFByZWMpXG4gICAgICAgICAgICB0aGlzLnNjb3JlICs9IGRQcmVjO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhdGUsIHR5cGUsIHRydWUpLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFja1tiYXNlIC0gMl07XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gdGhpcy5zdGFja1tiYXNlIC0gMV0sIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIFJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgdmFsdWUgaW50byB0aGUgYnVmZmVyXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0b3JlTm9kZSh0ZXJtLCBzdGFydCwgZW5kLCBzaXplID0gNCwgaXNSZWR1Y2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGVybSA9PSAwIC8qIEVyciAqLykgeyAvLyBUcnkgdG8gb21pdC9tZXJnZSBhZGphY2VudCBlcnJvciBub2Rlc1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMsIHRvcCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3AgPT0gMCAmJiBjdXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gY3VyLmJ1ZmZlckJhc2UgLSBjdXIucGFyZW50LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiAwICYmIGN1ci5idWZmZXJbdG9wIC0gNF0gPT0gMCAvKiBFcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZHVjZSB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoaXMgcmVjb3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGhpcy5idWZmZXJbaW5kZXggLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gdGhpcy5idWZmZXJbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiAxMzEwNzIgLyogR290b0ZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLywgdGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChhY3Rpb24gJiAyNjIxNDQgLyogU3RheUZsYWcgKi8pID09IDApIHsgLy8gUmVndWxhciBzaGlmdFxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3MsIG5leHRTdGF0ZSA9IGFjdGlvbiwgeyBwYXJzZXIgfSA9IHRoaXMuY3g7XG4gICAgICAgICAgICBpZiAobmV4dEVuZCA+IHRoaXMucG9zIHx8IG5leHQgPD0gcGFyc2VyLm1heE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuc3RhdGVGbGFnKG5leHRTdGF0ZSwgMSAvKiBTa2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICBpZiAobmV4dCA8PSB0aGlzLmN4LnBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXh0RW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGFuIGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBhcHBseShhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pXG4gICAgICAgICAgICB0aGlzLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCk7XG4gICAgfVxuICAgIC8vIEFkZCBhIHByZWJ1aWx0IG5vZGUgaW50byB0aGUgYnVmZmVyLiBUaGlzIG1heSBiZSBhIHJldXNlZCBub2RlIG9yXG4gICAgLy8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIGEgbmVzdGVkIHBhcnNlci5cbiAgICAvLy8gQGludGVybmFsXG4gICAgdXNlTm9kZSh2YWx1ZSwgbmV4dCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmN4LnJldXNlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMuY3gucmV1c2VkW2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jeC5yZXVzZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zID0gc3RhcnQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbmRleCwgc3RhcnQsIHRoaXMucmVkdWNlUG9zLCAtMSAvKiBzaXplIDwgMCBtZWFucyB0aGlzIGlzIGEgcmV1c2VkIHZhbHVlICovKTtcbiAgICB9XG4gICAgLy8gU3BsaXQgdGhlIHN0YWNrLiBEdWUgdG8gdGhlIGJ1ZmZlciBzaGFyaW5nIGFuZCB0aGUgZmFjdFxuICAgIC8vIHRoYXQgYHRoaXMuc3RhY2tgIHRlbmRzIHRvIHN0YXkgcXVpdGUgc2hhbGxvdywgdGhpcyBpc24ndCB2ZXJ5XG4gICAgLy8gZXhwZW5zaXZlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzcGxpdCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgIGxldCBvZmYgPSBwYXJlbnQuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgdG9wIG9mIHRoZSBidWZmZXIgKGFmdGVyIHRoaXMucG9zKSBtYXkgYmUgbXV0YXRlZFxuICAgICAgICAvLyB0byByZW9yZGVyIHJlZHVjdGlvbnMgYW5kIHNraXBwZWQgdG9rZW5zLCBhbmQgc2hhcmVkIGJ1ZmZlcnNcbiAgICAgICAgLy8gc2hvdWxkIGJlIGltbXV0YWJsZSwgdGhpcyBjb3BpZXMgYW55IG91dHN0YW5kaW5nIHNraXBwZWQgdG9rZW5zXG4gICAgICAgIC8vIHRvIHRoZSBuZXcgYnVmZmVyLCBhbmQgcHV0cyB0aGUgYmFzZSBwb2ludGVyIGJlZm9yZSB0aGVtLlxuICAgICAgICB3aGlsZSAob2ZmID4gMCAmJiBwYXJlbnQuYnVmZmVyW29mZiAtIDJdID4gcGFyZW50LnJlZHVjZVBvcylcbiAgICAgICAgICAgIG9mZiAtPSA0O1xuICAgICAgICBsZXQgYnVmZmVyID0gcGFyZW50LmJ1ZmZlci5zbGljZShvZmYpLCBiYXNlID0gcGFyZW50LmJ1ZmZlckJhc2UgKyBvZmY7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBwYXJlbnQgcG9pbnRzIHRvIGFuIGFjdHVhbCBwYXJlbnQgd2l0aCBjb250ZW50LCBpZiB0aGVyZSBpcyBzdWNoIGEgcGFyZW50LlxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIGJhc2UgPT0gcGFyZW50LmJ1ZmZlckJhc2UpXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHRoaXMuY3gsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5jeC5wYXJzZXIubWF4Tm9kZTtcbiAgICAgICAgaWYgKGlzTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKG5leHQsIHRoaXMucG9zLCBuZXh0RW5kKTtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHRoaXMucG9zLCBuZXh0RW5kLCBpc05vZGUgPyA4IDogNCk7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICB0aGlzLnNjb3JlIC09IDIwMCAvKiBUb2tlbiAqLztcbiAgICB9XG4gICAgLy8vIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIC8vLyBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICAvLy8gZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgICAvLy8gZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLmN4LnBhcnNlci5zdGF0ZVNsb3Qoc2ltLnRvcCwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSB8fCB0aGlzLmN4LnBhcnNlci5oYXNBY3Rpb24oc2ltLnRvcCwgdGVybSk7XG4gICAgICAgICAgICBpZiAoKGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgc2ltLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBGaW5kIHRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcnVsZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBwYXJzZWQuXG4gICAgZ2V0IHJ1bGVTdGFydCgpIHtcbiAgICAgICAgZm9yIChsZXQgc3RhdGUgPSB0aGlzLnN0YXRlLCBiYXNlID0gdGhpcy5zdGFjay5sZW5ndGg7Oykge1xuICAgICAgICAgICAgbGV0IGZvcmNlID0gdGhpcy5jeC5wYXJzZXIuc3RhdGVTbG90KHN0YXRlLCA1IC8qIEZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgICAgICBpZiAoIShmb3JjZSAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgYmFzZSAtPSAzICogKGZvcmNlID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8pO1xuICAgICAgICAgICAgaWYgKChmb3JjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLykgPCB0aGlzLmN4LnBhcnNlci5taW5SZXBlYXRUZXJtKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrW2Jhc2UgKyAxXTtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gRmluZCB0aGUgc3RhcnQgcG9zaXRpb24gb2YgYW4gaW5zdGFuY2Ugb2YgYW55IG9mIHRoZSBnaXZlbiB0ZXJtXG4gICAgLy8vIHR5cGVzLCBvciByZXR1cm4gYG51bGxgIHdoZW4gbm9uZSBvZiB0aGVtIGFyZSBmb3VuZC5cbiAgICAvLy9cbiAgICAvLy8gKipOb3RlOioqIHRoaXMgaXMgb25seSByZWxpYWJsZSB3aGVuIHRoZXJlIGlzIGF0IGxlYXN0IHNvbWVcbiAgICAvLy8gc3RhdGUgdGhhdCB1bmFtYmlndW91c2x5IG1hdGNoZXMgdGhlIGdpdmVuIHJ1bGUgb24gdGhlIHN0YWNrLlxuICAgIC8vLyBJLmUuIGlmIHlvdSBoYXZlIGEgZ3JhbW1hciBsaWtlIHRoaXMsIHdoZXJlIHRoZSBkaWZmZXJlbmNlXG4gICAgLy8vIGJldHdlZW4gYGFgIGFuZCBgYmAgaXMgb25seSBhcHBhcmVudCBhdCB0aGUgdGhpcmQgdG9rZW46XG4gICAgLy8vXG4gICAgLy8vICAgICBhIHsgYiB8IGMgfVxuICAgIC8vLyAgICAgYiB7IFwieFwiIFwieVwiIFwieFwiIH1cbiAgICAvLy8gICAgIGMgeyBcInhcIiBcInlcIiBcInpcIiB9XG4gICAgLy8vXG4gICAgLy8vIFRoZW4gYSBwYXJzZSBzdGF0ZSBhZnRlciBgXCJ4XCJgIHdpbGwgbm90IHJlbGlhYmx5IHRlbGwgeW91IHRoYXRcbiAgICAvLy8gYGJgIGlzIG9uIHRoZSBzdGFjay4gWW91IF9jYW5fIHBhc3MgYFtiLCBjXWAgdG8gcmVsaWFibHkgY2hlY2tcbiAgICAvLy8gZm9yIGVpdGhlciBvZiB0aG9zZSB0d28gcnVsZXMgKGFzc3VtaW5nIHRoYXQgYGFgIGlzbid0IHBhcnQgb2ZcbiAgICAvLy8gc29tZSBydWxlIHRoYXQgaW5jbHVkZXMgb3RoZXIgdGhpbmdzIHN0YXJ0aW5nIHdpdGggYFwieFwiYCkuXG4gICAgLy8vXG4gICAgLy8vIFdoZW4gYGJlZm9yZWAgaXMgZ2l2ZW4sIHRoaXMga2VlcHMgc2Nhbm5pbmcgdXAgdGhlIHN0YWNrIHVudGlsXG4gICAgLy8vIGl0IGZpbmRzIGEgbWF0Y2ggdGhhdCBzdGFydHMgYmVmb3JlIHRoYXQgcG9zaXRpb24uXG4gICAgc3RhcnRPZih0eXBlcywgYmVmb3JlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGUsIGZyYW1lID0gdGhpcy5zdGFjay5sZW5ndGgsIHsgcGFyc2VyIH0gPSB0aGlzLmN4O1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCA1IC8qIEZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSBmb3JjZSA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovLCB0ZXJtID0gZm9yY2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5kZXhPZih0ZXJtKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBmcmFtZSAtICgzICogKGZvcmNlID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8pKSwgcG9zID0gdGhpcy5zdGFja1tiYXNlICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA9PSBudWxsIHx8IGJlZm9yZSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFtZSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgICAgICBmcmFtZSAtPSAzO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGFja1tmcmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFtZSAtPSAzICogKGRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW2ZyYW1lIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IHVwIHRvIFJlY292ZXIuTWF4TmV4dCByZWNvdmVyeSBhY3Rpb25zIHRoYXQgY29uY2VwdHVhbGx5XG4gICAgLy8gaW5zZXJ0cyBzb21lIG1pc3NpbmcgdG9rZW4gb3IgcnVsZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5SW5zZXJ0KG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID49IDMwMCAvKiBNYXhJbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXRlcyA9IHRoaXMuY3gucGFyc2VyLm5leHRTdGF0ZXModGhpcy5zdGF0ZSk7XG4gICAgICAgIGlmIChuZXh0U3RhdGVzLmxlbmd0aCA+IDQgLyogTWF4TmV4dCAqLyB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBuZXh0U3RhdGVzLmZpbHRlcihzID0+IHMgIT0gdGhpcy5zdGF0ZSAmJiB0aGlzLmN4LnBhcnNlci5oYXNBY3Rpb24ocywgbmV4dCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMTIwIC8qIERhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGJlc3QubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovICYmIGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdC5pbmRleE9mKG5leHRTdGF0ZXNbaV0pIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldKTtcbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZXh0U3RhdGVzW2ldID09IHRoaXMuc3RhdGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICBzdGFjay5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHN0YWNrLnBvcywgc3RhY2sucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2hTdGF0ZShuZXh0U3RhdGVzW2ldLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zY29yZSAtPSAyMDAgLyogVG9rZW4gKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlUmVkdWNlKCkge1xuICAgICAgICBsZXQgcmVkdWNlID0gdGhpcy5jeC5wYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDUgLyogRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgaWYgKChyZWR1Y2UgJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuY3gucGFyc2VyLnZhbGlkQWN0aW9uKHRoaXMuc3RhdGUsIHJlZHVjZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY29yZSAtPSAxMDAgLyogUmVkdWNlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkdWNlKHJlZHVjZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VBbGwoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5jeC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogQWNjZXB0aW5nICovKSAmJiB0aGlzLmZvcmNlUmVkdWNlKCkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSwgc2luY2UgYW55IG90aGVyIHN0YXRlcyBtdXN0IGJlIGFibGUgdG8gY29udGludWVcbiAgICAvLy8gc29tZWhvdykuIEBpbnRlcm5hbFxuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLmN4O1xuICAgICAgICByZXR1cm4gcGFyc2VyLmRhdGFbcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pXSA9PSA2NTUzNSAvKiBFbmQgKi8gJiZcbiAgICAgICAgICAgICFwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgfVxuICAgIC8vLyBSZXN0YXJ0IHRoZSBzdGFjayAocHV0IGl0IGJhY2sgaW4gaXRzIHN0YXJ0IHN0YXRlKS4gT25seSBzYWZlXG4gICAgLy8vIHdoZW4gdGhpcy5zdGFjay5sZW5ndGggPT0gMyAoc3RhdGUgaXMgZGlyZWN0bHkgYmVsb3cgdGhlIHRvcFxuICAgIC8vLyBzdGF0ZSkuIEBpbnRlcm5hbFxuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrWzBdO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzYW1lU3RhdGUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gb3RoZXIuc3RhdGUgfHwgdGhpcy5zdGFjay5sZW5ndGggIT0gb3RoZXIuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja1tpXSAhPSBvdGhlci5zdGFja1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBwYXJzZXIgdXNlZCBieSB0aGlzIHN0YWNrLlxuICAgIGdldCBwYXJzZXIoKSB7IHJldHVybiB0aGlzLmN4LnBhcnNlcjsgfVxuICAgIC8vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBkaWFsZWN0IChieSBudW1lcmljIElELCBhcyBleHBvcnRlZCBmcm9tXG4gICAgLy8vIHRoZSB0ZXJtcyBmaWxlKSBpcyBlbmFibGVkLlxuICAgIGRpYWxlY3RFbmFibGVkKGRpYWxlY3RJRCkgeyByZXR1cm4gdGhpcy5jeC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG59XG52YXIgUmVjb3ZlcjtcbihmdW5jdGlvbiAoUmVjb3Zlcikge1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIlRva2VuXCJdID0gMjAwXSA9IFwiVG9rZW5cIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJSZWR1Y2VcIl0gPSAxMDBdID0gXCJSZWR1Y2VcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhOZXh0XCJdID0gNF0gPSBcIk1heE5leHRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhJbnNlcnRTdGFja0RlcHRoXCJdID0gMzAwXSA9IFwiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIl0gPSAxMjBdID0gXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCI7XG59KShSZWNvdmVyIHx8IChSZWNvdmVyID0ge30pKTtcbi8vIFVzZWQgdG8gY2hlYXBseSBydW4gc29tZSByZWR1Y3Rpb25zIHRvIHNjYW4gYWhlYWQgd2l0aG91dCBtdXRhdGluZ1xuLy8gYW4gZW50aXJlIHN0YWNrXG5jbGFzcyBTaW11bGF0ZWRTdGFjayB7XG4gICAgY29uc3RydWN0b3Ioc3RhY2spIHtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnRvcCA9IHN0YWNrLnN0YXRlO1xuICAgICAgICB0aGlzLnJlc3QgPSBzdGFjay5zdGFjaztcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLnJlc3QubGVuZ3RoO1xuICAgIH1cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovLCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdCA9PSB0aGlzLnN0YWNrLnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMucmVzdCA9IHRoaXMucmVzdC5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXN0LnB1c2godGhpcy50b3AsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0IC09IChkZXB0aCAtIDEpICogMztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ290byA9IHRoaXMuc3RhY2suY3gucGFyc2VyLmdldEdvdG8odGhpcy5yZXN0W3RoaXMub2Zmc2V0IC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnRvcCA9IGdvdG87XG4gICAgfVxufVxuLy8gVGhpcyBpcyBnaXZlbiB0byBgVHJlZS5idWlsZGAgdG8gYnVpbGQgYSBidWZmZXIsIGFuZCBlbmNhcHN1bGF0ZXNcbi8vIHRoZSBwYXJlbnQtc3RhY2std2Fsa2luZyBuZWNlc3NhcnkgdG8gcmVhZCB0aGUgbm9kZXMuXG5jbGFzcyBTdGFja0J1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhY2ssIHBvcywgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHN0YWNrLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgsIHN0YWNrLmJ1ZmZlci5sZW5ndGgpO1xuICAgIH1cbiAgICBtYXliZU5leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdGFjay5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBuZXh0LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV4dDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV4dC5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSA0O1xuICAgICAgICB0aGlzLnBvcyAtPSA0O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgZm9yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcih0aGlzLnN0YWNrLCB0aGlzLnBvcywgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuXG4vLy8gVG9rZW5pemVycyB3cml0ZSB0aGUgdG9rZW5zIHRoZXkgcmVhZCBpbnRvIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLlxuY2xhc3MgVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLy8gVGhlIHN0YXJ0IG9mIHRoZSB0b2tlbi4gVGhpcyBpcyBzZXQgYnkgdGhlIHBhcnNlciwgYW5kIHNob3VsZCBub3RcbiAgICAgICAgLy8vIGJlIG11dGF0ZWQgYnkgdGhlIHRva2VuaXplci5cbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICAvLy8gVGhpcyBzdGFydHMgYXQgLTEsIGFuZCBzaG91bGQgYmUgdXBkYXRlZCB0byBhIHRlcm0gaWQgd2hlbiBhXG4gICAgICAgIC8vLyBtYXRjaGluZyB0b2tlbiBpcyBmb3VuZC5cbiAgICAgICAgdGhpcy52YWx1ZSA9IC0xO1xuICAgICAgICAvLy8gV2hlbiBzZXR0aW5nIGAudmFsdWVgLCB5b3Ugc2hvdWxkIGFsc28gc2V0IGAuZW5kYCB0byB0aGUgZW5kXG4gICAgICAgIC8vLyBwb3NpdGlvbiBvZiB0aGUgdG9rZW4uIChZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZSB0aGUgYGFjY2VwdGBcbiAgICAgICAgLy8vIG1ldGhvZC4pXG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgfVxuICAgIC8vLyBBY2NlcHQgYSB0b2tlbiwgc2V0dGluZyBgdmFsdWVgIGFuZCBgZW5kYCB0byB0aGUgZ2l2ZW4gdmFsdWVzLlxuICAgIGFjY2VwdCh2YWx1ZSwgZW5kKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxufVxuLy8vIEBpbnRlcm5hbFxuY2xhc3MgVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgdG9rZW4sIHN0YWNrKSB7IHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCB0b2tlbiwgc3RhY2ssIHRoaXMuaWQpOyB9XG59XG5Ub2tlbkdyb3VwLnByb3RvdHlwZS5jb250ZXh0dWFsID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZmFsbGJhY2sgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5leHRlbmQgPSBmYWxzZTtcbi8vLyBFeHBvcnRzIHRoYXQgYXJlIHVzZWQgZm9yIGBAZXh0ZXJuYWwgdG9rZW5zYCBpbiB0aGUgZ3JhbW1hciBzaG91bGRcbi8vLyBleHBvcnQgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbmNsYXNzIEV4dGVybmFsVG9rZW5pemVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdG9rZW5pemVyLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGZ1bmN0aW9uIHRoYXQsXG4gICAgLy8vIGdpdmVuIGFuIGlucHV0IHN0cmVhbSBhbmQgYSB0b2tlbiBvYmplY3QsXG4gICAgLy8vIFtmaWxsc10oI2xlemVyLlRva2VuLmFjY2VwdCkgdGhlIHRva2VuIG9iamVjdCBpZiBpdCByZWNvZ25pemVzIGFcbiAgICAvLy8gdG9rZW4uIGB0b2tlbi5zdGFydGAgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvXG4gICAgLy8vIHNjYW4gZnJvbS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9rZW4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuY29udGV4dHVhbCA9ICEhb3B0aW9ucy5jb250ZXh0dWFsO1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gISFvcHRpb25zLmZhbGxiYWNrO1xuICAgICAgICB0aGlzLmV4dGVuZCA9ICEhb3B0aW9ucy5leHRlbmQ7XG4gICAgfVxufVxuLy8gVG9rZW5pemVyIGRhdGEgaXMgc3RvcmVkIGEgYmlnIHVpbnQxNiBhcnJheSBjb250YWluaW5nLCBmb3IgZWFjaFxuLy8gc3RhdGU6XG4vL1xuLy8gIC0gQSBncm91cCBiaXRtYXNrLCBpbmRpY2F0aW5nIHdoYXQgdG9rZW4gZ3JvdXBzIGFyZSByZWFjaGFibGUgZnJvbVxuLy8gICAgdGhpcyBzdGF0ZSwgc28gdGhhdCBwYXRocyB0aGF0IGNhbiBvbmx5IGxlYWQgdG8gdG9rZW5zIG5vdCBpblxuLy8gICAgYW55IG9mIHRoZSBjdXJyZW50IGdyb3VwcyBjYW4gYmUgY3V0IG9mZiBlYXJseS5cbi8vXG4vLyAgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiB0aGUgc3RhdGUncyBzZXF1ZW5jZSBvZiBhY2NlcHRpbmdcbi8vICAgIHRva2Vuc1xuLy9cbi8vICAtIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgZm9yIHRoZSBzdGF0ZVxuLy9cbi8vICAtIFRoZSBhY2NlcHRpbmcgdG9rZW5zLCBhcyAodG9rZW4gaWQsIGdyb3VwIG1hc2spIHBhaXJzXG4vL1xuLy8gIC0gVGhlIG91dGdvaW5nIGVkZ2VzLCBhcyAoc3RhcnQgY2hhcmFjdGVyLCBlbmQgY2hhcmFjdGVyLCBzdGF0ZVxuLy8gICAgaW5kZXgpIHRyaXBsZXMsIHdpdGggZW5kIGNoYXJhY3RlciBiZWluZyBleGNsdXNpdmVcbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGludGVycHJldHMgdGhhdCBkYXRhLCBydW5uaW5nIHRocm91Z2ggYSBzdHJlYW0gYXNcbi8vIGxvbmcgYXMgbmV3IHN0YXRlcyB3aXRoIHRoZSBhIG1hdGNoaW5nIGdyb3VwIG1hc2sgY2FuIGJlIHJlYWNoZWQsXG4vLyBhbmQgdXBkYXRpbmcgYHRva2VuYCB3aGVuIGl0IG1hdGNoZXMgYSB0b2tlbi5cbmZ1bmN0aW9uIHJlYWRUb2tlbihkYXRhLCBpbnB1dCwgdG9rZW4sIHN0YWNrLCBncm91cCkge1xuICAgIGxldCBzdGF0ZSA9IDAsIGdyb3VwTWFzayA9IDEgPDwgZ3JvdXAsIGRpYWxlY3QgPSBzdGFjay5jeC5wYXJzZXIuZGlhbGVjdDtcbiAgICBzY2FuOiBmb3IgKGxldCBwb3MgPSB0b2tlbi5zdGFydDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAodG9rZW4udmFsdWUgPT0gLTEgfHwgdG9rZW4udmFsdWUgPT0gdGVybSB8fCBzdGFjay5jeC5wYXJzZXIub3ZlcnJpZGVzKHRlcm0sIHRva2VuLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uYWNjZXB0KHRlcm0sIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5nZXQocG9zKyspO1xuICAgICAgICAvLyBEbyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHN0YXRlJ3MgZWRnZXNcbiAgICAgICAgZm9yIChsZXQgbG93ID0gMCwgaGlnaCA9IGRhdGFbc3RhdGUgKyAyXTsgbG93IDwgaGlnaDspIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGFjY0VuZCArIG1pZCArIChtaWQgPDwgMSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRhdGFbaW5kZXhdLCB0byA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA+PSB0bylcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2luZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLy8gRklYTUUgZmluZCBzb21lIHdheSB0byByZWR1Y2UgcmVjb3Zlcnkgd29yayBkb25lIHdoZW4gdGhlIGlucHV0XG4vLyBkb2Vzbid0IG1hdGNoIHRoZSBncmFtbWFyIGF0IGFsbC5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBjb25zb2xlIG91dHB1dFxuY29uc3QgdmVyYm9zZSA9IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgL1xcYnBhcnNlXFxiLy50ZXN0KHByb2Nlc3MuZW52LkxPRyk7XG5sZXQgc3RhY2tJRHMgPSBudWxsO1xuZnVuY3Rpb24gY3V0QXQodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGN1cnNvciA9IHRyZWUuY3Vyc29yKHBvcyk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIShzaWRlIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZShwb3MpIDogY3Vyc29yLmNoaWxkQWZ0ZXIocG9zKSkpXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlIDwgMCA/IGN1cnNvci50byA8PSBwb3MgOiBjdXJzb3IuZnJvbSA+PSBwb3MpICYmICFjdXJzb3IudHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyBjdXJzb3IudG8gLSAxIDogY3Vyc29yLmZyb20gKyAxO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gcG9zICYmIHN0YXJ0ICsgbmV4dC5sZW5ndGggPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgPT0gcG9zICYmIHN0YXJ0ID49IHRoaXMuc2FmZUZyb20gPyBuZXh0IDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgbGV6ZXJUcmVlLlRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IHBvcykgeyAvLyBFbnRlciB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ2FjaGVkVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICB9XG4gICAgY2xlYXIoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgIH1cbn1cbmNvbnN0IGR1bW15VG9rZW4gPSBuZXcgVG9rZW47XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBkdW1teVRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrLCBpbnB1dCkge1xuICAgICAgICBsZXQgYWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2suY3gsIHsgdG9rZW5pemVycyB9ID0gcGFyc2VyO1xuICAgICAgICBsZXQgbWFzayA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDMgLyogVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoMSA8PCBpKSAmIG1hc2spID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdG9rZW5pemVyID0gdG9rZW5pemVyc1tpXSwgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChtYWluICYmICF0b2tlbml6ZXIuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmNvbnRleHR1YWwgfHwgdG9rZW4uc3RhcnQgIT0gc3RhY2sucG9zIHx8IHRva2VuLm1hc2sgIT0gbWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2ssIGlucHV0KTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSAhPSAwIC8qIEVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmICghbWFpbikge1xuICAgICAgICAgICAgbWFpbiA9IGR1bW15VG9rZW47XG4gICAgICAgICAgICBtYWluLnN0YXJ0ID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA9PSBpbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFpbi5hY2NlcHQoc3RhY2suY3gucGFyc2VyLmVvZlRlcm0sIHN0YWNrLnBvcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWFpbi5hY2NlcHQoMCAvKiBFcnIgKi8sIHN0YWNrLnBvcyArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2ssIGlucHV0KSB7XG4gICAgICAgIHRva2VuLmNsZWFyKHN0YWNrLnBvcyk7XG4gICAgICAgIHRva2VuaXplci50b2tlbihpbnB1dCwgdG9rZW4sIHN0YWNrKTtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2suY3g7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKGlucHV0LnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLmN4LnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uZXh0ZW5kZWQgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YWNrLnBvcyA9PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuLmFjY2VwdChzdGFjay5jeC5wYXJzZXIuZW9mVGVybSwgc3RhY2sucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLmFjY2VwdCgwIC8qIEVyciAqLywgc3RhY2sucG9zICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLmN4LCB7IGRhdGEgfSA9IHBhcnNlcjtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFNraXAgKi8gOiAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAwICYmIGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAxKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxudmFyIFJlYztcbihmdW5jdGlvbiAoUmVjKSB7XG4gICAgUmVjW1JlY1tcIkRpc3RhbmNlXCJdID0gNV0gPSBcIkRpc3RhbmNlXCI7XG4gICAgUmVjW1JlY1tcIk1heFJlbWFpbmluZ1BlclN0ZXBcIl0gPSAzXSA9IFwiTWF4UmVtYWluaW5nUGVyU3RlcFwiO1xuICAgIFJlY1tSZWNbXCJNaW5CdWZmZXJMZW5ndGhQcnVuZVwiXSA9IDIwMF0gPSBcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCI7XG4gICAgUmVjW1JlY1tcIkZvcmNlUmVkdWNlTGltaXRcIl0gPSAxMF0gPSBcIkZvcmNlUmVkdWNlTGltaXRcIjtcbn0pKFJlYyB8fCAoUmVjID0ge30pKTtcbi8vLyBBIHBhcnNlIGNvbnRleHQgY2FuIGJlIHVzZWQgZm9yIHN0ZXAtYnktc3RlcCBwYXJzaW5nLiBBZnRlclxuLy8vIGNyZWF0aW5nIGl0LCB5b3UgcmVwZWF0ZWRseSBjYWxsIGAuYWR2YW5jZSgpYCB1bnRpbCBpdCByZXR1cm5zIGFcbi8vLyB0cmVlIHRvIGluZGljYXRlIGl0IGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHBhcnNlLlxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIHN0YXJ0UG9zLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuc3RhcnRQb3MgPSBzdGFydFBvcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgLy8gVGhlIHBvc2l0aW9uIHRvIHdoaWNoIHRoZSBwYXJzZSBoYXMgYWR2YW5jZWQuXG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gMDtcbiAgICAgICAgdGhpcy5uZXh0U3RhY2tJRCA9IDB4MjY1NDtcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSBudWxsO1xuICAgICAgICB0aGlzLm5lc3RFbmQgPSAwO1xuICAgICAgICB0aGlzLm5lc3RXcmFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBuZXcgVG9rZW5DYWNoZShwYXJzZXIpO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICB0aGlzLnN0YWNrcyA9IFtTdGFjay5zdGFydCh0aGlzLCBwYXJzZXIudG9wWzBdLCB0aGlzLnN0YXJ0UG9zKV07XG4gICAgICAgIGxldCBmcmFnbWVudHMgPSBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cyAmJiBmcmFnbWVudHMubGVuZ3RoID8gbmV3IEZyYWdtZW50Q3Vyc29yKGZyYWdtZW50cykgOiBudWxsO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRoZSBwYXJzZXIgZm9yd2FyZC4gVGhpcyB3aWxsIHByb2Nlc3MgYWxsIHBhcnNlIHN0YWNrcyBhdFxuICAgIC8vIGB0aGlzLnBvc2AgYW5kIHRyeSB0byBhZHZhbmNlIHRoZW0gdG8gYSBmdXJ0aGVyIHBvc2l0aW9uLiBJZiBub1xuICAgIC8vIHN0YWNrIGZvciBzdWNoIGEgcG9zaXRpb24gaXMgZm91bmQsIGl0J2xsIHN0YXJ0IGVycm9yLXJlY292ZXJ5LlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgcGFyc2UgaXMgZmluaXNoZWQsIHRoaXMgd2lsbCByZXR1cm4gYSBzeW50YXggdHJlZS4gV2hlblxuICAgIC8vIG5vdCwgaXQgcmV0dXJucyBgbnVsbGAuXG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmVzdGVkKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5uZXN0ZWQuYWR2YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLm5lc3RlZC5wb3M7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hOZXN0ZWQodGhpcy5zdGFja3NbMF0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3RhY2tzLCBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICBsZXQgbWF5YmVOZXN0O1xuICAgICAgICAvLyBLZWVwIGFkdmFuY2luZyBhbnkgc3RhY2tzIGF0IGBwb3NgIHVudGlsIHRoZXkgZWl0aGVyIG1vdmVcbiAgICAgICAgLy8gZm9yd2FyZCBvciBjYW4ndCBiZSBhZHZhbmNlZC4gR2F0aGVyIHN0YWNrcyB0aGF0IGNhbid0IGJlXG4gICAgICAgIC8vIGFkdmFuY2VkIGZ1cnRoZXIgaW4gYHN0b3BwZWRgLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCBuZXN0O1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXN0ID0gdGhpcy5jaGVja05lc3Qoc3RhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF5YmVOZXN0IHx8IG1heWJlTmVzdC5zdGFjay5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVOZXN0ID0gbmVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG5ld1N0YWNrcywgc3RhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2sgPSB0aGlzLnRva2Vucy5tYWluVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmVOZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmVzdGVkKG1heWJlTmVzdCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSAmJiBzdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0dWNrIHdpdGggdG9rZW4gXCIgKyB0aGlzLnBhcnNlci5nZXROYW1lKHRoaXMudG9rZW5zLm1haW5Ub2tlbi52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vIHBhcnNlIGF0IFwiICsgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvdmVyaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDUgLyogRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQuZm9yY2VBbGwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZykge1xuICAgICAgICAgICAgbGV0IG1heFJlbWFpbmluZyA9IHRoaXMucmVjb3ZlcmluZyA9PSAxID8gMSA6IHRoaXMucmVjb3ZlcmluZyAqIDMgLyogTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDIwMCAvKiBNaW5CdWZmZXJMZW5ndGhQcnVuZSAqLyAmJiBvdGhlci5idWZmZXIubGVuZ3RoID4gMjAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChzdGFjay5zY29yZSAtIG90aGVyLnNjb3JlKSB8fCAoc3RhY2suYnVmZmVyLmxlbmd0aCAtIG90aGVyLmJ1ZmZlci5sZW5ndGgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSBuZXdTdGFja3NbMF0ucG9zO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0ucG9zIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IGlucHV0LCBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50cykge1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBsZXplclRyZWUuVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgbGV6ZXJUcmVlLlRyZWUpXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoZGVmYXVsdFJlZHVjZSA+IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZShkZWZhdWx0UmVkdWNlKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIGFsd2F5cy1yZWR1Y2UgJHtwYXJzZXIuZ2V0TmFtZShkZWZhdWx0UmVkdWNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2ssIGlucHV0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsb2NhbFN0YWNrLmFwcGx5KGFjdGlvbiwgdGVybSwgZW5kKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQobG9jYWxTdGFjaykgKyBgICh2aWEgJHsoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMCA/IFwic2hpZnRcIlxuICAgICAgICAgICAgICAgICAgICA6IGByZWR1Y2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pfWB9IGZvciAke3BhcnNlci5nZXROYW1lKHRlcm0pfSBAICR7c3RhcnR9JHtsb2NhbFN0YWNrID09IHN0YWNrID8gXCJcIiA6IFwiLCBzcGxpdFwifSlgKTtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxTdGFjay5wb3MgPiBzdGFydClcbiAgICAgICAgICAgICAgICBzdGFja3MucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzcGxpdC5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWR2YW5jZSBhIGdpdmVuIHN0YWNrIGZvcndhcmQgYXMgZmFyIGFzIGl0IHdpbGwgZ28uIFJldHVybnMgdGhlXG4gICAgLy8gKHBvc3NpYmx5IHVwZGF0ZWQpIHN0YWNrIGlmIGl0IGdvdCBzdHVjaywgb3IgbnVsbCBpZiBpdCBtb3ZlZFxuICAgIC8vIGZvcndhcmQgYW5kIHdhcyBnaXZlbiB0byBgcHVzaFN0YWNrRGVkdXBgLlxuICAgIGFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBwb3MgPSBzdGFjay5wb3M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXN0ID0gdGhpcy5jaGVja05lc3Qoc3RhY2spO1xuICAgICAgICAgICAgaWYgKG5lc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBudWxsLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuUmVjb3Zlcnkoc3RhY2tzLCB0b2tlbnMsIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBudWxsLCByZXN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG1heWJlTmVzdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgdG9rZW4gPSB0b2tlbnNbaSA8PCAxXSwgdG9rZW5FbmQgPSB0b2tlbnNbKGkgPDwgMSkgKyAxXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoc3RhY2suZGVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIChyZXN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5lc3QgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBzdGFjay5zcGxpdCgpLCBmb3JjZUJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGZvcmNlLmZvcmNlUmVkdWNlKCkgJiYgaiA8IDEwIC8qIEZvcmNlUmVkdWNlTGltaXQgKi87IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmb3JjZUJhc2UgKyB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgKHZpYSBmb3JjZS1yZWR1Y2UpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoZm9yY2UsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5lc3QgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0Lmxlbmd0aCA+IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkVuZCA9PSBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAwIC8qIEVyciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucmVjb3ZlckJ5RGVsZXRlKHRva2VuLCB0b2tlbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJlY292ZXItZGVsZXRlICR7dGhpcy5wYXJzZXIuZ2V0TmFtZSh0b2tlbil9KWApO1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmlzaGVkIHx8IGZpbmlzaGVkLnNjb3JlIDwgc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICAgICAgaWYgKG1heWJlTmVzdClcbiAgICAgICAgICAgIGZvciAobGV0IHMgb2YgdGhpcy5zdGFja3MpXG4gICAgICAgICAgICAgICAgaWYgKHMuc2NvcmUgPiBtYXliZU5lc3Quc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVOZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZU5lc3QpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmVzdGVkKG1heWJlTmVzdCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3JjZUZpbmlzaCgpIHtcbiAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zdGFja3NbMF0uc3BsaXQoKTtcbiAgICAgICAgaWYgKHRoaXMubmVzdGVkKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hOZXN0ZWQoc3RhY2ssIHRoaXMubmVzdGVkLmZvcmNlRmluaXNoKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShzdGFjay5mb3JjZUFsbCgpKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgc3RhY2sncyBidWZmZXIgdG8gYSBzeW50YXggdHJlZS5cbiAgICBzdGFja1RvVHJlZShzdGFjaywgcG9zID0gc3RhY2sucG9zKSB7XG4gICAgICAgIHJldHVybiBsZXplclRyZWUuVHJlZS5idWlsZCh7IGJ1ZmZlcjogU3RhY2tCdWZmZXJDdXJzb3IuY3JlYXRlKHN0YWNrKSxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRQb3MsXG4gICAgICAgICAgICBsZW5ndGg6IHBvcyAtIHRoaXMuc3RhcnRQb3MsXG4gICAgICAgICAgICBtaW5SZXBlYXRUeXBlOiB0aGlzLnBhcnNlci5taW5SZXBlYXRUZXJtIH0pO1xuICAgIH1cbiAgICBjaGVja05lc3Qoc3RhY2spIHtcbiAgICAgICAgbGV0IGluZm8gPSB0aGlzLnBhcnNlci5maW5kTmVzdGVkKHN0YWNrLnN0YXRlKTtcbiAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzcGVjID0gaW5mby52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHNwZWMgPSBzcGVjKHRoaXMuaW5wdXQsIHN0YWNrKTtcbiAgICAgICAgcmV0dXJuIHNwZWMgPyB7IHN0YWNrLCBpbmZvLCBzcGVjIH0gOiBudWxsO1xuICAgIH1cbiAgICBzdGFydE5lc3RlZChuZXN0KSB7XG4gICAgICAgIGxldCB7IHN0YWNrLCBpbmZvLCBzcGVjIH0gPSBuZXN0O1xuICAgICAgICB0aGlzLnN0YWNrcyA9IFtzdGFja107XG4gICAgICAgIHRoaXMubmVzdEVuZCA9IHRoaXMuc2NhbkZvck5lc3RFbmQoc3RhY2ssIGluZm8uZW5kLCBzcGVjLmZpbHRlckVuZCk7XG4gICAgICAgIHRoaXMubmVzdFdyYXAgPSB0eXBlb2Ygc3BlYy53cmFwVHlwZSA9PSBcIm51bWJlclwiID8gdGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1tzcGVjLndyYXBUeXBlXSA6IHNwZWMud3JhcFR5cGUgfHwgbnVsbDtcbiAgICAgICAgaWYgKHNwZWMuc3RhcnRQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5uZXN0ZWQgPSBzcGVjLnN0YXJ0UGFyc2UodGhpcy5pbnB1dC5jbGlwKHRoaXMubmVzdEVuZCksIHN0YWNrLnBvcywgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTmVzdGVkKHN0YWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuRm9yTmVzdEVuZChzdGFjaywgZW5kVG9rZW4sIGZpbHRlcikge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBzdGFjay5wb3M7IHBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICAgICAgZHVtbXlUb2tlbi5zdGFydCA9IHBvcztcbiAgICAgICAgICAgIGR1bW15VG9rZW4udmFsdWUgPSAtMTtcbiAgICAgICAgICAgIGVuZFRva2VuLnRva2VuKHRoaXMuaW5wdXQsIGR1bW15VG9rZW4sIHN0YWNrKTtcbiAgICAgICAgICAgIGlmIChkdW1teVRva2VuLnZhbHVlID4gLTEgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHRoaXMuaW5wdXQucmVhZChwb3MsIGR1bW15VG9rZW4uZW5kKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5pc2hOZXN0ZWQoc3RhY2ssIHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMubmVzdFdyYXApXG4gICAgICAgICAgICB0cmVlID0gbmV3IGxlemVyVHJlZS5UcmVlKHRoaXMubmVzdFdyYXAsIHRyZWUgPyBbdHJlZV0gOiBbXSwgdHJlZSA/IFswXSA6IFtdLCB0aGlzLm5lc3RFbmQgLSBzdGFjay5wb3MpO1xuICAgICAgICBlbHNlIGlmICghdHJlZSlcbiAgICAgICAgICAgIHRyZWUgPSBuZXcgbGV6ZXJUcmVlLlRyZWUobGV6ZXJUcmVlLk5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgdGhpcy5uZXN0RW5kIC0gc3RhY2sucG9zKTtcbiAgICAgICAgbGV0IGluZm8gPSB0aGlzLnBhcnNlci5maW5kTmVzdGVkKHN0YWNrLnN0YXRlKTtcbiAgICAgICAgc3RhY2sudXNlTm9kZSh0cmVlLCB0aGlzLnBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBpbmZvLnBsYWNlaG9sZGVyLCB0cnVlKSk7XG4gICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSB1bm5lc3QpYCk7XG4gICAgfVxuICAgIHN0YWNrSUQoc3RhY2spIHtcbiAgICAgICAgbGV0IGlkID0gKHN0YWNrSURzIHx8IChzdGFja0lEcyA9IG5ldyBXZWFrTWFwKSkuZ2V0KHN0YWNrKTtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHN0YWNrSURzLnNldChzdGFjaywgaWQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLm5leHRTdGFja0lEKyspKTtcbiAgICAgICAgcmV0dXJuIGlkICsgc3RhY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA9PSBzdGFjay5wb3MgJiYgb3RoZXIuc2FtZVN0YXRlKHN0YWNrKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgIG5ld1N0YWNrc1tpXSA9IHN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbn1cbmNsYXNzIERpYWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZmxhZ3MsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgYWxsb3dzKHRlcm0pIHsgcmV0dXJuICF0aGlzLmRpc2FibGVkIHx8IHRoaXMuZGlzYWJsZWRbdGVybV0gPT0gMDsgfVxufVxuLy8vIEEgcGFyc2VyIGhvbGRzIHRoZSBwYXJzZSB0YWJsZXMgZm9yIGEgZ2l2ZW4gZ3JhbW1hciwgYXMgZ2VuZXJhdGVkXG4vLy8gYnkgYGxlemVyLWdlbmVyYXRvcmAuXG5jbGFzcyBQYXJzZXIge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSBsZXplclRyZWUuRGVmYXVsdEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5leHRTdGF0ZUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuY2FjaGVkRGlhbGVjdCA9IG51bGw7XG4gICAgICAgIGlmIChzcGVjLnZlcnNpb24gIT0gMTMgLyogVmVyc2lvbiAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQYXJzZXIgdmVyc2lvbiAoJHtzcGVjLnZlcnNpb259KSBkb2Vzbid0IG1hdGNoIHJ1bnRpbWUgdmVyc2lvbiAoJHsxMyAvKiBWZXJzaW9uICovfSlgKTtcbiAgICAgICAgbGV0IHRva2VuQXJyYXkgPSBkZWNvZGVBcnJheShzcGVjLnRva2VuRGF0YSk7XG4gICAgICAgIGxldCBub2RlTmFtZXMgPSBzcGVjLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICAgIHRoaXMubWluUmVwZWF0VGVybSA9IG5vZGVOYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5yZXBlYXROb2RlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIG5vZGVOYW1lcy5wdXNoKFwiXCIpO1xuICAgICAgICBsZXQgbm9kZVByb3BzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZU5hbWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZVByb3BzLnB1c2goW10pO1xuICAgICAgICBmdW5jdGlvbiBzZXRQcm9wKG5vZGVJRCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIG5vZGVQcm9wc1tub2RlSURdLnB1c2goW3Byb3AsIHByb3AuZGVzZXJpYWxpemUoU3RyaW5nKHZhbHVlKSldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYy5ub2RlUHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wU3BlYyBvZiBzcGVjLm5vZGVQcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcHJvcFNwZWNbMF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wU3BlYy5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcHJvcFNwZWNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChuZXh0LCBwcm9wLCBwcm9wU3BlY1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3BTcGVjW2kgKyAtbmV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLW5leHQ7IGogPiAwOyBqLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChwcm9wU3BlY1tpKytdLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkoc3BlYy5zcGVjaWFsaXplZCA/IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoIDogMCk7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnNwZWNpYWxpemVkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0udGVybTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVyc1tpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0uZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgbGV0IHRvcFRlcm1zID0gT2JqZWN0LmtleXMoc3BlYy50b3BSdWxlcykubWFwKHIgPT4gc3BlYy50b3BSdWxlc1tyXVsxXSk7XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5ldyBsZXplclRyZWUuTm9kZVNldChub2RlTmFtZXMubWFwKChuYW1lLCBpKSA9PiBsZXplclRyZWUuTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICB0aGlzLm1heFRlcm0gPSBzcGVjLm1heFRlcm07XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IHNwZWMudG9rZW5pemVycy5tYXAodmFsdWUgPT4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyBuZXcgVG9rZW5Hcm91cCh0b2tlbkFycmF5LCB2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgIHRoaXMudG9wUnVsZXMgPSBzcGVjLnRvcFJ1bGVzO1xuICAgICAgICB0aGlzLm5lc3RlZCA9IChzcGVjLm5lc3RlZCB8fCBbXSkubWFwKChbbmFtZSwgdmFsdWUsIGVuZFRva2VuLCBwbGFjZWhvbGRlcl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlLCBlbmQ6IG5ldyBUb2tlbkdyb3VwKGRlY29kZUFycmF5KGVuZFRva2VuKSwgMCksIHBsYWNlaG9sZGVyIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpYWxlY3RzID0gc3BlYy5kaWFsZWN0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljUHJlY2VkZW5jZXMgPSBzcGVjLmR5bmFtaWNQcmVjZWRlbmNlcyB8fCBudWxsO1xuICAgICAgICB0aGlzLnRva2VuUHJlY1RhYmxlID0gc3BlYy50b2tlblByZWM7XG4gICAgICAgIHRoaXMudGVybU5hbWVzID0gc3BlYy50ZXJtTmFtZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tYXhOb2RlID0gdGhpcy5ub2RlU2V0LnR5cGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5zdGF0ZXMubGVuZ3RoIC8gNiAvKiBTaXplICovOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5uZXh0U3RhdGVDYWNoZVtpXSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KCk7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3BSdWxlc1tPYmplY3Qua2V5cyh0aGlzLnRvcFJ1bGVzKVswXV07XG4gICAgfVxuICAgIC8vLyBQYXJzZSBhIGdpdmVuIHN0cmluZyBvciBzdHJlYW0uXG4gICAgcGFyc2UoaW5wdXQsIHN0YXJ0UG9zID0gMCwgY29udGV4dCA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbGV6ZXJUcmVlLnN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgbGV0IGN4ID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBzdGFydFBvcywgY29udGV4dCk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gY3guYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFN0YXJ0IGFuIGluY3JlbWVudGFsIHBhcnNlLlxuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIHN0YXJ0UG9zID0gMCwgY29udGV4dCA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbGV6ZXJUcmVlLnN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZSh0aGlzLCBpbnB1dCwgc3RhcnRQb3MsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIEZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmROZXN0ZWQoc3RhdGUpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogRmxhZ3MgKi8pO1xuICAgICAgICByZXR1cm4gZmxhZ3MgJiA0IC8qIFN0YXJ0TmVzdCAqLyA/IHRoaXMubmVzdGVkW2ZsYWdzID4+IDEwIC8qIE5lc3RTaGlmdCAqL10gOiBudWxsO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdmFsaWRBY3Rpb24oc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uID09IHRoaXMuc3RhdGVTbG90KHN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSBwYWlyKHRoaXMuZGF0YSwgaSArIDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHN0YXRlcyB0aGF0IGNhbiBmb2xsb3cgdGhpcyBvbmUgdGhyb3VnaCBzaGlmdCBhY3Rpb25zIG9yXG4gICAgLy8vIGdvdG8ganVtcHMuIEBpbnRlcm5hbFxuICAgIG5leHRTdGF0ZXMoc3RhdGUpIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMubmV4dFN0YXRlQ2FjaGVbc3RhdGVdO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmRhdGFbaSArIDJdICYgKDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8gPj4gMTYpKSA9PSAwICYmIHJlc3VsdC5pbmRleE9mKHRoaXMuZGF0YVtpICsgMV0pIDwgMClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmRhdGFbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFibGUgPSB0aGlzLmdvdG8sIG1heCA9IHRhYmxlWzBdO1xuICAgICAgICBmb3IgKGxldCB0ZXJtID0gMDsgdGVybSA8IG1heDsgdGVybSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0YWJsZVt0ZXJtICsgMV07Oykge1xuICAgICAgICAgICAgICAgIGxldCBncm91cFRhZyA9IHRhYmxlW3BvcysrXSwgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlW3Bvc10gPT0gc3RhdGUgJiYgcmVzdWx0LmluZGV4T2YodGFyZ2V0KSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFRhZyAmIDEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRTdGF0ZUNhY2hlW3N0YXRlXSA9IHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG92ZXJyaWRlcyh0b2tlbiwgcHJldikge1xuICAgICAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgcHJldik7XG4gICAgICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHRva2VuKSA8IGlQcmV2O1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIC8vLyBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIC8vLyBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKFBhcnNlci5wcm90b3R5cGUpLCB0aGlzKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9wcylcbiAgICAgICAgICAgIGNvcHkubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uY29uZmlnLnByb3BzKTtcbiAgICAgICAgaWYgKGNvbmZpZy50b3ApIHtcbiAgICAgICAgICAgIGxldCBpbmZvID0gdGhpcy50b3BSdWxlc1tjb25maWcudG9wXTtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCB0b3AgcnVsZSBuYW1lICR7Y29uZmlnLnRvcH1gKTtcbiAgICAgICAgICAgIGNvcHkudG9wID0gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnRva2VuaXplcnMpXG4gICAgICAgICAgICBjb3B5LnRva2VuaXplcnMgPSB0aGlzLnRva2VuaXplcnMubWFwKHQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy50b2tlbml6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gZm91bmQudG8gOiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuZGlhbGVjdClcbiAgICAgICAgICAgIGNvcHkuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KGNvbmZpZy5kaWFsZWN0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5uZXN0ZWQpXG4gICAgICAgICAgICBjb3B5Lm5lc3RlZCA9IHRoaXMubmVzdGVkLm1hcChvYmogPT4ge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZy5uZXN0ZWQsIG9iai5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBvYmoubmFtZSwgdmFsdWU6IGNvbmZpZy5uZXN0ZWRbb2JqLm5hbWVdLCBlbmQ6IG9iai5lbmQsIHBsYWNlaG9sZGVyOiBvYmoucGxhY2Vob2xkZXIgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgICAvLy8gd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgLy8vIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICAvLy8gc3RvcmVkLlxuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLy8vIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgLy8vIHR5cGVzLiBAaW50ZXJuYWxcbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvLy8gVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBncmFtbWFyIGhhcyBhbnkgbmVzdGVkIGdyYW1tYXJzLlxuICAgIGdldCBoYXNOZXN0ZWQoKSB7IHJldHVybiB0aGlzLm5lc3RlZC5sZW5ndGggPiAwOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGR5bmFtaWNQcmVjZWRlbmNlKHRlcm0pIHtcbiAgICAgICAgbGV0IHByZWMgPSB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcztcbiAgICAgICAgcmV0dXJuIHByZWMgPT0gbnVsbCA/IDAgOiBwcmVjW3Rlcm1dIHx8IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwYXJzZURpYWxlY3QoZGlhbGVjdCkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZWREaWFsZWN0ICYmIHRoaXMuY2FjaGVkRGlhbGVjdC5zb3VyY2UgPT0gZGlhbGVjdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZERpYWxlY3Q7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkRGlhbGVjdCA9IG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8vLyAodXNlZCBieSB0aGUgb3V0cHV0IG9mIHRoZSBwYXJzZXIgZ2VuZXJhdG9yKSBAaW50ZXJuYWxcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihzcGVjKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYWlyKGRhdGEsIG9mZikgeyByZXR1cm4gZGF0YVtvZmZdIHwgKGRhdGFbb2ZmICsgMV0gPDwgMTYpOyB9XG5mdW5jdGlvbiBmaW5kT2Zmc2V0KGRhdGEsIHN0YXJ0LCB0ZXJtKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBuZXh0OyAobmV4dCA9IGRhdGFbaV0pICE9IDY1NTM1IC8qIEVuZCAqLzsgaSsrKVxuICAgICAgICBpZiAobmV4dCA9PSB0ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIGkgLSBzdGFydDtcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBmaW5kRmluaXNoZWQoc3RhY2tzKSB7XG4gICAgbGV0IGJlc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBpZiAoc3RhY2sucG9zID09IHN0YWNrLmN4LmlucHV0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc3RhY2suY3gucGFyc2VyLnN0YXRlRmxhZyhzdGFjay5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pICYmXG4gICAgICAgICAgICAoIWJlc3QgfHwgYmVzdC5zY29yZSA8IHN0YWNrLnNjb3JlKSlcbiAgICAgICAgICAgIGJlc3QgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG59XG5cbmV4cG9ydHMuTm9kZVByb3AgPSBsZXplclRyZWUuTm9kZVByb3A7XG5leHBvcnRzLk5vZGVTZXQgPSBsZXplclRyZWUuTm9kZVNldDtcbmV4cG9ydHMuTm9kZVR5cGUgPSBsZXplclRyZWUuTm9kZVR5cGU7XG5leHBvcnRzLlRyZWUgPSBsZXplclRyZWUuVHJlZTtcbmV4cG9ydHMuVHJlZUN1cnNvciA9IGxlemVyVHJlZS5UcmVlQ3Vyc29yO1xuZXhwb3J0cy5FeHRlcm5hbFRva2VuaXplciA9IEV4dGVybmFsVG9rZW5pemVyO1xuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG5leHBvcnRzLlN0YWNrID0gU3RhY2s7XG5leHBvcnRzLlRva2VuID0gVG9rZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXN1bmlPcCA9IGV4cG9ydHMuaXNzYW1lT3AgPSBleHBvcnRzLmlzYm9vbE9wID0gZXhwb3J0cy5pc2ludE9wID0gZXhwb3J0cy5pc09wID0gdm9pZCAwO1xudmFyIGludF9vcHMgPSB7IFwiK1wiOiB0cnVlLCBcIi1cIjogdHJ1ZSwgXCIqXCI6IHRydWUsIFwiLy9cIjogdHJ1ZSwgXCIlXCI6IHRydWUsXG4gICAgXCI+XCI6IHRydWUsIFwiPFwiOiB0cnVlLCBcIj49XCI6IHRydWUsIFwiPD1cIjogdHJ1ZSB9O1xudmFyIHNhbWVfb3BzID0geyBcIj09XCI6IHRydWUsIFwiIT1cIjogdHJ1ZSB9O1xudmFyIGJvb2xfb3BzID0geyBcImFuZFwiOiB0cnVlLCBcIm9yXCI6IHRydWUgfTtcbnZhciBzcGVjX29wcyA9IHsgXCJpc1wiOiB0cnVlIH07XG52YXIgdW5pX29wcyA9IHsgXCJub3RcIjogdHJ1ZSwgXCItXCI6IHRydWUgfTtcbmZ1bmN0aW9uIGlzT3AobWF5YmVPcCkge1xuICAgIHJldHVybiBtYXliZU9wIGluIGludF9vcHMgfHwgbWF5YmVPcCBpbiBib29sX29wcyB8fCBtYXliZU9wIGluIHNhbWVfb3BzIHx8IG1heWJlT3AgaW4gc3BlY19vcHM7XG59XG5leHBvcnRzLmlzT3AgPSBpc09wO1xuZnVuY3Rpb24gaXNpbnRPcChtYXliZU9wKSB7XG4gICAgcmV0dXJuIG1heWJlT3AgaW4gaW50X29wcztcbn1cbmV4cG9ydHMuaXNpbnRPcCA9IGlzaW50T3A7XG5mdW5jdGlvbiBpc2Jvb2xPcChtYXliZU9wKSB7XG4gICAgcmV0dXJuIG1heWJlT3AgaW4gYm9vbF9vcHM7XG59XG5leHBvcnRzLmlzYm9vbE9wID0gaXNib29sT3A7XG5mdW5jdGlvbiBpc3NhbWVPcChtYXliZU9wKSB7XG4gICAgcmV0dXJuIG1heWJlT3AgaW4gc2FtZV9vcHM7XG59XG5leHBvcnRzLmlzc2FtZU9wID0gaXNzYW1lT3A7XG5mdW5jdGlvbiBpc3VuaU9wKG1heWJlT3ApIHtcbiAgICByZXR1cm4gbWF5YmVPcCBpbiB1bmlfb3BzO1xufVxuZXhwb3J0cy5pc3VuaU9wID0gaXN1bmlPcDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBpbGUgPSBleHBvcnRzLmNvZGVHZW5TdG10ID0gZXhwb3J0cy5jb2RlR2VuQ2xhc3MgPSBleHBvcnRzLmNvZGVHZW5GdW5EZWYgPSBleHBvcnRzLmNvZGVHZW5FeHByID0gZXhwb3J0cy5vcFN0bXRzID0gZXhwb3J0cy5ydW53YXRzcmMgPSB2b2lkIDA7XG52YXIgd2FidF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ3YWJ0XCIpKTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3BhcnNlclwiKTtcbnZhciB0Y18xID0gcmVxdWlyZShcIi4vdGNcIik7XG52YXIgbG9vcF9jb3VudGVyID0gMDtcbnZhciBvYmpfZmllbGRfdHlwZV9pZHg7XG52YXIgY2xhc3NlcyA9IG5ldyBNYXAoKTtcbnZhciBvYmpfbmFtZV9yZWcgPSBcIm5vbmVcIjtcbnZhciB0bXBfdmFycyA9IFtdO1xudmFyIHVuYXNzaWduZWRfY2xzID0gMDtcbnZhciBkZWNsX29mX2Z1bmNzID0gW107XG5mdW5jdGlvbiB2YXJpYWJsZU5hbWVzKHN0bXRzLCBjbGFzc19uYW1lKSB7XG4gICAgaWYgKGNsYXNzX25hbWUgPT09IHZvaWQgMCkgeyBjbGFzc19uYW1lID0gXCJcIjsgfVxuICAgIHZhciB2YXJzID0gW107XG4gICAgc3RtdHMuZm9yRWFjaChmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgICBpZiAoc3RtdC50YWcgPT09IFwiYXNzaWduXCIgJiYgISh2YXJzLmluY2x1ZGVzKHN0bXQubmFtZSkpKSB7XG4gICAgICAgICAgICBpZiAoY2xhc3NfbmFtZSAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdmFycy5wdXNoKFwiXCIuY29uY2F0KGNsYXNzX25hbWUsIFwiLlwiKS5jb25jYXQoc3RtdC5uYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXJzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YXJzO1xufVxuZnVuY3Rpb24gZnVucyhzdG10cykge1xuICAgIHJldHVybiBzdG10cy5maWx0ZXIoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudGFnID09PSBcImRlZmluZVwiOyB9KTtcbn1cbmZ1bmN0aW9uIG5vbkZ1bnMoc3RtdHMpIHtcbiAgICByZXR1cm4gc3RtdHMuZmlsdGVyKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnRhZyAhPT0gXCJkZWZpbmVcIjsgfSk7XG59XG5mdW5jdGlvbiB2YXJzRnVuc1N0bXRzKHN0bXRzKSB7XG4gICAgcmV0dXJuIFt2YXJpYWJsZU5hbWVzKHN0bXRzKSwgZnVucyhzdG10cyksIG5vbkZ1bnMoc3RtdHMpXTtcbn1cbmZ1bmN0aW9uIHJ1bndhdHNyYyh3YXRTb3VyY2UsIGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdhYnRBcGksIHBhcnNlZCwgYmluYXJ5LCB3YXNtTW9kdWxlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgd2FidF8xLmRlZmF1bHQpKCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgd2FidEFwaSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gd2FidEFwaS5wYXJzZVdhdChcImV4YW1wbGVcIiwgd2F0U291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5ID0gcGFyc2VkLnRvQmluYXJ5KHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LmJ1ZmZlciwgY29uZmlnKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB3YXNtTW9kdWxlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgd2FzbU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzLl9zdGFydCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJ1bndhdHNyYyA9IHJ1bndhdHNyYztcbmZ1bmN0aW9uIG9wU3RtdHMob3ApIHtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6IHJldHVybiBbXCJpMzIuYWRkXCJdO1xuICAgICAgICBjYXNlIFwiLVwiOiByZXR1cm4gW1wiaTMyLnN1YlwiXTtcbiAgICAgICAgY2FzZSBcIipcIjogcmV0dXJuIFtcImkzMi5tdWxcIl07XG4gICAgICAgIGNhc2UgXCIvL1wiOiByZXR1cm4gW1wiaTMyLmRpdl9zXCJdO1xuICAgICAgICBjYXNlIFwiJVwiOiByZXR1cm4gW1wiaTMyLnJlbV9zXCJdO1xuICAgICAgICBjYXNlIFwiPlwiOiByZXR1cm4gW1wiaTMyLmd0X3NcIl07XG4gICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiBbXCJpMzIubHRfc1wiXTtcbiAgICAgICAgY2FzZSBcIj49XCI6IHJldHVybiBbXCJpMzIuZ2Vfc1wiXTtcbiAgICAgICAgY2FzZSBcIjw9XCI6IHJldHVybiBbXCJpMzIubGVfc1wiXTtcbiAgICAgICAgY2FzZSBcIj09XCI6IHJldHVybiBbXCJpMzIuZXFcIl07XG4gICAgICAgIGNhc2UgXCIhPVwiOiByZXR1cm4gW1wiaTMyLm5lXCJdO1xuICAgICAgICBjYXNlIFwiYW5kXCI6IHJldHVybiBbXCJpMzIuYW5kXCJdO1xuICAgICAgICBjYXNlIFwib3JcIjogcmV0dXJuIFtcImkzMi5vclwiXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIltDb21waWxlci50c11VbmhhbmRsZWQgb3IgdW5rbm93biBvcDogXCIuY29uY2F0KG9wKSk7XG4gICAgfVxufVxuZXhwb3J0cy5vcFN0bXRzID0gb3BTdG10cztcbmZ1bmN0aW9uIGNvZGVHZW5FeHByKGV4cHIsIGxvY2Fscykge1xuICAgIHZhciBlbXB0eUVudiA9IG5ldyBNYXAoKTtcbiAgICBzd2l0Y2ggKGV4cHIudGFnKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjogcmV0dXJuIFtcIihpMzIuY29uc3QgXCIuY29uY2F0KGV4cHIudmFsdWUsIFwiKVwiKV07XG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6IHJldHVybiBbXCIoaTMyLmNvbnN0IDEpXCJdO1xuICAgICAgICBjYXNlIFwiZmFsc2VcIjogcmV0dXJuIFtcIihpMzIuY29uc3QgMClcIl07XG4gICAgICAgIGNhc2UgXCJub25lXCI6IHJldHVybiBbXCIoaTMyLmNvbnN0IDApXCJdO1xuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIHR5cGUtY2hlY2tlZCBmb3IgbWFraW5nIHN1cmUgYWxsIHZhcmlhYmxlIGV4aXN0LCBoZXJlIHdlXG4gICAgICAgICAgICAvLyBqdXN0IGNoZWNrIGlmIGl0J3MgYSBsb2NhbCB2YXJpYWJsZSBhbmQgYXNzdW1lIGl0IGlzIGdsb2JhbCBpZiBub3RcbiAgICAgICAgICAgIGlmIChsb2NhbHMuaGFzKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiKGxvY2FsLmdldCAkXCIuY29uY2F0KGV4cHIubmFtZSwgXCIpXCIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCIoZ2xvYmFsLmdldCAkXCIuY29uY2F0KGV4cHIubmFtZSwgXCIpXCIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJpbm9wXCI6IHtcbiAgICAgICAgICAgIHZhciBsaHNFeHBycyA9IGNvZGVHZW5FeHByKGV4cHIubGhzLCBsb2NhbHMpO1xuICAgICAgICAgICAgdmFyIHJoc0V4cHJzID0gY29kZUdlbkV4cHIoZXhwci5yaHMsIGxvY2Fscyk7XG4gICAgICAgICAgICBpZiAoZXhwci5vcCA9PSAnaXMnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb21waWxlciBsaHMvcmhzOiBcIiwgZXhwci5saHMsIGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhleHByLmxocy5hID09IGV4cHIucmhzLmEsIGV4cHIubGhzLmEgPT09IGV4cHIucmhzLmEpO1xuICAgICAgICAgICAgICAgIGlmIChleHByLmxocy5hID09PSBleHByLnJocy5hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhbWUgbGlrZSByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiKGkzMi5jb25zdCAxKVwiXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCIoaTMyLmNvbnN0IDApXCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcHN0bXRzID0gb3BTdG10cyhleHByLm9wKTtcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgbGhzRXhwcnMsIHRydWUpLCByaHNFeHBycywgdHJ1ZSksIG9wc3RtdHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNsYXNzZXM6XCIsIGNsYXNzZXMpO1xuICAgICAgICAgICAgaWYgKGNsYXNzZXMuaGFzKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnN0YW50aWF0ZSBhIG5ldyBvYmogb2YgY2xhc3MgJ2V4cHIubmFtZSdcbiAgICAgICAgICAgICAgICB2YXIgaW5pdHZhbHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NkYXRhID0gY2xhc3Nlcy5nZXQoZXhwci5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NkYXRhLnRhZyAhPSBcImNsYXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xhc3NkYXRhIGhhcyBhbiBub24tY2xhc3MgdGFnXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3Qgd2UgY29tcGlsZSBpdHMgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ial9uYW1lX3JlZyA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBjbGFzcyB3aXRob3V0IGFuIG9iaiBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wX29ial9uYW1lID0gXCJSRVNFUlZFRF9cIi5jb25jYXQodW5hc3NpZ25lZF9jbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGluZyB0bXAgdmFyIFwiLmNvbmNhdCh0bXBfb2JqX25hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVE1QX1ZBUlM6IFwiLmNvbmNhdCh0bXBfdmFycykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wX3ZhcnMucHVzaCh0bXBfb2JqX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cl9wdXNoX3RtcF9uYW1lID0gXCJnbG9iYWwuc2V0ICRcIi5jb25jYXQodG1wX29ial9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2X29ial9uYW1lX3JlZyA9IG9ial9uYW1lX3JlZztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ial9uYW1lX3JlZyA9IHRtcF9vYmpfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc2RhdGEuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGYsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaW5kZXggKiA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYudGFnICE9IFwiYXNzaWduXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWVsZCBcIi5jb25jYXQoZiwgXCIgZG9lcyBub3QgaGF2ZSBhbiAnYXNzaWduJyB0YWdcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbFRvQmUgPSBjb2RlR2VuRXhwcihmLnZhbHVlLCBsb2NhbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxUb0JlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbXBpbGVkIGZpZWxkcyBpcyBub3QgYSBsaXRlcmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqX2ZpZWxkX3R5cGVfaWR4LmdldChleHByLm5hbWUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkZXRlY3QgdW5kZWZpbmQgZm9yIE9GSTogXCIuY29uY2F0KGV4cHIubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpfZmllbGRfdHlwZV9pZHguc2V0KGV4cHIubmFtZSwgbmV3IE1hcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ial9maWVsZF90eXBlX2lkeC5nZXQob2JqX25hbWVfcmVnKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ial9maWVsZF90eXBlX2lkeC5zZXQob2JqX25hbWVfcmVnLCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFkZGluZyB0aGlzIGVudHJ5OlwiLmNvbmNhdChmLm5hbWUsIFwiLFwiKS5jb25jYXQoaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpfZmllbGRfdHlwZV9pZHguZ2V0KGV4cHIubmFtZSkuc2V0KGYubmFtZSwgW2YuYSwgaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpfZmllbGRfdHlwZV9pZHguZ2V0KG9ial9uYW1lX3JlZykuc2V0KGYubmFtZSwgW2YuYSwgaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXR2YWxzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBpbml0dmFscywgdHJ1ZSksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihnbG9iYWwuZ2V0ICRoZWFwKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKGkzMi5hZGQgKGkzMi5jb25zdCBcIi5jb25jYXQob2Zmc2V0LCBcIikpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbFRvQmVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpMzIuc3RvcmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJPTlI6XCIsIG9ial9uYW1lX3JlZyk7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZGF0YS5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMsIGZfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19uYW1lID0gXCJcIi5jb25jYXQoZl9uYW1lLCBcIiRcIikuY29uY2F0KG9ial9uYW1lX3JlZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY19zdHJpbmcgPSBjb2RlR2VuRnVuRGVmKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmdW5jKSwgeyBuYW1lOiBuZXdfbmFtZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsX29mX2Z1bmNzID0gW2RlY2xfb2ZfZnVuY3Muam9pbigpICsgZnVuY19zdHJpbmcuam9pbigpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRE9GOlwiLCBkZWNsX29mX2Z1bmNzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xfb2ZfZnVuY3MgPSBkZWNsX29mX2Z1bmNzLmZsYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJET0YgYWZ0ZXIgZmxhdDpcIiwgZGVjbF9vZl9mdW5jcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X29ial9uYW1lX3JlZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpfbmFtZV9yZWcgPSBwcmV2X29ial9uYW1lX3JlZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuX3N0cjtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTVFIgVE8gUFVTSFwiLCBzdHJfcHVzaF90bXBfbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJfcHVzaF90bXBfbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5fc3RyID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBpbml0dmFscywgdHJ1ZSksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihnbG9iYWwuZ2V0ICRoZWFwKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKGdsb2JhbC5zZXQgJGhlYXAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJGhlYXApIChpMzIuY29uc3QgXCIuY29uY2F0KGNsYXNzZGF0YS5maWVsZHMubGVuZ3RoICogNCwgXCIpKSlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyX3B1c2hfdG1wX25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybl9zdHIgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGluaXR2YWxzLCB0cnVlKSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKGdsb2JhbC5nZXQgJGhlYXApXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoZ2xvYmFsLnNldCAkaGVhcCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkaGVhcCkgKGkzMi5jb25zdCBcIi5jb25jYXQoY2xhc3NkYXRhLmZpZWxkcy5sZW5ndGggKiA0LCBcIikpKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5fc3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWxTdG10cyA9IGV4cHIuYXJncy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNvZGVHZW5FeHByKGUsIGxvY2Fscyk7IH0pLmZsYXQoKTtcbiAgICAgICAgICAgIHZhciB0b0NhbGwgPSBleHByLm5hbWU7XG4gICAgICAgICAgICBpZiAoZXhwci5uYW1lID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInBhcnNlIHByaW50LCBhID0gXCIgKyBleHByLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwci5hcmdzWzBdLmEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQ2FsbCA9IFwicHJpbnRfYm9vbFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQ2FsbCA9IFwicHJpbnRfbnVtXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQ2FsbCA9IFwicHJpbnRfbm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQUklOVCBFUlJPUjogYW5ub3RhdGlvbiA9IFwiLmNvbmNhdChleHByLmFyZ3NbMF0uYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsU3RtdHMucHVzaChcIihjYWxsICRcIi5jb25jYXQodG9DYWxsLCBcIilcIikpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codmFsU3RtdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbFN0bXRzO1xuICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICBpZiAoZXhwci50YWcgPT0gXCJtZXRob2RcIikge1xuICAgICAgICAgICAgICAgIC8vVHJpY2t5IGhlcmUsIHVzZSBlbXB0eSBlbnYgdG8gaW5pdFxuICAgICAgICAgICAgICAgIHZhciBhcmdJbnN0cnMgPSBleHByLmFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBjb2RlR2VuRXhwcihhLCBlbXB0eUVudik7IH0pLmZsYXQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub19vYmogPSBleHByLm9iai5hO1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2Rfc3VwcG9ydF90eXBlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAobWV0aG9kX3N1cHBvcnRfdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Rfc3VwcG9ydF90eXBlW21ldGhvZF9zdXBwb3J0X3R5cGVbXCJpZFwiXSA9IDBdID0gXCJpZFwiO1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Rfc3VwcG9ydF90eXBlW21ldGhvZF9zdXBwb3J0X3R5cGVbXCJtZXRob2RcIl0gPSAxXSA9IFwibWV0aG9kXCI7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZF9zdXBwb3J0X3R5cGVbbWV0aG9kX3N1cHBvcnRfdHlwZVtcImdldGZpZWxkXCJdID0gMl0gPSBcImdldGZpZWxkXCI7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZF9zdXBwb3J0X3R5cGVbbWV0aG9kX3N1cHBvcnRfdHlwZVtcImNhbGxcIl0gPSAzXSA9IFwiY2FsbFwiO1xuICAgICAgICAgICAgICAgIH0pKG1ldGhvZF9zdXBwb3J0X3R5cGUgfHwgKG1ldGhvZF9zdXBwb3J0X3R5cGUgPSB7fSkpO1xuICAgICAgICAgICAgICAgIGlmIChhbm5vX29iaiAhPSBcImludFwiICYmIGFubm9fb2JqICE9IFwibm9uZVwiICYmIGFubm9fb2JqICE9IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlb2JqID0gZXhwci5vYmo7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlb2JqX3N0bXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcF9uYW1lID0gb2JqX25hbWVfcmVnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW9iai50YWcgPT0gXCJpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHkgaXQgY2FuIGJlIGEgY2FsbFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZfbGVuZ3RoID0gdG1wX3ZhcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVvYmpfc3RtdCA9IGNvZGVHZW5FeHByKGVvYmosIGxvY2Fscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldl9sZW5ndGggIT0gdG1wX3ZhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wX25hbWUgPSB0bXBfdmFyc1t0bXBfdmFycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW9iai50YWcgPT0gJ3NlbGYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlb2JqID0geyB0YWc6ICdpZCcsIG5hbWU6IG9ial9uYW1lX3JlZywgYTogZW9iai5hIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVvYmoudGFnID09IFwiaWRcIiB8fCBlb2JqLnRhZyA9PSBcIm1ldGhvZFwiIHx8IGVvYmoudGFnID09IFwiZ2V0ZmllbGRcIiB8fCBlb2JqLnRhZyA9PSBcImNhbGxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZF9zdG10cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlb2JqX3N0bXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR290IHJlY3Vyc2l2ZSBleHByIGluIG9iajogdG1wX25hbWVcIiwgdG1wX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZF9zdG10cyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBlb2JqX3N0bXQsIHRydWUpLCBhcmdJbnN0cnMsIHRydWUpLCBbXCJjYWxsICRcIi5jb25jYXQoZXhwci5uYW1lLCBcIiRcIikuY29uY2F0KHRtcF9uYW1lKV0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZF9zdG10cyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYXJnSW5zdHJzLCB0cnVlKSwgW1wiY2FsbCAkXCIuY29uY2F0KGV4cHIubmFtZSwgXCIkXCIpLmNvbmNhdChlb2JqLm5hbWUpXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVyZSBvYmogdGFnIG11c3QgYmUgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJtZXRob2Rfc3RtdHM6XCIsIG1ldGhvZF9zdG10cyk7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kX3N0bXRzO1xuICAgICAgICBjYXNlIFwiZ2V0ZmllbGRcIjpcbiAgICAgICAgICAgIHZhciBhbm5vID0gZXhwci5vYmouYTtcbiAgICAgICAgICAgIGlmIChhbm5vICE9IFwiaW50XCIgJiYgYW5ubyAhPSBcIm5vbmVcIiAmJiBhbm5vICE9IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iamV4cHJzID0gY29kZUdlbkV4cHIoZXhwci5vYmosIGxvY2Fscyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGV4cHIub2JqLnRhZz09XCJzZWxmXCIpe1xuICAgICAgICAgICAgICAgIC8vICAgLy9kb25vdGhpbmdcbiAgICAgICAgICAgICAgICAvLyB9ZWxzZXtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIub2JqLnRhZyAhPSAnaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLm9iai50YWcgPT0gJ3NlbGYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByLmEgPSBvYmpfZmllbGRfdHlwZV9pZHguZ2V0KG9ial9uYW1lX3JlZykuZ2V0KGV4cHIubmFtZSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByLm9iaiA9IHsgdGFnOiAnaWQnLCBuYW1lOiBvYmpfbmFtZV9yZWcsIGE6IGV4cHIub2JqLmEgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iaiB0YWcgaXMgbm90ICdpZCcgb3IgJ3NlbGYnLCBpbnN0ZWFkIGl0J3MgXCIuY29uY2F0KGV4cHIub2JqLnRhZykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvYmpkYXRhID0gb2JqX2ZpZWxkX3R5cGVfaWR4LmdldChleHByLm9iai5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJVTlRJTUUgRVJST1I6IG9iamRhdGEgb2YgXCIuY29uY2F0KGV4cHIub2JqLm5hbWUsIFwiIGlzIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0ZmllbGQgXCIuY29uY2F0KGV4cHIubmFtZSwgXCIgb2YgXCIpLmNvbmNhdChleHByLm9iai5uYW1lLCBcIiwgb2JqZGF0YVwiKSk7XG4gICAgICAgICAgICAgICAgdmFyIGlvZiA9IG9iamRhdGEuZ2V0KGV4cHIubmFtZSlbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIihnbG9iYWwuZ2V0ICRcIi5jb25jYXQoZXhwci5vYmoubmFtZSwgXCIpXCIpLCBcIihpMzIuYWRkIChpMzIuY29uc3QgXCIuY29uY2F0KGlvZiAqIDQsIFwiKSlcIiksIFwiKGkzMi5sb2FkKVwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iaiBnZXQgYW4gYW5ub3RhdGlvbiBvZiBcIi5jb25jYXQoYW5ubykpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwic2VsZlwiOlxuICAgICAgICAgICAgaWYgKGxvY2Fscy5oYXMob2JqX25hbWVfcmVnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCIobG9jYWwuZ2V0ICRcIi5jb25jYXQob2JqX25hbWVfcmVnLCBcIilcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIihnbG9iYWwuZ2V0ICRcIi5jb25jYXQob2JqX25hbWVfcmVnLCBcIilcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwciBcIi5jb25jYXQoZXhwciwgXCIgbm90IGltcGxlbWVudGVkIVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5jb2RlR2VuRXhwciA9IGNvZGVHZW5FeHByO1xuZnVuY3Rpb24gY29kZUdlbkZ1bkRlZihtKSB7XG4gICAgdmFyIGVtcHR5RW52ID0gbmV3IE1hcCgpO1xuICAgIHZhciB3aXRoUGFyYW1zQW5kVmFyaWFibGVzID0gbmV3IE1hcChlbXB0eUVudi5lbnRyaWVzKCkpO1xuICAgIHZhciBpID0gbS5uYW1lLmluZGV4T2YoJyQnKTtcbiAgICBpZiAoaSAhPSAtMSkge1xuICAgICAgICB2YXIgcHJldl9vYmpfbmFtZV9yZWcgPSBvYmpfbmFtZV9yZWc7XG4gICAgICAgIG9ial9uYW1lX3JlZyA9IG0ubmFtZS5zbGljZShpICsgMSk7XG4gICAgfVxuICAgIC8vIENvbnN0cnVjdCB0aGUgZW52aXJvbm1lbnQgZm9yIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgdmFyIHZhcmlhYmxlcyA9IHZhcmlhYmxlTmFtZXMobS5ib2R5KTtcbiAgICB2YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gd2l0aFBhcmFtc0FuZFZhcmlhYmxlcy5zZXQodiwgdHJ1ZSk7IH0pO1xuICAgIG0ucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHdpdGhQYXJhbXNBbmRWYXJpYWJsZXMuc2V0KHAubmFtZSwgdHJ1ZSk7IH0pO1xuICAgIC8vIENvbnN0cnVjdCB0aGUgY29kZSBmb3IgcGFyYW1zIGFuZCB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgaW4gdGhlIGJvZHlcbiAgICB2YXIgcGFyYW1zID0gbS5wYXJhbXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIC8vSWdub3JlIHNlbGZcbiAgICAgICAgaWYgKHAubmFtZSAhPSBcInNlbGZcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiKHBhcmFtICRcIi5jb25jYXQocC5uYW1lLCBcIiBpMzIpXCIpO1xuICAgICAgICB9XG4gICAgfSkuam9pbihcIiBcIik7XG4gICAgdmFyIHZhckRlY2xzID0gdmFyaWFibGVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gXCIobG9jYWwgJFwiLmNvbmNhdCh2LCBcIiBpMzIpXCIpOyB9KS5qb2luKFwiXFxuXCIpO1xuICAgIC8vIFZlcnkgVHJpY2t5IGhlcmUsIHdlIGlnbm9yZSB0aGUgZ2xvYmFsIHZhcmlhYmxlXG4gICAgdmFyIHN0bXRzID0gbS5ib2R5Lm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gY29kZUdlblN0bXQocywgd2l0aFBhcmFtc0FuZFZhcmlhYmxlcywgZW1wdHlFbnYpOyB9KS5mbGF0KCk7XG4gICAgdmFyIHN0bXRzQm9keSA9IHN0bXRzLmpvaW4oXCJcXG5cIik7XG4gICAgaWYgKHByZXZfb2JqX25hbWVfcmVnICE9PSB1bmRlZmluZWQgJiYgcHJldl9vYmpfbmFtZV9yZWcgIT0gb2JqX25hbWVfcmVnKSB7XG4gICAgICAgIG9ial9uYW1lX3JlZyA9IHByZXZfb2JqX25hbWVfcmVnO1xuICAgIH1cbiAgICByZXR1cm4gW1wiKGZ1bmMgJFwiLmNvbmNhdChtLm5hbWUsIFwiIFwiKS5jb25jYXQocGFyYW1zLCBcIiAocmVzdWx0IGkzMilcXG4gICAgICAgIChsb2NhbCAkc2NyYXRjaCBpMzIpXFxuICAgICAgICBcIikuY29uY2F0KHZhckRlY2xzLCBcIlxcbiAgICAgICAgXCIpLmNvbmNhdChzdG10c0JvZHksIFwiXFxuICAgICAgICAoaTMyLmNvbnN0IDApKVwiKV07XG59XG5leHBvcnRzLmNvZGVHZW5GdW5EZWYgPSBjb2RlR2VuRnVuRGVmO1xuZnVuY3Rpb24gY29kZUdlbkNsYXNzKGMpIHtcbiAgICAvLyBDdXJyZW50bHkgZG8gbm90IHdhbnQgYWRkIGFueSBnbG9iYWxzIHdoZW4gZ2VuZXJhdGluZyBjbGFzc1xuICAgIHZhciBtZXRob2RzID0gW107XG4gICAgaWYgKGMudGFnICE9IFwiY2xhc3NcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDR0MgRVJST1I6IFN0YXRlbWVudCB0YWcgaXMgbm90ICdjbGFzcycsIHNob3VsZCBub3QgY2FsbCBDR0NcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjLm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobSwgaSkge1xuICAgICAgICAgICAgdmFyIHRoaXNfZnVuID0gY29kZUdlbkZ1bkRlZihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbSksIHsgbmFtZTogXCIkXCIuY29uY2F0KG0ubmFtZSwgXCIkXCIpLmNvbmNhdChjLm5hbWUpIH0pKTtcbiAgICAgICAgICAgIG1ldGhvZHMuY29uY2F0KHRoaXNfZnVuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGhvZHMgPSBtZXRob2RzLmZsYXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZHM7XG59XG5leHBvcnRzLmNvZGVHZW5DbGFzcyA9IGNvZGVHZW5DbGFzcztcbmZ1bmN0aW9uIGNvZGVHZW5TdG10KHN0bXQsIGxvY2FscywgZ2xvYmFsX3ZhcnMpIHtcbiAgICB2YXIgd2l0aFBhcmFtc0FuZFZhcmlhYmxlcyA9IG5ldyBNYXAobG9jYWxzLmVudHJpZXMoKSk7XG4gICAgdmFyIGVtcHR5RW52ID0gbmV3IE1hcCgpO1xuICAgIHN3aXRjaCAoc3RtdC50YWcpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAvLyBwdXNoIGNsYXNzX25hbWUgdG8gY2xhc3Nlc1xuICAgICAgICAgICAgY2xhc3Nlcy5zZXQoc3RtdC5uYW1lLCBzdG10KTtcbiAgICAgICAgICAgIC8vIHNldCBjbGFzcyBuYW1lIHJlZyB0byBlbmFibGUgc2VsZi1wYXJzaW5nXG4gICAgICAgICAgICAvLyBjbHNfbmFtZV9yZWcgPSBzdG10Lm5hbWU7XG4gICAgICAgICAgICAvLyAvLyBjb25zdHJ1Y3QgY2xhc3MgdmFyaWFibGVzXG4gICAgICAgICAgICAvLyBjb25zdCBjbHNfdmFycyA9IHZhcmlhYmxlTmFtZXMoc3RtdC5maWVsZHMsc3RtdC5uYW1lKTtcbiAgICAgICAgICAgIC8vIGNsc192YXJzLmZvckVhY2godiA9PiB3aXRoUGFyYW1zQW5kVmFyaWFibGVzLnNldCh2LCB0cnVlKSk7XG4gICAgICAgICAgICAvLyAvL0NvbnN0cnVjdCBtZXRob2RzIGZvciBlYWNoIGNsYXNzXG4gICAgICAgICAgICAvLyBjb25zdCB2YXJEZWNsQ2xzID0gY2xzX3ZhcnMubWFwKGN2ID0+IGBsb2NhbCAkJHtjdn0gaTMyYCkuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgIC8vIC8vIE5PVEU6IHZlcnkgdHJpY2t5IGhlcmUsIHdlIGp1c3QgZG9uJ3QgcGFzcyBnbG9iYWwgZW52IHRvIGNvZGUgZ2VuIHdoZW4gZ2VuIGNsYXNzIG1ldGhvZHNcbiAgICAgICAgICAgIC8vIC8vIE5PVEU6IDA0MjYsIGV2ZW4gbW9yZSB0cmlja3ksIGhhdmUgdG8gY29udmVydCBtYXAgaW50byBhIGxpc3RcbiAgICAgICAgICAgIC8vIGNvbnN0IGZ1bmNDbHMgPSBjb2RlR2VuQ2xhc3Moc3RtdClcbiAgICAgICAgICAgIC8vIGNvbnN0IGZ1bmNDbHNCb2R5ID0gZnVuY0Nscy5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgLy8gLy9SZXNldCBjbGFzcyBuYW1lIHJlZ1xuICAgICAgICAgICAgLy8gY2xzX25hbWVfcmVnID0gXCJub25lXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJkZWZpbmVcIjpcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgZW52aXJvbm1lbnQgZm9yIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICAgICAgICB2YXIgdmFyaWFibGVzID0gdmFyaWFibGVOYW1lcyhzdG10LmJvZHkpO1xuICAgICAgICAgICAgdmFyaWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHdpdGhQYXJhbXNBbmRWYXJpYWJsZXMuc2V0KHYsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIHN0bXQucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHdpdGhQYXJhbXNBbmRWYXJpYWJsZXMuc2V0KHAubmFtZSwgdHJ1ZSk7IH0pO1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBjb2RlIGZvciBwYXJhbXMgYW5kIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBpbiB0aGUgYm9keVxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHN0bXQucGFyYW1zLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gXCIocGFyYW0gJFwiLmNvbmNhdChwLm5hbWUsIFwiIGkzMilcIik7IH0pLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgdmFyIHZhckRlY2xzID0gdmFyaWFibGVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gXCIobG9jYWwgJFwiLmNvbmNhdCh2LCBcIiBpMzIpXCIpOyB9KS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgdmFyIHN0bXRzID0gc3RtdC5ib2R5Lm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gY29kZUdlblN0bXQocywgd2l0aFBhcmFtc0FuZFZhcmlhYmxlcywgZ2xvYmFsX3ZhcnMpOyB9KS5mbGF0KCk7XG4gICAgICAgICAgICB2YXIgc3RtdHNCb2R5ID0gc3RtdHMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgIHJldHVybiBbXCIoZnVuYyAkXCIuY29uY2F0KHN0bXQubmFtZSwgXCIgXCIpLmNvbmNhdChwYXJhbXMsIFwiIChyZXN1bHQgaTMyKVxcbiAgICAgICAgKGxvY2FsICRzY3JhdGNoIGkzMilcXG4gICAgICAgIFwiKS5jb25jYXQodmFyRGVjbHMsIFwiXFxuICAgICAgICBcIikuY29uY2F0KHN0bXRzQm9keSwgXCJcXG4gICAgICAgIChpMzIuY29uc3QgMCkpXCIpXTtcbiAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgICAgdmFyIHZhbFN0bXRzID0gY29kZUdlbkV4cHIoc3RtdC52YWx1ZSwgbG9jYWxzKTtcbiAgICAgICAgICAgIHZhbFN0bXRzLnB1c2goXCJyZXR1cm5cIik7XG4gICAgICAgICAgICByZXR1cm4gdmFsU3RtdHM7XG4gICAgICAgIGNhc2UgXCJhc3NpZ25cIjpcbiAgICAgICAgICAgIHZhciBvZmkgPSBvYmpfZmllbGRfdHlwZV9pZHg7XG4gICAgICAgICAgICBpZiAoc3RtdC52YWx1ZS50YWcgPT0gJ2NhbGwnICYmIGNsYXNzZXMuaGFzKHN0bXQudmFsdWUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY3JlYXRpbmcgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGluZyBvYmplY3QgXCIuY29uY2F0KHN0bXQubmFtZSwgXCIgZnJvbSBcIikuY29uY2F0KHN0bXQudmFsdWUubmFtZSkpO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2X29ial9uYW1lX3JlZyA9IG9ial9uYW1lX3JlZztcbiAgICAgICAgICAgICAgICBvYmpfbmFtZV9yZWcgPSBzdG10Lm5hbWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwcmV2X29ialwiLCBwcmV2X29ial9uYW1lX3JlZywgXCJvYmpcIiwgb2JqX25hbWVfcmVnKTtcbiAgICAgICAgICAgICAgICB2YXIgc3ZuID0gc3RtdC52YWx1ZS5uYW1lO1xuICAgICAgICAgICAgICAgIG9maS5zZXQoc3RtdC5uYW1lLCBvZmkuZ2V0KHN2bikpO1xuICAgICAgICAgICAgICAgIG9maS5kZWxldGUoc3ZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LnZhbHVlLmhhc093blByb3BlcnR5KCdhJykgJiYgKDAsIHRjXzEuaXNPYmplY3QpKHN0bXQudmFsdWUuYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hhbGxvdyBjb3B5IG9iamVjdCB0byBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQudmFsdWUudGFnID09ICdpZCcgJiYgb2ZpLmhhcyhzdG10LnZhbHVlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ZuID0gc3RtdC52YWx1ZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2ZpLnNldChzdG10Lm5hbWUsIG9maS5nZXQoc3ZuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgdG8gY29weSBvYmplY3QsYnV0IFwiLmNvbmNhdChzdG10LnZhbHVlLCBcIiBpcyBOT1QgYW4gb2JqZWN0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWxTdG10cyA9IGNvZGVHZW5FeHByKHN0bXQudmFsdWUsIGxvY2Fscyk7XG4gICAgICAgICAgICBpZiAoc3RtdC5uYW1lLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIERlYWwgd2l0aCBTZXRmaWVsZFxuICAgICAgICAgICAgICAgIHZhciBvYmpfbmFtZSA9IHN0bXQubmFtZS5zcGxpdCgnLicsIDIpWzBdO1xuICAgICAgICAgICAgICAgIGlmIChvYmpfbmFtZSA9PSAnc2VsZicpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqX25hbWUgPSBvYmpfbmFtZV9yZWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmbGRfbmFtZSA9IHN0bXQubmFtZS5zcGxpdCgnLicsIDIpWzFdO1xuICAgICAgICAgICAgICAgIHZhciBpb2YgPSBvYmpfZmllbGRfdHlwZV9pZHguZ2V0KG9ial9uYW1lKS5nZXQoZmxkX25hbWUpWzFdO1xuICAgICAgICAgICAgICAgIHZhciBsc3Rfb2Zfc3RtdHMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW1xuICAgICAgICAgICAgICAgICAgICBcIihnbG9iYWwuZ2V0ICRcIi5jb25jYXQob2JqX25hbWUsIFwiKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgXCIoaTMyLmFkZCAoaTMyLmNvbnN0IFwiLmNvbmNhdChpb2YgKiA0LCBcIikpXCIpXG4gICAgICAgICAgICAgICAgXSwgdmFsU3RtdHMsIHRydWUpLCBbXG4gICAgICAgICAgICAgICAgICAgIFwiaTMyLnN0b3JlXCJcbiAgICAgICAgICAgICAgICBdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdmFsU3RtdHMgPSBsc3Rfb2Zfc3RtdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxzLmhhcyhzdG10Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFN0bXRzLnB1c2goXCIobG9jYWwuc2V0ICRcIi5jb25jYXQoc3RtdC5uYW1lLCBcIilcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVhbGluZyB3aXRoIGdsb2JhbHNcbiAgICAgICAgICAgICAgICAgICAgdmFsU3RtdHMucHVzaChcIihnbG9iYWwuc2V0ICRcIi5jb25jYXQoc3RtdC5uYW1lLCBcIilcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2X29ial9uYW1lX3JlZyAhPT0gdW5kZWZpbmVkICYmIHByZXZfb2JqX25hbWVfcmVnICE9IG9ial9uYW1lX3JlZykge1xuICAgICAgICAgICAgICAgIG9ial9uYW1lX3JlZyA9IHByZXZfb2JqX25hbWVfcmVnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBRlRFUjogcHJldl9vYmpcIiwgcHJldl9vYmpfbmFtZV9yZWcsIFwib2JqXCIsIG9ial9uYW1lX3JlZyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsU3RtdHM7XG4gICAgICAgIGNhc2UgXCJleHByXCI6XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29kZUdlbkV4cHIoc3RtdC5leHByLCBsb2NhbHMpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCIobG9jYWwuc2V0ICRzY3JhdGNoKVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNhc2UgXCJwYXNzXCI6XG4gICAgICAgICAgICB2YXIgZG9ub3RoaW5nID0gW107XG4gICAgICAgICAgICByZXR1cm4gZG9ub3RoaW5nO1xuICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgIC8vICB7IGE/OiBBLCB0YWc6IFwiaWZcIiwgY29uZDogRXhwcjxBPiwgYm9keTogU3RtdDxBPltdLCBlbHNlX2JvZHk6IFN0bXQ8QT5bXX1cbiAgICAgICAgICAgIHZhciBjb25kRXhwciA9IGNvZGVHZW5FeHByKHN0bXQuY29uZCwgbG9jYWxzKTsgLy9nZW5lcmF0ZSBjb25kaXRpb25cbiAgICAgICAgICAgIHZhciBvdXQgPSBjb25kRXhwci5jb25jYXQoW1wiKGlmXCJdKS5jb25jYXQoW1wiKHRoZW5cIl0pO1xuICAgICAgICAgICAgdmFyIGJvZHlfc3RtdHMgPSBzdG10LmJvZHkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiAoY29kZUdlblN0bXQocywgbG9jYWxzLCBnbG9iYWxfdmFycykpLmZsYXQoKS5qb2luKFwiXFxuXCIpOyB9KTsgLy9nZW5lcmF0ZSB0aGVuIGJvZHlcbiAgICAgICAgICAgIG91dCA9IG91dC5jb25jYXQoYm9keV9zdG10cykuY29uY2F0KFtcIilcIl0pO1xuICAgICAgICAgICAgaWYgKHN0bXQuZWxzZV9ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KFwiKGVsc2VcIik7XG4gICAgICAgICAgICAgICAgdmFyIGVsc2Vfc3RtdHMgPSBzdG10LmVsc2VfYm9keS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChjb2RlR2VuU3RtdChzLCBsb2NhbHMsIGdsb2JhbF92YXJzKSkuZmxhdCgpLmpvaW4oXCJcXG5cIik7IH0pOyAvL2dlbmVyYXRlIHRoZSBlbHNlIGJvZHlcbiAgICAgICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KGVsc2Vfc3RtdHMpLmNvbmNhdChcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2VuZCB0aGUgaWYgc3RhdGVtZW50XG4gICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KFtcIilcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgY2FzZSBcIndoaWxlXCI6XG4gICAgICAgICAgICAvLyB7IGE/OiBBLCB0YWc6IFwid2hpbGVcIixjb25kOiBFeHByIDxBPiwgYm9keTogU3RtdDxBPltdfVxuICAgICAgICAgICAgdmFyIGNvbmR3aGlsZSA9IGNvZGVHZW5FeHByKHN0bXQuY29uZCwgbG9jYWxzKTtcbiAgICAgICAgICAgIHZhciB3aGlsZW91dCA9IGNvbmR3aGlsZS5jb25jYXQoW1wiKGlmXCJdKS5jb25jYXQoW1wiKHRoZW5cIl0pO1xuICAgICAgICAgICAgLy8gTmVlZCB0byBjaGVjayB0aGUgY29uZCBiZWZvcmUgZW50ZXIgdGhpcyBsb29wXG4gICAgICAgICAgICB3aGlsZW91dCA9IHdoaWxlb3V0LmNvbmNhdChbXCIobG9vcCAkbXlMb29wXCIuY29uY2F0KGxvb3BfY291bnRlcildKTtcbiAgICAgICAgICAgIHZhciBib2R5X3N0bXRzID0gc3RtdC5ib2R5Lm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gKGNvZGVHZW5TdG10KHMsIGxvY2FscywgZ2xvYmFsX3ZhcnMpKS5mbGF0KCkuam9pbihcIlxcblwiKTsgfSk7XG4gICAgICAgICAgICB3aGlsZW91dCA9IHdoaWxlb3V0LmNvbmNhdChib2R5X3N0bXRzKTtcbiAgICAgICAgICAgIHdoaWxlb3V0ID0gd2hpbGVvdXQuY29uY2F0KGNvbmR3aGlsZSkuY29uY2F0KFtcImJyX2lmICRteUxvb3BcIi5jb25jYXQobG9vcF9jb3VudGVyKV0pO1xuICAgICAgICAgICAgLy9FbmRsb29wXG4gICAgICAgICAgICB3aGlsZW91dCA9IHdoaWxlb3V0LmNvbmNhdChbXCIpXCJdKTtcbiAgICAgICAgICAgIC8vRW5kd2hpbGUoXG4gICAgICAgICAgICB3aGlsZW91dCA9IHdoaWxlb3V0LmNvbmNhdChbXCIpXCJdKS5jb25jYXQoW1wiKVwiXSk7XG4gICAgICAgICAgICBsb29wX2NvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiB3aGlsZW91dDtcbiAgICB9XG59XG5leHBvcnRzLmNvZGVHZW5TdG10ID0gY29kZUdlblN0bXQ7XG5mdW5jdGlvbiBjb21waWxlKHNvdXJjZSkge1xuICAgIHZhciBhc3QgPSAoMCwgcGFyc2VyXzEucGFyc2VQcm9ncmFtKShzb3VyY2UpO1xuICAgIG9ial9maWVsZF90eXBlX2lkeCA9IG5ldyBNYXAoKTtcbiAgICBjb25zb2xlLmxvZyhcInBhcnNlZCBwcm9ncmFtLCBhc3Q6XCIsIGFzdCk7XG4gICAgYXN0ID0gKDAsIHRjXzEudGNQcm9ncmFtKShhc3QpO1xuICAgIGNvbnNvbGUubG9nKFwiYWZ0ZXIgdGMsIGFzdDpcIiwgYXN0KTtcbiAgICBkZWNsX29mX2Z1bmNzID0gW107XG4gICAgdmFyIGVtcHR5RW52ID0gbmV3IE1hcCgpO1xuICAgIHRtcF92YXJzID0gW107XG4gICAgdmFyIF9hID0gdmFyc0Z1bnNTdG10cyhhc3QpLCB2YXJzID0gX2FbMF0sIGZ1bnMgPSBfYVsxXSwgc3RtdHMgPSBfYVsyXTtcbiAgICB2YXIgZnVuc0NvZGUgPSBmdW5zLm1hcChmdW5jdGlvbiAoZikgeyByZXR1cm4gY29kZUdlblN0bXQoZiwgZW1wdHlFbnYsIGVtcHR5RW52KTsgfSkubWFwKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLmpvaW4oXCJcXG5cIik7IH0pO1xuICAgIHZhciBhbGxGdW5zID0gZnVuc0NvZGUuam9pbihcIlxcblxcblwiKTtcbiAgICB2YXIgdmFyRGVjbHMgPSB2YXJzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gXCIoZ2xvYmFsICRcIi5jb25jYXQodiwgXCIgKG11dCBpMzIpIChpMzIuY29uc3QgMCkpXCIpOyB9KS5qb2luKFwiXFxuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiY29tcGlsZS1zdG10czpcIiwgc3RtdHMpO1xuICAgIHZhciBhbGxTdG10cyA9IHN0bXRzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gY29kZUdlblN0bXQocywgZW1wdHlFbnYsIGVtcHR5RW52KTsgfSkuZmxhdCgpO1xuICAgIHZhciBtYWluID0gX19zcHJlYWRBcnJheShbXCIobG9jYWwgJHNjcmF0Y2ggaTMyKVwiXSwgYWxsU3RtdHMsIHRydWUpLmpvaW4oXCJcXG5cIik7XG4gICAgdmFyIGxhc3RTdG10ID0gYXN0W2FzdC5sZW5ndGggLSAxXTtcbiAgICB2YXIgaXNFeHByID0gbGFzdFN0bXQudGFnID09PSBcImV4cHJcIjtcbiAgICB2YXIgcmV0VHlwZSA9IFwiXCI7XG4gICAgdmFyIHJldFZhbCA9IFwiXCI7XG4gICAgaWYgKGlzRXhwcikge1xuICAgICAgICByZXRUeXBlID0gXCIocmVzdWx0IGkzMilcIjtcbiAgICAgICAgcmV0VmFsID0gXCIobG9jYWwuZ2V0ICRzY3JhdGNoKVwiO1xuICAgIH1cbiAgICB2YXIgdG1wdmFyRGVjbHMgPSB0bXBfdmFycy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFwiKGdsb2JhbCAkXCIuY29uY2F0KHYsIFwiIChtdXQgaTMyKSAoaTMyLmNvbnN0IDApKVwiKTsgfSkuam9pbihcIlxcblwiKTtcbiAgICByZXR1cm4gXCJcXG4gICAgKG1vZHVsZVxcbiAgICAgIChmdW5jICRwcmludF9udW0gKGltcG9ydCBcXFwiaW1wb3J0c1xcXCIgXFxcInByaW50X251bVxcXCIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcXG4gICAgICAoZnVuYyAkcHJpbnRfYm9vbCAoaW1wb3J0IFxcXCJpbXBvcnRzXFxcIiBcXFwicHJpbnRfYm9vbFxcXCIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcXG4gICAgICAoZnVuYyAkcHJpbnRfbm9uZSAoaW1wb3J0IFxcXCJpbXBvcnRzXFxcIiBcXFwicHJpbnRfbm9uZVxcXCIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcXG4gICAgICAobWVtb3J5IChpbXBvcnQgXFxcImltcG9ydHNcXFwiIFxcXCJtZW1cXFwiKSAxKVxcbiAgICAgIChnbG9iYWwgJGhlYXAgKG11dCBpMzIpIChpMzIuY29uc3QgNCkpXFxuICAgICAgXCIuY29uY2F0KHZhckRlY2xzLCBcIlxcbiAgICAgIFwiKS5jb25jYXQodG1wdmFyRGVjbHMsIFwiXFxuICAgICAgXCIpLmNvbmNhdChkZWNsX29mX2Z1bmNzLCBcIlxcbiAgICAgIFwiKS5jb25jYXQoYWxsRnVucywgXCJcXG4gICAgICAoZnVuYyAoZXhwb3J0IFxcXCJfc3RhcnRcXFwiKSBcIikuY29uY2F0KHJldFR5cGUsIFwiXFxuICAgICAgICBcIikuY29uY2F0KG1haW4sIFwiXFxuICAgICAgICBcIikuY29uY2F0KHJldFZhbCwgXCJcXG4gICAgICApXFxuICAgICkgXFxuICBcIik7XG59XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlID0gZXhwb3J0cy50cmF2ZXJzZSA9IGV4cG9ydHMudHJhdmVyc2VBcmd1bWVudHMgPSBleHBvcnRzLnRyYXZlcnNlRXhwciA9IGV4cG9ydHMudHJhdmVyc2VQYXJhbWV0ZXJzID0gZXhwb3J0cy50cmF2ZXJzZVR5cGUgPSBleHBvcnRzLnRyYXZlcnNlU3RtdCA9IGV4cG9ydHMudHJhdmVyc2VTdG10cyA9IGV4cG9ydHMucGFyc2VQcm9ncmFtID0gdm9pZCAwO1xudmFyIGxlemVyX3B5dGhvbl8xID0gcmVxdWlyZShcImxlemVyLXB5dGhvblwiKTtcbnZhciBhc3RfMSA9IHJlcXVpcmUoXCIuL2FzdFwiKTtcbnZhciBzdXBwb3J0ZWRUeXBlcyA9IFtcImludFwiLCBcIm5vbmVcIiwgXCJib29sXCJdO1xudmFyIGNsc19uYW1lX3JlZyA9IFwibm9uZVwiO1xuZnVuY3Rpb24gcGFyc2VQcm9ncmFtKHNvdXJjZSkge1xuICAgIHZhciB0ID0gbGV6ZXJfcHl0aG9uXzEucGFyc2VyLnBhcnNlKHNvdXJjZSkuY3Vyc29yKCk7XG4gICAgcmV0dXJuIHRyYXZlcnNlU3RtdHMoc291cmNlLCB0KTtcbn1cbmV4cG9ydHMucGFyc2VQcm9ncmFtID0gcGFyc2VQcm9ncmFtO1xuZnVuY3Rpb24gdHJhdmVyc2VTdG10cyhzLCB0KSB7XG4gICAgLy8gVGhlIHRvcCBub2RlIGluIHRoZSBwcm9ncmFtIGlzIGEgU2NyaXB0IG5vZGUgd2l0aCBhIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICAvLyB0aGF0IGFyZSB2YXJpb3VzIHN0YXRlbWVudHNcbiAgICB0LmZpcnN0Q2hpbGQoKTtcbiAgICB2YXIgc3RtdHMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIHN0bXRzLnB1c2godHJhdmVyc2VTdG10KHMsIHQpKTtcbiAgICB9IHdoaWxlICh0Lm5leHRTaWJsaW5nKCkpOyAvLyB0Lm5leHRTaWJsaW5nKCkgcmV0dXJucyBmYWxzZSB3aGVuIGl0IHJlYWNoZXNcbiAgICAvLyAgdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgIHQucGFyZW50KCk7XG4gICAgcmV0dXJuIHN0bXRzO1xufVxuZXhwb3J0cy50cmF2ZXJzZVN0bXRzID0gdHJhdmVyc2VTdG10cztcbi8qXG4gIEludmFyaWFudCDigJMgdCBtdXN0IGZvY3VzIG9uIHRoZSBzYW1lIG5vZGUgYXQgdGhlIGVuZCBvZiB0aGUgdHJhdmVyc2FsXG4qL1xuZnVuY3Rpb24gdHJhdmVyc2VTdG10KHMsIHQpIHtcbiAgICBzd2l0Y2ggKHQudHlwZS5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJSZXR1cm5TdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyByZXR1cm4ga2V5d29yZFxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBleHByZXNzaW9uXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcInJldHVyblwiLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgY2FzZSBcIkFzc2lnblN0YXRlbWVudFwiOlxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIGZvY3VzZWQgb24gbmFtZSAodGhlIGZpcnN0IGNoaWxkKVxuICAgICAgICAgICAgdmFyIG5hbWUgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBmb2N1c2VkIG9uIDp0eXBlIHBhcnQsIGV4cGxhaW5lZCBpbiBDaG9jb3B5XG4gICAgICAgICAgICB2YXIgYW5ubyA9IHMuc3Vic3RyaW5nKHQuZnJvbSArIDEsIHQudG8pLnRyaW0oKTsgLy8gVXNlICsyIHRvIHNraXAgdGhlIDpcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gZm9jdXNlZCBvbiA9IHNpZ24uIE1heSBuZWVkIHRoaXMgZm9yIGNvbXBsZXggdGFza3MsIGxpa2UgKz0hXG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIGZvY3VzZWQgb24gdGhlIHZhbHVlIGV4cHJlc3Npb25cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFzc2lnbi1yZXR1cm46XCIsIHsgYTogYW5ubywgdGFnOiBcImFzc2lnblwiLCBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBhOiBhbm5vLCB0YWc6IFwiYXNzaWduXCIsIG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIFRoZSBjaGlsZCBpcyBzb21lIGtpbmQgb2YgZXhwcmVzc2lvbiwgdGhlXG4gICAgICAgICAgICAvLyBFeHByZXNzaW9uU3RhdGVtZW50IGlzIGp1c3QgYSB3cmFwcGVyIHdpdGggbm8gaW5mb3JtYXRpb25cbiAgICAgICAgICAgIHZhciBleHByID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJleHByXCIsIGV4cHI6IGV4cHIgfTtcbiAgICAgICAgY2FzZSBcIkZ1bmN0aW9uRGVmaW5pdGlvblwiOlxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIGRlZlxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBuYW1lIG9mIGZ1bmN0aW9uXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIFBhcmFtTGlzdFxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRyYXZlcnNlUGFyYW1ldGVycyhzLCB0KTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gQm9keSBvciBUeXBlRGVmXG4gICAgICAgICAgICB2YXIgcmV0ID0gXCJub25lXCI7XG4gICAgICAgICAgICB2YXIgbWF5YmVURCA9IHQ7XG4gICAgICAgICAgICBpZiAobWF5YmVURC50eXBlLm5hbWUgPT09IFwiVHlwZURlZlwiKSB7XG4gICAgICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7XG4gICAgICAgICAgICAgICAgcmV0ID0gdHJhdmVyc2VUeXBlKHMsIHQpO1xuICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIHNpbmdsZSBzdGF0ZW1lbnQgKGZvciBub3cpXG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb24gOlxuICAgICAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICh0Lm5leHRTaWJsaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBib2R5LnB1c2godHJhdmVyc2VTdG10KHMsIHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQucGFyZW50KCk7IC8vIFBvcCB0byBCb2R5XG4gICAgICAgICAgICB0LnBhcmVudCgpOyAvLyBQb3AgdG8gRnVuY3Rpb25EZWZpbml0aW9uXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhZzogXCJkZWZpbmVcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgcmV0OiByZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJDbGFzc0RlZmluaXRpb25cIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyBvbiBkZWZcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gbmFtZSBvZiBmdW5jdGlvblxuICAgICAgICAgICAgdmFyIG5hbWUgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgc3VwcG9ydGVkVHlwZXMucHVzaChuYW1lKTtcbiAgICAgICAgICAgIGNsc19uYW1lX3JlZyA9IG5hbWU7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIG9iamVjdCwgdGhlIG9yaWdpbmFsIHBhcmFtIGxpc3RcbiAgICAgICAgICAgIC8vbm8gcGFyYW1zIGhlcmUsIGFzIG9ubHkgXCJvYmplY3RcIiBpcyBhbGxvd2VkXG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIEJvZHkgb3IgVHlwZURlZlxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBzaW5nbGUgc3RhdGVtZW50IChmb3Igbm93KVxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIDpcbiAgICAgICAgICAgIHZhciB2YXJJbml0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNsc0JvZHkgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB3aGlsZSAodC5uZXh0U2libGluZygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsc19zdG10ID0gdHJhdmVyc2VTdG10KHMsIHQpO1xuICAgICAgICAgICAgICAgIGlmIChjbHNfc3RtdC50YWcgPT0gXCJkZWZpbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyB7IGE/OiBBLCB0YWc6IFwiY2xhc3NcIiwgbmFtZTpzdHJpbmcsIGZpZWxkczogU3RtdDxBPltdLCBtZXRob2RzOiBNYXAgPHN0cmluZywgRnVuRGVmPEE+Pn1cbiAgICAgICAgICAgICAgICAgICAgY2xzQm9keS5zZXQoY2xzX3N0bXQubmFtZSwgeyBuYW1lOiBjbHNfc3RtdC5uYW1lLCBwYXJhbXM6IGNsc19zdG10LnBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldDogY2xzX3N0bXQucmV0LCBpbml0czogdmFySW5pdHMsIGJvZHk6IGNsc19zdG10LmJvZHkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xzX3N0bXQudGFnID09IFwiYXNzaWduXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhckluaXRzLnB1c2goY2xzX3N0bXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUEFSU0VSIEVSUk9SOiB1bnN1cHBvcnRlZCBzdGF0ZW1lbnRzIHR5cGUgZm9yIGNsYXNzIGRlZmluaXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0LnBhcmVudCgpOyAvLyBQb3AgdG8gQm9keVxuICAgICAgICAgICAgdC5wYXJlbnQoKTsgLy8gUG9wIHRvIEZ1bmN0aW9uRGVmaW5pdGlvblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjbGFzc19uYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgY2xzX25hbWVfcmVnID0gXCJub25lXCI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGE6IG5hbWUsXG4gICAgICAgICAgICAgICAgdGFnOiBcImNsYXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHZhckluaXRzLFxuICAgICAgICAgICAgICAgIG1ldGhvZHM6IGNsc0JvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJQYXNzU3RhdGVtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwicGFzc1wiIH07XG4gICAgICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICB2YXIgY29uZF9leHByID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvL2ZvY3VzIG9uIGJvZHlcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvL2ZvY3VzIG9uIDpcbiAgICAgICAgICAgIHZhciBzdG10X2IgPSBbXTtcbiAgICAgICAgICAgIHZhciBlbHNlX3N0bXRfYiA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHQubmV4dFNpYmxpbmcoKSkge1xuICAgICAgICAgICAgICAgIHN0bXRfYi5wdXNoKHRyYXZlcnNlU3RtdChzLCB0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgaWYgKHQubm9kZS50eXBlLm5hbWUgPT09IFwiZWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvL2ZvY3VzIG9uIGJvZHlcbiAgICAgICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy9mb2N1cyBvbiA6XG4gICAgICAgICAgICAgICAgd2hpbGUgKHQubmV4dFNpYmxpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBlbHNlX3N0bXRfYi5wdXNoKHRyYXZlcnNlU3RtdChzLCB0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiaWZcIiwgY29uZDogY29uZF9leHByLCBib2R5OiBzdG10X2IsIGVsc2VfYm9keTogZWxzZV9zdG10X2IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcImlmXCIsIGNvbmQ6IGNvbmRfZXhwciwgYm9keTogc3RtdF9iLCBlbHNlX2JvZHk6IGVsc2Vfc3RtdF9iIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICB2YXIgY29uZF93aGlsZSA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy9mb2N1cyBvbiBib2R5XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy9mb2N1cyBvbiA6XG4gICAgICAgICAgICB2YXIgc3RtdF93ID0gW107XG4gICAgICAgICAgICB3aGlsZSAodC5uZXh0U2libGluZygpKSB7XG4gICAgICAgICAgICAgICAgc3RtdF93LnB1c2godHJhdmVyc2VTdG10KHMsIHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcIndoaWxlXCIsIGNvbmQ6IGNvbmRfd2hpbGUsIGJvZHk6IHN0bXRfdyB9O1xuICAgIH1cbn1cbmV4cG9ydHMudHJhdmVyc2VTdG10ID0gdHJhdmVyc2VTdG10O1xuZnVuY3Rpb24gdHJhdmVyc2VUeXBlKHMsIHQpIHtcbiAgICBzd2l0Y2ggKHQudHlwZS5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJWYXJpYWJsZU5hbWVcIjpcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgLy8gLy8gaWYobmFtZSAhPT0gXCJpbnRcIiAmJiBuYW1lICE9PVwibm9uZVwiICYmIG5hbWUgIT09IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAvLyBpZiAoIXN1cHBvcnRlZFR5cGVzLmluY2x1ZGVzKG5hbWUpKXtcbiAgICAgICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBWYXJpYWJsZU5hbWUgdHlwZTogXCIgKyBuYW1lKVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgdmFyIHJldHVybl9uYW1lID0gbmFtZV8xO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybl9uYW1lO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub24tVmFyaWFibGVOYW1lIHR5cGU6IFwiICsgdC50eXBlLm5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMudHJhdmVyc2VUeXBlID0gdHJhdmVyc2VUeXBlO1xuZnVuY3Rpb24gdHJhdmVyc2VQYXJhbWV0ZXJzKHMsIHQpIHtcbiAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXNlcyBvbiBvcGVuIHBhcmVuXG4gICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gYSBWYXJpYWJsZU5hbWVcbiAgICB3aGlsZSAodC50eXBlLm5hbWUgIT09IFwiKVwiKSB7XG4gICAgICAgIHZhciBuYW1lXzIgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gXCJUeXBlRGVmXCIsIGhvcGVmdWxseSwgb3IgXCIsXCIgaWYgbWlzdGFrZVxuICAgICAgICB2YXIgbmV4dFRhZ05hbWUgPSB0LnR5cGUubmFtZTsgLy8gTk9URShqb2UpOiBhIGJpdCBvZiBhIGhhY2sgc28gdGhlIG5leHQgbGluZSBkb2Vzbid0IGlmLXNwbGl0XG4gICAgICAgIGlmIChuZXh0VGFnTmFtZSAhPT0gXCJUeXBlRGVmXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NlZCB0eXBlIGFubm90YXRpb24gZm9yIHBhcmFtZXRlciBcIiArIG5hbWVfMik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRW50ZXIgVHlwZURlZlxuICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gdHlwZSBpdHNlbGZcbiAgICAgICAgdmFyIHR5cCA9IHRyYXZlcnNlVHlwZShzLCB0KTtcbiAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBNb3ZlIG9uIHRvIGNvbW1hIG9yIFwiKVwiXG4gICAgICAgIHBhcmFtZXRlcnMucHVzaCh7IG5hbWU6IG5hbWVfMiwgdHlwOiB0eXAgfSk7XG4gICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiBhIFZhcmlhYmxlTmFtZVxuICAgIH1cbiAgICB0LnBhcmVudCgpOyAvLyBQb3AgdG8gUGFyYW1MaXN0XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG5leHBvcnRzLnRyYXZlcnNlUGFyYW1ldGVycyA9IHRyYXZlcnNlUGFyYW1ldGVycztcbmZ1bmN0aW9uIHRyYXZlcnNlRXhwcihzLCB0KSB7XG4gICAgc3dpdGNoICh0LnR5cGUubmFtZSkge1xuICAgICAgICBjYXNlIFwiTm9uZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcIm5vbmVcIiB9O1xuICAgICAgICBjYXNlIFwiQm9vbGVhblwiOlxuICAgICAgICAgICAgaWYgKHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykgPT09IFwiVHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcInRydWVcIiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcImZhbHNlXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogTnVtYmVyKHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykpIH07XG4gICAgICAgIGNhc2UgXCJWYXJpYWJsZU5hbWVcIjpcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJpZFwiLCBuYW1lOiBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pIH07XG4gICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG5hbWVcbiAgICAgICAgICAgIHZhciBuYW1lID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgIGlmIChuYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqX3BhcnNlZCA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIEFyZ0xpc3RcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyBvcGVuIHBhcmVuXG4gICAgICAgICAgICB2YXIgYXJncyA9IHRyYXZlcnNlQXJndW1lbnRzKHQsIHMpO1xuICAgICAgICAgICAgdC5wcmV2U2libGluZygpO1xuICAgICAgICAgICAgaWYgKG5hbWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmpfcGFyc2VkLnRhZyA9PSBcImdldGZpZWxkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geyB0YWc6IFwibWV0aG9kXCIsIG9iajogb2JqX3BhcnNlZC5vYmosIG5hbWU6IG9ial9wYXJzZWQubmFtZSwgYXJnczogYXJncyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgdGFnOiBcImNhbGxcIiwgbmFtZTogbmFtZSwgYXJnczogYXJncyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgdmFyIHVvcCA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVvcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGlzX3ZhciA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfdmFyLnRhZyA9PSBcImlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0YWc6ICdiaW5vcCcsIG9wOiAnKicsIGxoczogeyBhOiBcImludFwiLCB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAtMSB9LCByaHM6IHRoaXNfdmFyIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9IE51bWJlcih1b3AgKyBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBBUlNFIEVSUk9SOiB1bmFyeSBvcGVyYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IG51bSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGlzX3ZhciA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfdmFyLnRhZyA9PSBcImlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0YWc6ICdiaW5vcCcsIG9wOiAnKicsIGxoczogeyBhOiBcImludFwiLCB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAxIH0sIHJoczogdGhpc192YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gTnVtYmVyKHVvcCArIHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUEFSU0UgRVJST1I6IHVuYXJ5IG9wZXJhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogbnVtIH07XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vdFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgbm90X3Jlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKSA9PT0gXCJUcnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdF9yZXN1bHQgPSB7IHRhZzogXCJmYWxzZVwiIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RfcmVzdWx0ID0geyB0YWc6IFwidHJ1ZVwiIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vdF9yZXN1bHQ7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUEFSU0UgRVJST1I6IHVuaW1wbGVtZW50ZWQgdW5hcnkgb3BcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gZ28gdG8gbGhzXG4gICAgICAgICAgICB2YXIgbGhzRXhwciA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gZ28gdG8gb3BcbiAgICAgICAgICAgIHZhciBvcFN0ciA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgICAgICBpZiAoISgwLCBhc3RfMS5pc09wKShvcFN0cikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yIHVuaGFuZGxlZCBvcDogXCIuY29uY2F0KG9wU3RyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIGdvIHRvIHJoc1xuICAgICAgICAgICAgdmFyIHJoc0V4cHIgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWc6IFwiYmlub3BcIixcbiAgICAgICAgICAgICAgICBvcDogb3BTdHIsXG4gICAgICAgICAgICAgICAgbGhzOiBsaHNFeHByLFxuICAgICAgICAgICAgICAgIHJoczogcmhzRXhwclxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gZm9jdXMgb24gKFxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgdmFyIHBhcmVuX2V4cCA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gZm9jdXMgb24gKVxuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbl9leHA7XG4gICAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy9mb2N1cyBvbiB2YXJpYWJsZSBuYW1lIGxpa2UgXCJjXCIsXCJzZWxmXCJcbiAgICAgICAgICAgIHZhciBjbHNfbmFtZSA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgICAgICB2YXIgY2xzX29iaiA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gZm9jdXMgb24gcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgdmFyIHByb3BlcnR5X25hbWUgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSBzZWxmIHdpdGggYSByZWdpc3RlclxuICAgICAgICAgICAgaWYgKGNsc19uYW1lID09IFwic2VsZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsc19uYW1lX3JlZyA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHNlbGYgaGVyZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsc19uYW1lID0gY2xzX25hbWVfcmVnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1lbWJlciBFeHByZXNzaW9uLCBvYmo6XCIuY29uY2F0KGNsc19vYmosIFwiLCBuYW1lOlwiKS5jb25jYXQocHJvcGVydHlfbmFtZSkpO1xuICAgICAgICAgICAgcmVzdWx0ID0geyB0YWc6IFwiZ2V0ZmllbGRcIiwgb2JqOiBjbHNfb2JqLCBuYW1lOiBwcm9wZXJ0eV9uYW1lIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlIFwic2VsZlwiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcInNlbGZcIiwgYTogeyB0YWc6IFwib2JqZWN0XCIsIGNsYXNzOiBjbHNfbmFtZV9yZWcgfSB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwcmVzc2lvbiBub3QgaW5jbHVkZWQgaW4gdHJhdmVyc2VFeHByOiBcIi5jb25jYXQodC50eXBlLm5hbWUsIFwiLCBcIikuY29uY2F0KHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykpKTtcbiAgICB9XG59XG5leHBvcnRzLnRyYXZlcnNlRXhwciA9IHRyYXZlcnNlRXhwcjtcbmZ1bmN0aW9uIHRyYXZlcnNlQXJndW1lbnRzKGMsIHMpIHtcbiAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXNlcyBvbiBvcGVuIHBhcmVuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgd2hpbGUgKGMudHlwZS5uYW1lICE9PSBcIilcIikge1xuICAgICAgICB2YXIgZXhwciA9IHRyYXZlcnNlRXhwcihzLCBjKTtcbiAgICAgICAgYXJncy5wdXNoKGV4cHIpO1xuICAgICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gZWl0aGVyIFwiLFwiIG9yIFwiKVwiXG4gICAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiBhIFZhcmlhYmxlTmFtZVxuICAgIH1cbiAgICBjLnBhcmVudCgpOyAvLyBQb3AgdG8gQXJnTGlzdFxuICAgIHJldHVybiBhcmdzO1xufVxuZXhwb3J0cy50cmF2ZXJzZUFyZ3VtZW50cyA9IHRyYXZlcnNlQXJndW1lbnRzO1xuZnVuY3Rpb24gdHJhdmVyc2UoYywgcykge1xuICAgIHN3aXRjaCAoYy5ub2RlLnR5cGUubmFtZSkge1xuICAgICAgICBjYXNlIFwiU2NyaXB0XCI6XG4gICAgICAgICAgICB2YXIgc3RtdHMgPSBbXTtcbiAgICAgICAgICAgIGMuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHN0bXRzLnB1c2godHJhdmVyc2VTdG10KHMsIGMpKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGMubmV4dFNpYmxpbmcoKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRyYXZlcnNlZCBcIiArIHN0bXRzLmxlbmd0aCArIFwiIHN0YXRlbWVudHMgXCIsIHN0bXRzLCBcInN0b3BwZWQgYXQgXCIsIGMubm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gc3RtdHM7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgcHJvZ3JhbSBhdCBcIiArIGMubm9kZS5mcm9tICsgXCIgXCIgKyBjLm5vZGUudG8pO1xuICAgIH1cbn1cbmV4cG9ydHMudHJhdmVyc2UgPSB0cmF2ZXJzZTtcbmZ1bmN0aW9uIHBhcnNlKHNvdXJjZSkge1xuICAgIHZhciB0ID0gbGV6ZXJfcHl0aG9uXzEucGFyc2VyLnBhcnNlKHNvdXJjZSk7XG4gICAgcmV0dXJuIHRyYXZlcnNlKHQuY3Vyc29yKCksIHNvdXJjZSk7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNMQVNTID0gZXhwb3J0cy5hc3NpZ25hYmxlVG8gPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy50Y0xpdGVyYWwgPSBleHBvcnRzLnRjUHJvZ3JhbSA9IGV4cG9ydHMudGNTdG10ID0gZXhwb3J0cy50Y0V4cHIgPSBleHBvcnRzLnRjUGFyYW1zID0gZXhwb3J0cy50Y1ZhckluaXRzID0gdm9pZCAwO1xudmFyIGFzdF8xID0gcmVxdWlyZShcIi4vYXN0XCIpO1xudmFyIGFzdF8yID0gcmVxdWlyZShcIi4vYXN0XCIpO1xudmFyIG9iakVudjtcbnZhciBvYmpfbmFtZV9yZWcgPSBcIm5vbmVcIjtcbmZ1bmN0aW9uIGR1cGxpY2F0ZUVudihlbnYpIHtcbiAgICByZXR1cm4geyB2YXJzOiBuZXcgTWFwKGVudi52YXJzKSwgZnVuczogbmV3IE1hcChlbnYuZnVucyksIHJldFR5cGU6IGVudi5yZXRUeXBlIH07XG59XG5mdW5jdGlvbiB0Y1ZhckluaXRzKGluaXRzLCBlbnYpIHtcbiAgICB2YXIgdHlwZWRJbml0cyA9IFtdO1xuICAgIGluaXRzLmZvckVhY2goZnVuY3Rpb24gKGluaXQpIHtcbiAgICAgICAgdmFyIHR5cGVkSW5pdCA9IHRjTGl0ZXJhbChpbml0LmluaXQpO1xuICAgICAgICBpZiAodHlwZWRJbml0LmEgIT09IGluaXQudHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IGluaXQgdHlwZSBkb2VzIG5vdCBtYXRjaCBsaXRlcmFsIHR5cGVcIik7XG4gICAgICAgIGVudi52YXJzLnNldChpbml0Lm5hbWUsIGluaXQudHlwZSk7XG4gICAgICAgIHR5cGVkSW5pdHMucHVzaChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5pdCksIHsgYTogaW5pdC50eXBlLCBpbml0OiB0eXBlZEluaXQgfSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0eXBlZEluaXRzO1xufVxuZXhwb3J0cy50Y1ZhckluaXRzID0gdGNWYXJJbml0cztcbmZ1bmN0aW9uIHRjUGFyYW1zKHBhcmFtcykge1xuICAgIHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtKSwgeyBhOiBwYXJhbS50eXBlIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy50Y1BhcmFtcyA9IHRjUGFyYW1zO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIHRjRnVuRGVmKGZ1bjpGdW5EZWY8YW55PiwgY2xzIDogQ2xhc3NFbnYsIGVudjogVHlwZUVudik6IEZ1bkRlZjxUeXBlPntcbi8vICAgY29uc3QgbG9jYWxFbnYgPSBkdXBsaWNhdGVFbnYoZW52KVxuLy8gICAvL2FkZCBwYXJhbXMgdG8gZW52XG4vLyAgIGZ1bi5wYXJhbXMuZm9yRWFjaChwYXJhbT0+e1xuLy8gICAgIGxvY2FsRW52LnZhcnMuc2V0KHBhcmFtLm5hbWUscGFyYW0udHlwZSk7XG4vLyAgIH0pXG4vLyAgIGNvbnN0IHR5cGVkUGFyYW1zID0gdGNQYXJhbXMoZnVuLnBhcmFtcyk7XG4vLyAgIC8vQWRkIGluaXRzXG4vLyAgIGNvbnN0IHR5cGVkSW5pdHMgPSB0Y1ZhckluaXRzKGZ1bi5pbml0cywgZW52KTtcbi8vICAgZnVuLmluaXRzLmZvckVhY2goaW5pdD0+e1xuLy8gICAgIGxvY2FsRW52LnZhcnMuc2V0KGluaXQubmFtZSxpbml0LnR5cGUpO1xuLy8gICB9KVxuLy8gICBsb2NhbEVudi5mdW5zLnNldChmdW4ubmFtZSxbZnVuLnBhcmFtcy5tYXAocGFyYW09PnBhcmFtLnR5cGUpLCBmdW4ucmV0XSk7XG4vLyAgIC8vQ2hlY2sgYm9keVxuLy8gICBjb25zdCB0eXBlZFN0bXRzID0gdGNTdG10KGZ1bi5ib2R5LGNscyxsb2NhbEVudi5mdW5zLGxvY2FsRW52LnZhcnMsbG9jYWxFbnYucmV0VHlwZSk7XG4vLyAgIHJldHVybiB7Li4uZnVuLHBhcmFtczogdHlwZWRQYXJhbXMsIGluaXRzOnR5cGVkSW5pdHMsIGJvZHk6dHlwZWRTdG10c307XG4vLyB9XG5mdW5jdGlvbiB0Y0V4cHIoZSwgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgZW1wdHlFbnYgPSBuZXcgTWFwKCk7XG4gICAgc3dpdGNoIChlLnRhZykge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6IHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJpbnRcIiB9KTtcbiAgICAgICAgY2FzZSBcInRydWVcIjogcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImJvb2xcIiB9KTtcbiAgICAgICAgY2FzZSBcImZhbHNlXCI6IHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJib29sXCIgfSk7XG4gICAgICAgIGNhc2UgXCJub25lXCI6IHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJub25lXCIgfSk7XG4gICAgICAgIGNhc2UgXCJiaW5vcFwiOiB7XG4gICAgICAgICAgICAvLyBXZSBjdXJyZW50bHkgZW5mb3JjZSB0aGUgbGhzIGFuZCByaHMgbXVzdCBiZSBpbnRcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGNFeHByKGUubGhzLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0Y0V4cHIoZS5yaHMsIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIGUubGhzID0gbGVmdDtcbiAgICAgICAgICAgIGUucmhzID0gcmlnaHQ7XG4gICAgICAgICAgICBpZiAoZS5vcCA9PSAnaXMnKSB7XG4gICAgICAgICAgICAgICAgLy8gXCJpc1wiIG9wZXJhdG9yIGxvZ2ljXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJpcyBvcCwgbGVmdCwgcmlnaHRcIiwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0LmEgPT0gXCJpbnRcIiB8fCBsZWZ0LmEgPT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogTEhTIG9mICdpcycgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5hID09IFwiaW50XCIgfHwgcmlnaHQuYSA9PSBcImJvb2xcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBSSFMgb2YgJ2lzJyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImJvb2xcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgYXN0XzIuaXNpbnRPcCkoZS5vcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5saHMuYSAhPSBcImludFwiIHx8IGUucmhzLmEgIT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRDIFZhcmlhYmxlc1wiLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBMSFMsUkhTIG9mIFwiLmNvbmNhdChlLm9wLCBcIiBtdXN0IGJlIGJvdGggaW50LCBpbnN0ZWFkLCB3ZSBoYXZlIFwiKS5jb25jYXQoZS5saHMuYSwgXCIsXCIpLmNvbmNhdChlLnJocy5hKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXR1cm5fYm9vbF9vcHMgPSBbXCI+XCIsIFwiPFwiLCBcIj49XCIsIFwiPD1cIl07XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmV0dXJuX2Jvb2xfb3BzLmluY2x1ZGVzKGUub3ApKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuX2Jvb2xfb3BzLmluY2x1ZGVzKGUub3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJib29sXCIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJpbnRcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgYXN0XzIuaXNib29sT3ApKGUub3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmxocy5hICE9IFwiYm9vbFwiIHx8IGUucmhzLmEgIT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IExIUyxSSFMgb2YgXCIuY29uY2F0KGUub3AsIFwiIG11c3QgYmUgYm90aCBib29sLCBpbnN0ZWFkLCB3ZSBoYXZlIFwiKS5jb25jYXQoZS5saHMuYSwgXCIsXCIpLmNvbmNhdChlLnJocy5hKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImJvb2xcIiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgYXN0XzEuaXNzYW1lT3ApKGUub3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5saHMuYSA9PSBlLnJocy5hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImJvb2xcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IExIUyxSSFMgb2YgXCIuY29uY2F0KGUub3AsIFwiIG11c3QgYmUgb2Ygc2FtZSB0eXBlLCBpbnN0ZWFkLCB3ZSBoYXZlIFwiKS5jb25jYXQoZS5saHMuYSwgXCIsXCIpLmNvbmNhdChlLnJocy5hKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBbdGMudHNdVW5oYW5kbGVkIGJpbmFyeSBvcCBcIi5jb25jYXQoZS5vcCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJpZFwiOiByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IHZhcmlhYmxlcy5nZXQoZS5uYW1lKSB9KTtcbiAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoZS5uYW1lID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5hcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBwcmludCBleHBlY3RzIGEgc2luZ2xlIGFyZ3VtZW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV3QXJnc18xID0gW3RjRXhwcihlLmFyZ3NbMF0sIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzKV07XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcIm5vbmVcIiwgYXJnczogbmV3QXJnc18xIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xhc3Nlcy5oYXMoZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIENhbGxpbmcgY2xhc3MoKVxuICAgICAgICAgICAgICAgIHZhciBjbGFzc19zdG10ID0gY2xhc3Nlcy5nZXQoZS5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3Nfc3RtdC50YWcgIT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IFZhcmlhYmxlIFwiLmNvbmNhdChlLm5hbWUsIFwiIHNob3VsZCBiZSBhIGNsYXNzLCBob3dldmVyIGl0cyB0YWcgaXMgbm90XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzX3N0bXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKHZpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmkudGFnICE9IFwiYXNzaWduXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBmaWVsZHMgd2l0aCBub24tYXNzaWduIHRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmpfbmFtZV9yZWcgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9Db21lb24hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMuc2V0KFwiXCIuY29uY2F0KG9ial9uYW1lX3JlZywgXCIuXCIpLmNvbmNhdCh2aS5uYW1lKSwgdmkuYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXBwZW5kIHRoaXMgZW50cnk6IFwiLmNvbmNhdChvYmpfbmFtZV9yZWcsIFwiLlwiKS5jb25jYXQodmkubmFtZSwgXCIgdG8gdmFyaWFibGVzXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IHsgdGFnOiBcIm9iamVjdFwiLCBjbGFzczogY2xhc3Nfc3RtdC5uYW1lIH0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvbnMuaGFzKGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogZnVuY3Rpb24gXCIuY29uY2F0KGUubmFtZSwgXCIgbm90IGZvdW5kXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZnVuY3Rpb25zLmdldChlLm5hbWUpLCBhcmdzID0gX2FbMF0sIHJldCA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gZS5hcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBUQy1jYWxsLWZ1bmN0aW9uOkV4cGVjdGVkIFwiLmNvbmNhdChhcmdzLmxlbmd0aCwgXCIgYXJndW1lbnRzIGJ1dCBnb3QgXCIpLmNvbmNhdChlLmFyZ3MubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXdBcmdzXzIgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJndHlwID0gdGNFeHByKGUuYXJnc1tpXSwgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSAhPT0gYXJndHlwLmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IEdvdCBcIi5jb25jYXQoYXJndHlwLCBcIiBhcyBhcmd1bWVudCBcIikuY29uY2F0KGkgKyAxLCBcIiwgZXhwZWN0ZWQgXCIpLmNvbmNhdChhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3R5cDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogcmV0LCBhcmdzOiBuZXdBcmdzXzIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlIFwibGl0ZXJhbFwiOlxuICAgICAgICAgICAgZS5saXRlcmFsID0gdGNMaXRlcmFsKGUubGl0ZXJhbCk7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IGUubGl0ZXJhbC5hIH0pO1xuICAgICAgICBjYXNlIFwiYnVpbHRpbjJcIjpcbiAgICAgICAgICAgIHZhciBhcmcxID0gdGNFeHByKGUuYXJnMSwgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgdmFyIGFyZzIgPSB0Y0V4cHIoZS5hcmcyLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICBpZiAoYXJnMS5hICE9IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBMZWZ0IG11c3QgYmUgaW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZzIuYSAhPSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogUmlnaHQgbXVzdCBiZSBpbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiaW50XCIgfSk7XG4gICAgICAgIGNhc2UgXCJtZXRob2RcIjpcbiAgICAgICAgICAgIHZhciBuZXdPYmogPSB0Y0V4cHIoZS5vYmosIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIHZhciBuZXdBcmdzO1xuICAgICAgICAgICAgaWYgKG5ld09iai5hICE9IFwiaW50XCIgJiYgbmV3T2JqLmEgIT0gXCJib29sXCIgJiYgbmV3T2JqLmEgIT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3T2JqLmEudGFnICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiTm9uLW9iamVjdCB0eXBlIGluIG1ldGhvZCBjYWxsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2xhc3Nlcy5oYXMobmV3T2JqLmEuY2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiQ29tcGlsZXIgZXJyb3IsIG5vIHN1Y2ggY2xhc3NcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzZGF0YSA9IGNsYXNzZXMuZ2V0KG5ld09iai5hLmNsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NkYXRhLnRhZyA9PSBcImNsYXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGFzc2RhdGEubWV0aG9kcy5oYXMoZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJObyBzdWNoIG1ldGhvZFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld0FyZ3MgPSBlLmFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiB0Y0V4cHIoYSwgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNmdW4gPSBjbGFzc2RhdGEubWV0aG9kcy5nZXQoZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ1R5cHMgPSB0aGlzZnVuLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldFR5cGUgPSB0aGlzZnVuLnJldDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSB3ZSBtdXN0IGlnbm9yZSBzZWxmIGJ5IGFkZGluZyAxIHRvIHRoZSByaHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ1R5cHMubGVuZ3RoICE9PSBuZXdBcmdzLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwidGM6IG1ldGhvZCBhcmcgbWlzbWF0Y2hcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdUeXBzLmZvckVhY2goZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh0LnR5cCkgJiYgIXQudHlwLmhhc093blByb3BlcnR5KCd0YWcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQudHlwID0geyB0YWc6IFwib2JqZWN0XCIsIGNsYXNzOiBTdHJpbmcodC50eXApIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5uYW1lICE9IFwic2VsZlwiICYmICFhc3NpZ25hYmxlVG8odC50eXAsIG5ld0FyZ3NbaSAtIDFdLmEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogQXJnIFR5cGVzIG1pc21hdGNoIGZvciBcIi5jb25jYXQodC50eXAsIFwiIGFuZCBcIikuY29uY2F0KG5ld0FyZ3NbaSAtIDFdLmEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlRhZyBzYXlzIFwiLmNvbmNhdChlLm5hbWUsIFwiIGlzIGEgbWV0aG9kLCBidXQgYW5ub3RhdGlvbiBzYXlzIGl0IGlzbid0IGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3T2JqLmEgPT0gXCJib29sXCIgfHwgbmV3T2JqLmEgPT0gXCJpbnRcIiB8fCBuZXdPYmouYSA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSVU5USU1FIEVSUk9SOiBUaGUgVHlwZSBvZiBcIi5jb25jYXQoZS5vYmosIFwiIHNob3VsZCBiZSBhbiBvYmosIGluc3RlYWQgaXQgaXMgYSBcIikuY29uY2F0KG5ld09iai5hKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHJldFR5cGUpICYmICFyZXRUeXBlLmhhc093blByb3BlcnR5KCd0YWcnKSkge1xuICAgICAgICAgICAgICAgIC8vSnVzdCBhIG5vcm1hbCBzdHJpbmdcbiAgICAgICAgICAgICAgICByZXRUeXBlID0geyB0YWc6IFwib2JqZWN0XCIsIGNsYXNzOiBTdHJpbmcocmV0VHlwZSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogcmV0VHlwZSwgb2JqOiBuZXdPYmosIGFyZ3M6IG5ld0FyZ3MgfSk7XG4gICAgICAgIGNhc2UgXCJnZXRmaWVsZFwiOlxuICAgICAgICAgICAgdmFyIGNsc19uYW1lO1xuICAgICAgICAgICAgc3dpdGNoIChlLm9iai50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9ial90eXBlID0gb2JqRW52LmdldChlLm9iai5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ial90eXBlID09IFwiYm9vbFwiIHx8IG9ial90eXBlID09IFwiaW50XCIgfHwgb2JqX3R5cGUgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJVTlRJTUUgRVJST1I6IFRoZSBUeXBlIG9mIFwiLmNvbmNhdChlLm9iai5uYW1lLCBcIiBzaG91bGQgYmUgYW4gb2JqXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsc19uYW1lID0gb2JqX3R5cGUuY2xhc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlbGZcIjpcbiAgICAgICAgICAgICAgICAgICAgY2xzX25hbWUgPSBlLm9iai5hLmNsYXNzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0ZmllbGRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUub2JqLmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldF9jbGFzcyA9IG9iakVudi5nZXQoZS5vYmoubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0X2NsYXNzID09IFwiYm9vbFwiIHx8IGdldF9jbGFzcyA9PSBcImludFwiIHx8IGdldF9jbGFzcyA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IFdlaXJkLiBDbGFzcyBTdGF0ZW1lbnQgXCIuY29uY2F0KGNsc19zdG10LCBcIiBoYXMgdGFnIFwiKS5jb25jYXQoY2xzX3N0bXQudGFnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHNfbmFtZSA9IGdldF9jbGFzcy5jbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsc19uYW1lID0gZS5vYmouYS5jbGFzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGNsc19uYW1lID0gZS5vYmouYS5jbGFzcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogdGM6IGdldGZpZWxkLCBub3QgYSBzdXBwb3J0ZWQgZGF0YXR5cGUsYnV0IFwiLmNvbmNhdChlLm9iai50YWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbHNfc3RtdCA9IGNsYXNzZXMuZ2V0KGNsc19uYW1lKTtcbiAgICAgICAgICAgIHdoaWxlIChjbHNfc3RtdC50YWcgPT0gXCJhc3NpZ25cIikge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGNsc19zdG10XG4gICAgICAgICAgICAgICAgY2xzX3N0bXQgPSBjbGFzc2VzLmdldChjbHNfc3RtdC5hLmNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbHNfc3RtdC50YWcgIT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUWVBFIEVSUk9SOiB0Yzogc3RhdGVtZW50IGlzIG5vdCBjbGFzcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFubm87XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRyeSB0byBmaW5kIHR5cGUgZnJvbSB0aGlzIGNscyBzdF9tdCBcIi5jb25jYXQoY2xzX3N0bXQpKTtcbiAgICAgICAgICAgIGNsc19zdG10LmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxkLnRhZyA9PSBcImFzc2lnblwiICYmIGZsZC5uYW1lID09IGUubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmbGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImZpbmQgdHlwZSBcIi5jb25jYXQoZmxkLmEsIFwiIGZvciBcIikuY29uY2F0KGUubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBhbm5vID0gZmxkLmE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IGFubm8gfSk7XG4gICAgICAgIGNhc2UgXCJzZWxmXCI6XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIGUpO1xuICAgIH1cbn1cbmV4cG9ydHMudGNFeHByID0gdGNFeHByO1xuZnVuY3Rpb24gdGNTdG10KHMsIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzLCBjdXJyZW50UmV0dXJuKSB7XG4gICAgY29uc29sZS5sb2coXCJ0Y1N0bXRcIiwgcyk7XG4gICAgc3dpdGNoIChzLnRhZykge1xuICAgICAgICBjYXNlIFwiYXNzaWduXCI6IHtcbiAgICAgICAgICAgIHZhciBzZWxmX2ZsYWcgPSAwO1xuICAgICAgICAgICAgaWYgKHMudmFsdWUudGFnID09IFwiY2FsbFwiICYmIGNsYXNzZXMuaGFzKHMudmFsdWUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNldCBPTlIgdG8gXCIuY29uY2F0KHMubmFtZSkpO1xuICAgICAgICAgICAgICAgIG9ial9uYW1lX3JlZyA9IHMubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqX3R5cGUgPSBjbGFzc2VzLmdldChzLnZhbHVlLm5hbWUpLmE7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9ial90eXBlKSAmJiAhb2JqX3R5cGUuaGFzT3duUHJvcGVydHkoJ3RhZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ial90eXBlID0gQ0xBU1Mob2JqX3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmpFbnYuc2V0KHMubmFtZSwgb2JqX3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYXNzIHRoZSBjYWxsIGNsYXNzIGNoZWNrXCIpO1xuICAgICAgICAgICAgdmFyIHJocyA9IHRjRXhwcihzLnZhbHVlLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICBpZiAocy5hID09PSAnJykge1xuICAgICAgICAgICAgICAgIGlmIChzLm5hbWUuc3RhcnRzV2l0aCgnc2VsZi4nKSkge1xuICAgICAgICAgICAgICAgICAgICBzLm5hbWUgPSBzLm5hbWUuc3BsaXQoJy4nLCAyKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZl9mbGFnID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlcy5oYXMocy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImdldF9uYW1lXCIsIHZhcmlhYmxlcy5nZXQocy5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIHMuYSA9IHZhcmlhYmxlcy5nZXQocy5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJVTlRJTUUgRVJST1I6IENhbm5vdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIFwiLmNvbmNhdChzLm5hbWUsIFwiIGJlZm9yZSBpdHMgZGVjbGFyYXRpb25cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGNTdG10LWFzc2lnblwiLCBzLmEsIHJocy5hKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXNzaWduYWJsZT9cIiwgYXNzaWduYWJsZVRvKHMuYSwgcmhzLmEpKTtcbiAgICAgICAgICAgIGlmIChzLmEgPT0gXCJub25lXCIgJiYgaXNPYmplY3QocmhzLmEpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY2xhc3MgdHlwZSBvZiBsaHMscmhzXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBc3NpZ24gY2xhc3MgdG8gbm9uZSwgd2l0aCBjbGFzc2VzXCIsIGNsYXNzZXMpO1xuICAgICAgICAgICAgICAgIHZhciBjbHNfdHlwID0gb2JqRW52LmdldChzLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghYXNzaWduYWJsZVRvKGNsc190eXAsIHJocy5hKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBDbGFzcyBNaXNtYXRjaDogVHJ5IHRvIGFzc2lnbiBcIi5jb25jYXQocmhzLmEsIFwiIHRvIFwiKS5jb25jYXQocy5uYW1lLCBcIiwgd2hpY2ggaXMgdHlwZSBcIikuY29uY2F0KGNsc190eXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFzc2lnbmFibGVUbyhzLmEsIHJocy5hKSkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgYW4gZXhlbXB0aW9uIGZvciBhc3NpZ24gXCJub25lXCIgdG8gXCJvYmpcIlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IENhbm5vdCBhc3NpZ24gXCIuY29uY2F0KHJocy5hLCBcIiB0byBcIikuY29uY2F0KHMubmFtZSwgXCIsIHdoaWNoIHJlcXVpcmVzIFwiKS5jb25jYXQocy5hKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmhzLmEgPT0gXCJub25lXCIgJiYgaXNPYmplY3Qocy5hKSkge1xuICAgICAgICAgICAgICAgICAgICBzLmEgPSB7IHRhZzogXCJvYmplY3RcIiwgY2xhc3M6IHMuYSB9O1xuICAgICAgICAgICAgICAgICAgICBvYmpFbnYuc2V0KHMubmFtZSwgcy5hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFyaWFibGVzLmhhcyhzLm5hbWUpICYmICFhc3NpZ25hYmxlVG8odmFyaWFibGVzLmdldChzLm5hbWUpLCByaHMuYSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBcIi5jb25jYXQocy5uYW1lLCBcIiBhbHJlYWR5IGRlY2xhcmVkLCB3aGljaCByZXF1aXJlcyBcIikuY29uY2F0KHMuYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJocy5hID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXNzaWduIE5vbmUgUmVzdWx0XCIsIHZhcmlhYmxlcy5nZXQocy5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcy5zZXQocy5uYW1lLCByaHMuYSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gY2hhbmdlIHMuYSBoZXJlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMuc2V0KHMubmFtZSwgcmhzLmEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh2YXJpYWJsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xhc3Nlcy5zZXQocy5uYW1lLHMpO1xuICAgICAgICAgICAgaWYgKHNlbGZfZmxhZyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcy5uYW1lID0gJ3NlbGYuJyArIHMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGZfZmxhZyA9IDA7XG4gICAgICAgICAgICBvYmpfbmFtZV9yZWcgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcyksIHsgdmFsdWU6IHJocyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZGVmaW5lXCI6IHtcbiAgICAgICAgICAgIHZhciBib2R5dmFyc18xID0gbmV3IE1hcCh2YXJpYWJsZXMuZW50cmllcygpKTtcbiAgICAgICAgICAgIHMucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgYm9keXZhcnNfMS5zZXQocC5uYW1lLCBwLnR5cCk7IH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJkZWZpbmUtcy5ib2R5XCIsIHMuYm9keSk7XG4gICAgICAgICAgICB2YXIgcmV0dXJuX2ZsYWcgPSAwO1xuICAgICAgICAgICAgdmFyIG5ld1N0bXRzID0gcy5ib2R5Lm1hcChmdW5jdGlvbiAoYnMpIHsgcmV0dXJuIHRjU3RtdChicywgY2xhc3NlcywgZnVuY3Rpb25zLCBib2R5dmFyc18xLCBzLnJldCk7IH0pO1xuICAgICAgICAgICAgaWYgKHMucmV0ICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgcy5ib2R5LmZvckVhY2goZnVuY3Rpb24gKGJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChicy50YWcgPT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuX2ZsYWcgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybl9mbGFnID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogXCIuY29uY2F0KHMucmV0LCBcIiBuZXZlciByZXR1cm5zXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHMpLCB7IGJvZHk6IG5ld1N0bXRzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjbGFzc1wiOiB7XG4gICAgICAgICAgICB2YXIgYm9keXZhcnMgPSBuZXcgTWFwKHZhcmlhYmxlcy5lbnRyaWVzKCkpO1xuICAgICAgICAgICAgcy5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAodmkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGNfdmkgPSB0Y1N0bXQodmksIGNsYXNzZXMsIGZ1bmN0aW9ucywgYm9keXZhcnMsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodmkudGFnICE9IFwiYXNzaWduXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogdmkgXCIuY29uY2F0KHZpLCBcIidzIHRhZyBpcyBub3QgYXNzaWduXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHl2YXJzLnNldCh2aS5uYW1lLCB0Y192aS5hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicy1maWVsZHM6XCIsIHMuZmllbGRzKTtcbiAgICAgICAgICAgIHZhciBuZXdfbWV0aG9kcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHMubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZHMsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlja2V5IEhlcmUsbWRzIGhlcmUgaXMgdGhlIEZ1bkRlZlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1kcyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobWRzLmJvZHkpO1xuICAgICAgICAgICAgICAgIHZhciBzdG10X2Zyb21fbWRzID0geyBhOiBtZHMuYSwgdGFnOiBcImRlZmluZVwiLCBuYW1lOiBtZHMubmFtZSwgcGFyYW1zOiBtZHMucGFyYW1zLCByZXQ6IG1kcy5yZXQsIGJvZHk6IG1kcy5ib2R5IH07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRjU3RtdChzdG10X2Zyb21fbWRzLCBjbGFzc2VzLCBmdW5jdGlvbnMsIGJvZHl2YXJzLCBtZHMucmV0KTtcbiAgICAgICAgICAgICAgICB2YXIgbWRzX2Zyb21fc3RtdCA9IHsgYTogcmVzdWx0LmEsIG5hbWU6IG1kcy5uYW1lLCBwYXJhbXM6IG1kcy5wYXJhbXMsIHJldDogbWRzLnJldCwgaW5pdHM6IG1kcy5pbml0cywgYm9keTogbWRzLmJvZHkgfTtcbiAgICAgICAgICAgICAgICBuZXdfbWV0aG9kcy5zZXQobmFtZSwgbWRzX2Zyb21fc3RtdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHMubWV0aG9kcyA9IG5ld19tZXRob2RzO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzKSwgeyBhOiBcIm5vbmVcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXhwclwiOiB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdGNFeHByKHMuZXhwciwgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzKSwgeyBleHByOiByZXQsIGE6IHJldC5hIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZXR1cm5cIjoge1xuICAgICAgICAgICAgdmFyIHZhbFR5cCA9IHRjRXhwcihzLnZhbHVlLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoY3VycmVudFJldHVybikpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmV0dXJuID0geyB0YWc6IFwib2JqZWN0XCIsIGNsYXNzOiBTdHJpbmcoY3VycmVudFJldHVybikgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXNzaWduYWJsZVRvKGN1cnJlbnRSZXR1cm4sIHZhbFR5cC5hKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IFwiLmNvbmNhdCh2YWxUeXAsIFwiIHJldHVybmVkIGJ1dCBcIikuY29uY2F0KGN1cnJlbnRSZXR1cm4sIFwiIGV4cGVjdGVkLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHMpLCB7IHZhbHVlOiB2YWxUeXAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhc3NcIjoge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCBzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaWZcIjoge1xuICAgICAgICAgICAgdmFyIGNvbmQgPSB0Y0V4cHIocy5jb25kLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICBpZiAoY29uZC5hICE9IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogXCIuY29uY2F0KGNvbmQsIFwiIG11c3QgYmUgYSBib29sLCBpbnN0ZWFkIGl0IGlzIG5vdyBcIikuY29uY2F0KGNvbmQuYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld19iZF9zdCA9IHMuYm9keS5tYXAoZnVuY3Rpb24gKGJzKSB7IHJldHVybiB0Y1N0bXQoYnMsIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzLCBjdXJyZW50UmV0dXJuKTsgfSk7XG4gICAgICAgICAgICBpZiAocy5lbHNlX2JvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzKSwgeyBjb25kOiBjb25kLCBib2R5OiBuZXdfYmRfc3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3X2Vsc2ViZF9zdCA9IHMuZWxzZV9ib2R5Lm1hcChmdW5jdGlvbiAoYnMpIHsgcmV0dXJuIHRjU3RtdChicywgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMsIGN1cnJlbnRSZXR1cm4pOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHMpLCB7IGNvbmQ6IGNvbmQsIGJvZHk6IG5ld19iZF9zdCwgZWxzZV9ib2R5OiBuZXdfZWxzZWJkX3N0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ3aGlsZVwiOiB7XG4gICAgICAgICAgICB2YXIgY29uZCA9IHRjRXhwcihzLmNvbmQsIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIGlmIChjb25kLmEgIT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBcIi5jb25jYXQoY29uZCwgXCIgbXVzdCBiZSBhIGJvb2wsIGluc3RlYWQgaXQgaXMgbm93IFwiKS5jb25jYXQoY29uZC5hKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3X2JkX3N0ID0gcy5ib2R5Lm1hcChmdW5jdGlvbiAoYnMpIHsgcmV0dXJuIHRjU3RtdChicywgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMsIGN1cnJlbnRSZXR1cm4pOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcyksIHsgY29uZDogY29uZCwgYm9keTogbmV3X2JkX3N0IH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy50Y1N0bXQgPSB0Y1N0bXQ7XG5mdW5jdGlvbiB0Y1Byb2dyYW0ocCkge1xuICAgIGNvbnNvbGUubG9nKFwidGNwcm9ncmFtLHBcIiwgcCk7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgY2xhc3NlcyA9IG5ldyBNYXAoKTtcbiAgICBvYmpFbnYgPSBuZXcgTWFwKCk7XG4gICAgcC5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGlmIChzLnRhZyA9PT0gXCJkZWZpbmVcIikge1xuICAgICAgICAgICAgZnVuY3Rpb25zLnNldChzLm5hbWUsIFtzLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudHlwOyB9KSwgcy5yZXRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy50YWcgPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgY2xhc3Nlcy5zZXQocy5uYW1lLCBzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBnbG9iYWxzID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiBwLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICBpZiAocy50YWcgPT09IFwiYXNzaWduXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHNtYXAsIGNoZWNrIGFzc2lnblwiLCBzLnZhbHVlKTtcbiAgICAgICAgICAgIHZhciByaHMgPSB0Y0V4cHIocy52YWx1ZSwgY2xhc3NlcywgZnVuY3Rpb25zLCBnbG9iYWxzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHNtYXAsIHJoczpcIiwgcmhzKTtcbiAgICAgICAgICAgIHZhciB0Y19zID0gdGNTdG10KHMsIGNsYXNzZXMsIGZ1bmN0aW9ucywgZ2xvYmFscywgcmhzLmEpO1xuICAgICAgICAgICAgLy8gZ2xvYmFscy5zZXQocy5uYW1lLCByaHMuYSk7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHMpLCB7IHZhbHVlOiByaHMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gdGNTdG10KHMsIGNsYXNzZXMsIGZ1bmN0aW9ucywgZ2xvYmFscywgXCJub25lXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy50Y1Byb2dyYW0gPSB0Y1Byb2dyYW07XG5mdW5jdGlvbiB0Y0xpdGVyYWwobGl0ZXJhbCkge1xuICAgIHN3aXRjaCAobGl0ZXJhbC50YWcpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBsaXRlcmFsKSwgeyBhOiBcImludFwiIH0pO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBsaXRlcmFsKSwgeyBhOiBcImJvb2xcIiB9KTtcbiAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbGl0ZXJhbCksIHsgYTogXCJub25lXCIgfSk7XG4gICAgfVxufVxuZXhwb3J0cy50Y0xpdGVyYWwgPSB0Y0xpdGVyYWw7XG5mdW5jdGlvbiBpc09iamVjdCh0cCkge1xuICAgIHJldHVybiAhKHRwID09IFwiaW50XCIgfHwgdHAgPT0gXCJib29sXCIgfHwgdHAgPT0gXCJub25lXCIpO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZnVuY3Rpb24gYXNzaWduYWJsZVRvKHR5cGVfYSwgdHlwZV9iKSB7XG4gICAgLy8gUnVsZSBOby4wOiBpZiBzdHJpY3RseSBlcXVhbCwgYWxsb3chXG4gICAgaWYgKHR5cGVfYiA9PT0gdHlwZV9hKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBSdWxlIE5vLjE6IE5vbmUgaXMgYWJsZSB0byBiZSBhc3NpZ25lZCB0byBldmVyeW9uZS5cbiAgICBpZiAodHlwZV9iID09IFwibm9uZVwiKSB7XG4gICAgICAgIC8vIFZlcnkgVHJpY2t5IGhlcmUsbXVzdCBiZSBmaXhlZCBsYXRlclxuICAgICAgICByZXR1cm4gaXNPYmplY3QodHlwZV9hKTtcbiAgICB9XG4gICAgLy8gUnVsZSBObzEuNSBPYmplY3QgaXMgYXNzaWduYWJsZSB0byBOb25lXG4gICAgaWYgKHR5cGVfYSA9PSBcIm5vbmVcIiAmJiBpc09iamVjdCh0eXBlX2IpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBSdWxlIE5vLjI6IE9ubHkgT2JqZWN0IGlzIGFsbG93ZWQgdG8gYXNzaWduIG9iamVjdC5cbiAgICBpZiAodHlwZV9iICE9IFwiaW50XCIgJiYgdHlwZV9iICE9IFwiYm9vbFwiKSB7XG4gICAgICAgIGlmICh0eXBlX2EgIT0gXCJpbnRcIiAmJiB0eXBlX2EgIT0gXCJub25lXCIgJiYgdHlwZV9hICE9IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZV9hLmNsYXNzID09IHR5cGVfYi5jbGFzcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmFzc2lnbmFibGVUbyA9IGFzc2lnbmFibGVUbztcbmZ1bmN0aW9uIENMQVNTKG5hbWUpIHtcbiAgICByZXR1cm4geyB0YWc6IFwib2JqZWN0XCIsIGNsYXNzOiBuYW1lIH07XG59XG5leHBvcnRzLkNMQVNTID0gQ0xBU1M7XG47XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGVyXCIpO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBkaXNwbGF5KGFyZykge1xuICAgICAgICB2YXIgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXRcIikuYXBwZW5kQ2hpbGQoZWx0KTtcbiAgICAgICAgZWx0LmlubmVyVGV4dCA9IGFyZztcbiAgICB9XG4gICAgdmFyIG1lbW9yeSwgaW1wb3J0T2JqZWN0LCBydW5CdXR0b24sIHVzZXJDb2RlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7IGluaXRpYWw6IDEwLCBtYXhpbXVtOiAxMDAgfSk7XG4gICAgICAgIGltcG9ydE9iamVjdCA9IHtcbiAgICAgICAgICAgIGltcG9ydHM6IHtcbiAgICAgICAgICAgICAgICBtZW06IG1lbW9yeSxcbiAgICAgICAgICAgICAgICBwcmludF9udW06IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2dnaW5nIGZyb20gV0FTTTogXCIsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkoU3RyaW5nKGFyZykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpbnRfYm9vbDogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5KFwiRmFsc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5KFwiVHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpbnRfbm9uZTogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5KFwiTm9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBydW5CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJ1blwiKTtcbiAgICAgICAgdXNlckNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInVzZXItY29kZVwiKTtcbiAgICAgICAgcnVuQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb2dyYW0sIG91dHB1dCwgd2F0LCBjb2RlLCByZXN1bHQsIGVfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW0gPSB1c2VyQ29kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheShcIlByb2dyYW0gT3V0cHV0OlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdCA9ICgwLCBjb21waWxlcl8xLmNvbXBpbGUpKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2VuZXJhdGVkLWNvZGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID0gJ0NvZGUgR2VuZXJhdGVkOicgKyB3YXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgY29tcGlsZXJfMS5ydW53YXRzcmMpKHdhdCwgaW1wb3J0T2JqZWN0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb3V0cHV0LnRleHRDb250ZW50ICs9IChTdHJpbmcocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwbGF5KFN0cmluZyhyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yOiBibGFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudGV4dENvbnRlbnQgPSBTdHJpbmcoZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yOiByZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgdXNlckNvZGUudmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInByb2dyYW1cIik7XG4gICAgICAgIHVzZXJDb2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwicHJvZ3JhbVwiLCB1c2VyQ29kZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgIH0pO1xufSk7IH0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB3YWJ0OyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdGlmKF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0pIHtcblx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGVcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi93ZWJzdGFydC50c1wiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=