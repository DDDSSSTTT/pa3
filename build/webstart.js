/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/lezer-python/dist/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/lezer-python/dist/index.cjs ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var lezer = __webpack_require__(/*! lezer */ "./node_modules/lezer/dist/index.cjs");

// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  printKeyword = 1,
  newline = 164,
  newlineBracketed = 165,
  newlineEmpty = 166,
  eof = 167,
  continueBody = 168,
  endBody = 169,
  ParenthesizedExpression = 21,
  TupleExpression = 48,
  ComprehensionExpression = 49,
  ArrayExpression = 53,
  ArrayComprehensionExpression = 56,
  DictionaryExpression = 57,
  DictionaryComprehensionExpression = 60,
  SetExpression = 61,
  SetComprehensionExpression = 62,
  compoundStatement = 231;

const newline$1 = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46;

const bracketed = [
  ParenthesizedExpression, TupleExpression, ComprehensionExpression, ArrayExpression, ArrayComprehensionExpression,
  DictionaryExpression, DictionaryComprehensionExpression, SetExpression, SetComprehensionExpression
], parentStatement = [compoundStatement];

const caches = new WeakMap;

// Per-input-stream indentation cache. `prev` maps indentation depths
// to the last position at which a statement indented to that depth
// was seen. There's an extra set of slots for the _current_
// indentation, since that needs to be available alongside a previous
// indentation position at the same level.
class Cache {
  constructor() {
    this.last = this.lastIndent = -1;
    this.prev = [];
  }

  get(pos) {
    if (this.last == pos) return this.lastIndent
    for (let i = 0; i < this.prev.length; i++) if (this.prev[i] == pos) return i
    return -1
  }

  set(pos, indent) {
    if (pos == this.last) return
    if (this.last > -1) this.setPrev(this.last, this.lastIndent);
    this.last = pos;
    this.lastIndent = indent;
  }

  setPrev(pos, indent) {
    while (this.prev.length < indent) this.prev.push(-1);
    this.prev[indent] = pos;
  }

  static for(input) {
    let found = caches.get(input);
    if (!found) caches.set(input, found = new Cache);
    return found
  }
}

const maxIndent = 50;

function getIndent(input, pos) {
  let cache = Cache.for(input), found = cache.get(pos);
  if (found > -1) return found

  // This shouldn't happen very often (or even at all) in normal
  // parsing, since the indentations are stored by the newline
  // tokenizer ahead of time. But it's kind of tricky to prove whether
  // that always happens in incremental parsing scenarios, so here's a
  // fallback anyway.
  let before = input.read(Math.max(0, pos - maxIndent), pos);
  let count = 0, start = before.length;
  for (; start > 0; start--) {
    let next = before.charCodeAt(start - 1);
    if (next == newline$1 || next == carriageReturn) break
  }
  for (let i = start; i < before.length; i++) {
    let ch = before.charCodeAt(i);
    if (ch == space) count++;
    else if (ch == tab) count += 8 - (count % 8);
    else break
  }
  cache.setPrev(pos, count);
  return count
}

const newlines = new lezer.ExternalTokenizer((input, token, stack) => {
  let next = input.get(token.start);
  if (next < 0) {
    token.accept(eof, token.start);
    return
  }
  if (next != newline$1 && next != carriageReturn) return
  if (stack.startOf(bracketed) != null) {
    token.accept(newlineBracketed, token.start + 1);
    return
  }
  let scan = token.start + 1, indent = 0;
  for (; scan < input.length; scan++) {
    let ch = input.get(scan);
    if (ch == space) indent++;
    else if (ch == tab) indent += 8 - (indent % 8);
    else if (ch == newline$1 || indent == carriageReturn || ch == hash) {
      token.accept(newlineEmpty, token.start + 1);
      return
    } else {
      break
    }
  }
  token.accept(newline, token.start + 1);
  Cache.for(input).set(scan, indent);
}, {contextual: true, fallback: true});

const bodyContinue = new lezer.ExternalTokenizer((input, token, stack) => {
  let parent = stack.startOf(parentStatement);
  let parentIndent = parent == null ? 0 : getIndent(input, parent);
  let indentHere = getIndent(input, token.start);
  token.accept(indentHere <= parentIndent ? endBody : continueBody, token.start);
}, {contextual: true, fallback: true});

const legacyPrint = new lezer.ExternalTokenizer((input, token) => {
  let pos = token.start;
  for (let print = "print", i = 0; i < print.length; i++, pos++)
    if (input.get(pos) != print.charCodeAt(i)) return
  let end = pos;
  if (/\w/.test(String.fromCharCode(input.get(pos)))) return
  for (;; pos++) {
    let next = input.get(pos);
    if (next == space || next == tab) continue
    if (next != parenOpen && next != dot && next != newline$1 && next != carriageReturn && next != hash)
      token.accept(printKeyword, end);
    return
  }
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,await:40, or:48, and:50, in:54, not:56, is:58, if:64, else:66, lambda:70, self:74, yield:90, from:92, async:100, for:102, None:154, True:156, False:156, del:170, pass:174, break:178, continue:182, return:186, raise:194, import:198, as:200, global:204, nonlocal:206, assert:210, elif:220, while:224, try:230, except:232, finally:234, with:238, def:242, class:252};
const parser = lezer.Parser.deserialize({
  version: 13,
  states: "!;[O`Q!LTOOO%fQ!LUO'#GcOOQ!LQ'#Cm'#CmOOQ!LQ'#Cn'#CnO'UQ!LSO'#ClO(zQ!LUO'#GbOOQ!LQ'#Gc'#GcOOQ!LQ'#DS'#DSOOQ!LQ'#Gb'#GbO)hQ!LSO'#CqO)xQ!LSO'#DcO*YQ!LSO'#DgOOQ!LQ'#Dt'#DtO*mOWO'#DtO*uO`O'#DtO*}OpO'#DuO+YO!bO'#DuO+eO#tO'#DuO+pO&jO'#DuO-rQ!LUO'#GSOOQ!LQ'#GS'#GSO'UQ!LSO'#GRO/UQ!LUO'#GROOQ!LQ'#E^'#E^O/mQ!LSO'#E_OOQ!LQ'#GQ'#GQO/wQ!LSO'#GPOOQ&FV'#GP'#GPO0SQ!LSO'#FQOOQ!LQ'#Ft'#FtO0XQ!LSO'#FPOOQ&FV'#H]'#H]OOQ&FV'#GO'#GOOOQ!LR'#FS'#FSQ`Q!LTOOO'UQ!LSO'#CoO0gQ!LSO'#CzO0nQ!LSO'#DOO1PQ!LSO'#GgO1aQ!LUO'#ERO'UQ!LSO'#ESOOQ!LQ'#EU'#EUOOQ!LQ'#EW'#EWOOQ!LQ'#EY'#EYO1uQ!LSO'#E[O2SQ!LSO'#E`O0SQ!LSO'#EbO2gQ!LUO'#EbO0SQ!LSO'#EeO/mQ!LSO'#EhO/mQ!LSO'#ElO/mQ!LSO'#EoO2rQ!LSO'#EqO2yQ!LSO'#EvO3UQ!LSO'#ErO/mQ!LSO'#EvO0SQ!LSO'#ExO0SQ!LSO'#E}OOQ!LQ'#Cc'#CcOOQ!LQ'#Cd'#CdOOQ!LQ'#Ce'#CeOOQ!LQ'#Cf'#CfOOQ!LQ'#Cg'#CgOOQ!LQ'#Ch'#ChOOQ!LQ'#Cj'#CjO'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O3ZQ!LSO'#DnOOQ!LQ,5:X,5:XO3nQ!LSO,5:[O3{Q#)WO,5:[O4QQ!LUO,59WO0gQ!LSO,59_O0gQ!LSO,59_O0gQ!LSO,59_O6pQ!LSO,59_O6uQ!LSO,59_O6|Q!LSO,59gO7TQ!LSO'#GbO8ZQ!LSO'#GaOOQ!LQ'#Ga'#GaOOQ!LQ'#DY'#DYO8rQ!LSO,59]O'UQ!LSO,59]O9QQ!LSO,59]O9VQ!LSO,5:QO'UQ!LSO,5:QOOQ!LQ,59},59}O9eQ!LSO,59}O9jQ!LSO,5:WO'UQ!LSO,5:WO'UQ!LSO,5:UOOQ!LQ,5:R,5:RO9{Q!LSO,5:RO:QQ!LSO,5:VOOOO'#F]'#F]O:VOWO,5:`OOQ!LQ,5:`,5:`OOOO'#F^'#F^O:_O`O,5:`O:gQ!LSO'#DvOOOO'#F_'#F_O:wOpO,5:aOOQ!LQ,5:a,5:aOOOO'#Fb'#FbO;SO!bO,5:aOOOO'#Fc'#FcO;_O#tO,5:aOOOO'#Fd'#FdO;jO&jO,5:aOOQ!LQ'#Fe'#FeO;uQ!LUO,5:eO>gQ!LUO,5<mO?QQ#4^O'#FfO?tQ!LUO,5<mOOQ!LQ,5:y,5:yO@]Q!LTO'#FmOAlQ!LSO,5;UOOQ&FV,5<k,5<kOAwQ!LUO'#HYOB`Q!LSO,5;lOOQ!LQ-E9r-E9rOOQ&FV,5;k,5;kO3PQ!LSO'#ExOOQ!LR-E9Q-E9QOBhQ!LUO,59ZODoQ!LUO,59fOEYQ!LSO'#GdOEeQ!LSO'#GdO0SQ!LSO'#GdOEpQ!LSO'#DQOExQ!LSO,59jOE}Q!LSO'#GhO'UQ!LSO'#GhO/mQ!LSO,5=ROOQ!LQ,5=R,5=RO/mQ!LSO'#D}OOQ!LQ'#EO'#EOOFlQ!LSO'#FgOF|Q!LSO,58zOG[Q!LSO,58zO)kQ!LSO,5:kOGaQ!LUO'#GjOOQ!LQ,5:n,5:nOOQ!LQ,5:v,5:vOGtQ!LSO,5:zOHVQ!LSO,5:|OOQ!LQ'#Fj'#FjOHeQ!LUO,5:|OHsQ!LSO,5:|OHxQ!LSO'#H[OOQ!LQ,5;P,5;POIWQ!LSO'#HXOOQ!LQ,5;S,5;SO3UQ!LSO,5;WO3UQ!LSO,5;ZOIiQ!LUO'#H^O'UQ!LSO'#H^OIsQ!LSO,5;]O2rQ!LSO,5;]O/mQ!LSO,5;bO0SQ!LSO,5;dOIxQ!LTO'#EmOKRQ&FXO,5;^ONjQ!LSO'#H_O3UQ!LSO,5;bONuQ!LSO,5;dONzQ!LSO,5;iO!#oQ!LUO1G.hO!#vQ!LUO1G.hO!&gQ!LUO1G.hO!&qQ!LUO1G.hO!)[Q!LUO1G.hO!)oQ!LUO1G.hO!*SQ!LUO1G.hO!,rQ!LSO'#GpO!-QQ!LUO'#GSO/mQ!LSO'#GpO!-[Q!LSO'#GoOOQ!LQ,5:Y,5:YO!-dQ!LSO,5:YO!-iQ!LSO'#GqO!-tQ!LSO'#GqO!.XQ!LSO1G/vOOQ!LQ'#Dr'#DrOOQ!LQ1G/v1G/vOOQ!LQ1G.y1G.yO!/XQ!LUO1G.yO!/`Q!LUO1G.yO0gQ!LSO1G.yO!/{Q!LSO1G/ROOQ!LQ'#DX'#DXO/mQ!LSO,59rOOQ!LQ1G.w1G.wO!0SQ!LSO1G/dO!0dQ!LSO1G/dO!0lQ!LSO1G/eO'UQ!LSO'#GiO!0qQ!LSO'#GiO!0vQ!LUO1G.wO!1WQ!LSO,59fO!2^Q!LSO'#FXO!2qQ!LSO,5=XO!2yQ!LSO1G/lO!3OQ!LUO1G/lOOQ!LQ1G/i1G/iO!3`Q!LSO'#FUO!4YQ!LSO,5=SO/mQ!LSO1G/pO!4wQ!LSO1G/rO!4|Q!LUO1G/rO!5^Q!LUO1G/pOOQ!LQ1G/m1G/mOOQ!LQ1G/q1G/qOOOO-E9Z-E9ZOOQ!LQ1G/z1G/zOOOO-E9[-E9[O!5nQ!LSO'#G|O/mQ!LSO'#G|O!5|Q!LSO,5:bOOOO-E9]-E9]OOQ!LQ1G/{1G/{OOOO-E9`-E9`OOOO-E9a-E9aOOOO-E9b-E9bOOQ!LQ-E9c-E9cO!6XQ!LUO1G2XO'UQ!LSO,5<QOOQ!LQ,5<Q,5<QOOQ!LQ-E9d-E9dOOQ!LQ,5<X,5<XOOQ!LQ-E9k-E9kOOQ&FV1G0p1G0pO0SQ!LSO'#FiO!6pQ!LUO,5=tOOQ!LQ1G1W1G1WO!7XQ!LSO1G1WOOQ!LQ'#DT'#DTO/mQ!LSO,5=OOOQ!LQ,5=O,5=OO!7^Q!LSO'#FTO!7lQ!LSO,59lO!7tQ!LSO1G/UO!8OQ!LUO,5=SOOQ!LQ1G2m1G2mOOQ!LQ,5:i,5:iO!8oQ!LSO'#GROOQ!LQ,5<R,5<ROOQ!LQ-E9e-E9eO!9QQ!LSO1G.fOOQ!LQ1G0V1G0VO!9`Q!LSO'#FWO!9sQ!LSO,5=UO/mQ!LSO1G0fO/mQ!LSO1G0fO0SQ!LSO1G0hOOQ!LQ-E9h-E9hO!:UQ!LSO1G0hO!:aQ!LSO1G0hO!:fQ!LSO'#FlO!:wQ!LSO,5=vO!;VQ!LSO'#FhO!;pQ!LSO,5=sO!<RQ&FXO1G0rO!?gQ&FXO1G0uO!BxQ!LSO'#FpO!CVQ!LSO,5=xO!C_Q!LUO,5=xO/mQ!LSO1G0wO!CiQ!LSO1G0wO3UQ!LSO1G0|ONuQ!LSO1G1OOOQ&FV,5;X,5;XO!CnQ!LTO,5;XO!EaQ&FXO1G0xO!HxQ!LSO'#FqO3UQ!LSO1G0xO3UQ!LSO1G0xO!IVQ!LSO'#FrO!IgQ!LSO,5=yO0SQ!LSO,5=yOOQ&FV1G0|1G0|O!JQQ!LSO'#EzO!JXQ#)WO1G1OOOQ&FV1G1T1G1TO3UQ!LSO1G1TOOQ!LQ,5=[,5=[OOQ!LQ'#Do'#DoO/mQ!LSO,5=[O!JaQ!LSO'#FZO!JwQ!LSO,5=ZOOQ!LQ1G/t1G/tO!KPQ!LSO'#F[O!KdQ!LSO,5=]O!KlQ!LSO,5=]O!LPQ!LSO,5=]O!LaQ!LSO,5=]OOQ!LQ7+%b7+%bOOQ!LQ7+$e7+$eO!7tQ!LSO7+$mO!NSQ!LSO1G.yO!NZQ!LSO1G.yOOQ!LQ1G/^1G/^OOQ!LQ,5;q,5;qO'UQ!LSO,5;qOOQ!LQ7+%O7+%OO!NbQ!LSO7+%OOOQ!LQ-E9T-E9TOOQ!LQ7+%P7+%PO!NrQ!LSO,5=TO'UQ!LSO,5=TOOQ!LQ7+$c7+$cO!NwQ!LSO7+%OO# PQ!LSO7+%POOQ!LQ,5;s,5;sO'UQ!LSO,5;sOOQ!LQ-E9V-E9VOOQ!LQ7+%W7+%WO# UQ!LSO1G2sO# ^Q!LSO7+%WOOQ!LQ,5;p,5;pO'UQ!LSO,5;pOOQ!LQ-E9S-E9SO# cQ!LSO7+%[OOQ!LQ7+%^7+%^O# qQ!LSO1G2nO#!`Q!LSO7+%^O#!eQ!LSO'#FYO#!xQ!LSO1G2tO##QQ!LSO7+%[O##VQ!LSO'#F`O##pQ!LSO,5=hO##pQ!LSO,5=hO#$OOMhO'#DxO#$ZOQO'#G}OOOO1G/|1G/|O#$`Q!LSO1G/|O#$hQ!LUO1G1lOOQ!LQ,5<T,5<TOOQ!LQ-E9g-E9gOOQ!LQ7+&r7+&rOOQ!LQ1G2j1G2jOOQ!LQ,5;o,5;oOOQ!LQ-E9R-E9ROOQ!LQ7+$p7+$pO#%RQ!LSO'#FfO#%oQ!LSO,5<mO#&QQ!LUO,5;rOOQ!LQ-E9U-E9UOOQ!LQ7+&Q7+&QO#&eQ!LSO7+&QOOQ!LQ7+&S7+&SO#&sQ!LSO'#HZO0SQ!LSO7+&SO#'XQ!LSO7+&SOOQ!LQ,5<W,5<WOOQ!LQ-E9j-E9jOOQ!LQ,5<S,5<SOOQ!LQ-E9f-E9fO#'dQ&FXO7+&^O!HxQ!LSO'#FoO3UQ!LSO7+&^O3UQ!LSO7+&aO#*xQ!LUO,5<[O'UQ!LSO,5<[OOQ!LQ-E9n-E9nO#+SQ!LSO1G3dO3UQ!LSO7+&cO/mQ!LSO7+&cOOQ&FV7+&h7+&hO!JXQ#)WO7+&jO#+[Q&FWO1G0sOOQ&FV-E9o-E9oO3UQ!LSO7+&dO3UQ!LSO7+&dOOQ&FV,5<],5<]O#+gQ!LSO,5<]OOQ&FV7+&d7+&dO#+rQ&FXO7+&dO#/TQ!LSO,5<^OOQ!LQ-E9p-E9pO#/`Q!LSO1G3eO#/hQ!LSO'#HaO#/vQ!LSO'#HaO0SQ!LSO'#HaOOQ!LQ'#Ha'#HaO#0RQ!LSO'#H`OOQ!LQ,5;f,5;fO#0ZQ!LSO,5;fO/mQ!LSO'#E|OOQ&FV7+&j7+&jO3UQ!LSO7+&jOOQ&FV7+&o7+&oOOQ!LQ1G2v1G2vOOQ!LQ,5;u,5;uOOQ!LQ-E9X-E9XO#0`Q!LSO,5;vO#0kQ!LSO,5;vOOQ!LQ-E9Y-E9YO#1OQ!LSO1G2wO#1WQ!LSO1G2wO#1hQ!LSO1G2wO#1OQ!LSO1G2wOOQ!LQ<<HX<<HXO#1sQ!LUO1G1]OOQ!LQ<<Hj<<HjP#1}Q!LSO'#FVO6|Q!LSO1G2oO#2[Q!LSO1G2oO#2aQ!LSO<<HjOOQ!LQ<<Hk<<HkO#2qQ!LUO1G1_OOQ!LQ<<Hr<<HrO#2{Q!LUO1G1[O#3lQ!LSO7+(`O#3tQ!LSO<<HvOOQ!LQ<<Hx<<HxO#3yQ!LSO,5;tO'UQ!LSO,5;tOOQ!LQ-E9W-E9WOOQ!LQ<<Hv<<HvOOQ!LQ,5;z,5;zO/mQ!LSO,5;zOOQ!LQ-E9^-E9^O#4OQ!LSO1G3SOOOO'#Fa'#FaO#4^OMhO,5:dOOOO,5=i,5=iOOOO7+%h7+%hO#4iQ!LSO1G2XO/mQ!LSO<<IlO#4zQ!LSO'#FkO#5`Q!LSO,5=uO0SQ!LSO,5=uO#5qQ!LSO<<InOOQ!LQ<<In<<InO0SQ!LSO<<InOOQ&FV-E9m-E9mO3UQ!LSO<<IxOOQ&FV,5<Z,5<ZO3UQ!LSO,5<ZOOQ&FV<<Ix<<IxOOQ&FV<<I{<<I{O#5vQ!LUO1G1vO#6QQ&FXO<<I}O3UQ!LSO<<I}OOQ&FV<<JU<<JUO3UQ!LSO<<JUO!CnQ!LTO'#FnO#9cQ&FWO7+&_OOQ&FV7+&_7+&_OOQ&FV<<JO<<JOO#9nQ&FXO<<JOOOQ&FV1G1w1G1wO0SQ!LSO1G1wO3UQ!LSO<<JOO0SQ!LSO1G1xO#=PQ!LSO7+)POOQ!LQ'#E{'#E{O/mQ!LSO,5={O#=XQ!LSO,5={OOQ!LQ,5={,5={O#=dQ!LSO'#FsO#=nQ!LSO,5=zOOQ!LQ1G1Q1G1QOOQ!LQ,5;h,5;hO#=vQ!LSO1G1bO#>ZQ!LSO1G1bO#>kQ!LSO1G1bO#>vQ!LSO7+(cO#>vQ!LSO7+(cO#?OQ!LSO7+(cO#?`Q!LSO7+(ZO6|Q!LSO7+(ZOOQ!LQAN>UAN>UOOQ!LQAN>bAN>bO/mQ!LSO1G1`O#?yQ!LUO1G1`OOQ!LQ1G1f1G1fOOOO-E9_-E9_OOQ!LQAN?WAN?WO#@TQ!LSO,5<VOOQ!LQ-E9i-E9iO#@iQ!LSO1G3aOOQ!LQAN?YAN?YO#@zQ!LSOAN?YOOQ&FVAN?dAN?dOOQ&FV1G1u1G1uO3UQ!LSOAN?iO#APQ&FXOAN?iOOQ&FVAN?pAN?pOOQ&FU,5<Y,5<YOOQ&FU-E9l-E9lOOQ&FV<<Iy<<IyO3UQ!LSOAN?jO3UQ!LSO7+'cOOQ&FVAN?jAN?jOOQ!LQ7+'d7+'dOOQ!LQ1G3g1G3gO/mQ!LSO1G3gOOQ!LQ,5<_,5<_OOQ!LQ-E9q-E9qO#DbQ!LSO7+&|O#DrQ!LSO7+&|OOQ!LQ7+&|7+&|O#D}Q!LSO<<K}O#D}Q!LSO<<K}O#EVQ!LSO'#GkOOQ!LQ<<Ku<<KuO#EaQ!LSO<<KuOOQ!LQ7+&z7+&zO0SQ!LSO1G1qO#EzQ!LSO7+({OOQ!LQG24tG24tOOQ&FVG25TG25TO3UQ!LSOG25TOOQ&FVG25UG25UOOQ&FV<<J}<<J}OOQ!LQ7+)R7+)ROOQ!LQ<<Jh<<JhO#F]Q!LSO<<JhO#FmQ!LSOANAiO#FuQ!LSO'#GlOOQ!LQ'#Gl'#GlO0nQ!LSO'#DbO#G`Q!LSO,5=VOOQ!LQANAaANAaOOQ!LQ7+']7+']OOQ&FVLD*oLD*oOOQ!LQAN@SAN@SO#GwQ!LSO,59|OOQ!LQ1G2q1G2qO#EVQ!LSO1G/hOOQ!LQ7+%S7+%SO6|Q!LSO'#CzO6|Q!LSO,59_O6|Q!LSO,59_O6|Q!LSO,59_O#G|Q!LUO,5<mO6|Q!LSO1G.yO/mQ!LSO1G/UO/mQ!LSO7+$mO'UQ!LSO'#GRO#HaQ!LSO,59_O#HfQ!LSO,59_O#HmQ!LSO,59jO#HrQ!LSO1G/RO0nQ!LSO'#DOO6|Q!LSO,59g",
  stateData: "#IT~O$qOS$lOS$kOSQOS~OPhOTeOdsOfXOltOp!SOsuOudO}vO!O!PO!S!VO!T!UO!WYO![ZO!gdO!ndO!odO!pdO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#d!TO#g!WO#k!XO#m!YO#r!ZO#ulO$jqO$|QO$}QO%RRO%SVO%g[O%h]O%k^O%n_O%t`O%waO%ybO~OT!aO]!aO_!bOf!jO!W!lO!e!mO$w![O$x!]O$y!^O$z!_O${!_O$|!`O$}!`O%O!aO%P!aO%Q!aO~Oh%VXi%VXj%VXk%VXl%VXm%VXp%VXx%VXy%VX!t%VX#_%VX$j%VX$m%VX%X%VX!P%VX!S%VX!T%VX%Y%VX!X%VX!]%VX!O%VX#W%VXq%VX!k%VX~P$bOdsOfXOudO!WYO![ZO!gdO!ndO!odO!pdO$|QO$}QO%RRO%SVO%g[O%h]O%k^O%n_O%t`O%waO%ybO~Ox%UXy%UX#_%UX$j%UX$m%UX%X%UX~Oh!pOi!qOj!oOk!oOl!rOm!sOp!tO!t%UX~P(fOT!zOl,qOs-OO}vO~P'UOT!}Ol,qOs-OO!X#OO~P'UOT#RO_#SOl,qOs-OO!]#TO~P'UO%i#WO%j#YO~O%l#ZO%m#YO~O![#]O%o#^O%s#`O~O![#]O%u#aO%v#`O~O![#]O%j#`O%x#cO~O![#]O%m#`O%z#eO~OT$vX]$vX_$vXf$vXh$vXi$vXj$vXk$vXl$vXm$vXp$vXx$vX!W$vX!e$vX$w$vX$x$vX$y$vX$z$vX${$vX$|$vX$}$vX%O$vX%P$vX%Q$vX!P$vX!S$vX!T$vX~O%g[O%h]O%k^O%n_O%t`O%waO%ybOy$vX!t$vX#_$vX$j$vX$m$vX%X$vX%Y$vX!X$vX!]$vX!O$vX#W$vXq$vX!k$vX~P+{Ox#jOy$uX!t$uX#_$uX$j$uX$m$uX%X$uX~Ol,qOs-OO~P'UO#_#mO$j#oO$m#oO~O%SVO~O!S#tO#m!YO#r!ZO#ulO~OltO~P'UOT#yO_#zOu#xO%SVOytP~OT$OOl,qOs-OO!O$PO~P'UOy$RO!t$WO%X$SO#_!uX$j!uX$m!uX~OT$OOl,qOs-OO~P'UOl,qOs-OO#_#SX$j#SX$m#SX~P'UO!e$^O!n$^O%SVO~OT$hO~P'UO!T$jO#k$kO#m$lO~Oy$mO~OT$|O_$|Ol,qOs-OO!P%OO~P'UOl,qOs-OOy%RO~P'UO%f%TO~O_!bOf!jO!W!lO!e!mOT`a]`ah`ai`aj`ak`al`am`ap`ax`ay`a!t`a#_`a$j`a$m`a$w`a$x`a$y`a$z`a${`a$|`a$}`a%O`a%P`a%Q`a%X`a!P`a!S`a!T`a%Y`a!X`a!]`a!O`a#W`aq`a!k`a~Ok%YO~Ol%YO~P'UOl,qO~P'UOh,sOi,tOj,rOk,rOl,zOm,{Op-PO!P%UX!S%UX!T%UX%Y%UX!X%UX!]%UX!O%UX#W%UX!k%UX~P(fO%Y%[Ox%TX!P%TX!S%TX!T%TX!X%TXy%TX~Ox%_O!P%^O!S%cO!T%bO~O!P%^O~Ox%fO!S%cO!T%bO!X%aX~O!X%jO~Ox%kOy%mO!S%cO!T%bO!]%[X~O!]%qO~O!]%rO~O%i#WO%j%tO~O%l#ZO%m%tO~OT%wOl,qOs-OO}vO~P'UO![#]O%o#^O%s%zO~O![#]O%u#aO%v%zO~O![#]O%j%zO%x#cO~O![#]O%m%zO%z#eO~OT!ma]!ma_!maf!mah!mai!maj!mak!mal!mam!map!max!may!ma!W!ma!e!ma!t!ma#_!ma$j!ma$m!ma$w!ma$x!ma$y!ma$z!ma${!ma$|!ma$}!ma%O!ma%P!ma%Q!ma%X!ma!P!ma!S!ma!T!ma%Y!ma!X!ma!]!ma!O!ma#W!maq!ma!k!ma~P#yOx#jOy$ua!t$ua#_$ua$j$ua$m$ua%X$ua~P$bOT&QOltOsuOx$YXy$YX!t$YX#_$YX$j$YX$m$YX%X$YX~P'UOx#jOy$ua!t$ua#_$ua$j$ua$m$ua%X$ua~OPhOTeOltOsuO}vO!O!PO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#_$aX$j$aX$m$aX~P'UO#_#mO$j&VO$m&VO~O!e&WOf%|X$j%|X#W%|X#_%|X$m%|X#V%|X~Of!jO$j&YO~Ohcaicajcakcalcamcapcaxcayca!tca#_ca$jca$mca%Xca!Pca!Sca!Tca%Yca!Xca!]ca!Oca#Wcaqca!kca~P$bOpnaxnayna#_na$jna$mna%Xna~Oh!pOi!qOj!oOk!oOl!rOm!sO!tna~PDWO%X&[Ox%WXy%WX~O%SVOx%WXy%WX~Ox&_OytX~Oy&aO~Ox%kO#_%[X$j%[X$m%[X!P%[Xy%[X!]%[X!k%[X%X%[X~OT,yOl,qOs-OO}vO~P'UO%X$SO#_Sa$jSa$mSa~O%X$SO~Ox&jO#_%^X$j%^X$m%^Xk%^X~P$bOx&mO!O&lO#_#Sa$j#Sa$m#Sa~O#W&nO#_#Ua$j#Ua$m#Ua~O!e$^O!n$^O#V&pO%SVO~O#V&pO~Ox&rO#_&OX$j&OX$m&OX~Ox&tO#_%{X$j%{X$m%{Xy%{X~Ox&xOk&QX~P$bOk&{O~OPhOTeOltOsuO}vO!O!PO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO$j'QO~P'UOq'UO#h'SO#i'TOP#faT#fad#faf#fal#fap#fas#fau#fa}#fa!O#fa!S#fa!T#fa!W#fa![#fa!g#fa!n#fa!o#fa!p#fa!w#fa!y#fa!{#fa!}#fa#P#fa#T#fa#V#fa#Y#fa#Z#fa#]#fa#d#fa#g#fa#k#fa#m#fa#r#fa#u#fa$i#fa$j#fa$|#fa$}#fa%R#fa%S#fa%g#fa%h#fa%k#fa%n#fa%t#fa%w#fa%y#fa$m#fa$n#fa$o#fa~Ox'VO#W'XOy&RX~Of'ZO~Of!jOy$mO~OT!aO]!aO_!bOf!jO!W!lO!e!mO$y!^O$z!_O${!_O$|!`O$}!`O%O!aO%P!aO%Q!aOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O$x!]O~P! SO$xUi~P! SOT!aO]!aO_!bOf!jO!W!lO!e!mO$|!`O$}!`O%O!aO%P!aO%Q!aOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O$z!_O${!_O~P!#}O$zUi${Ui~P!#}O_!bOf!jO!W!lO!e!mOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi$zUi${Ui$|Ui$}Ui%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~OT!aO]!aO%O!aO%P!aO%Q!aO~P!&{OTUi]Ui%OUi%PUi%QUi~P!&{Of!jO!W!lO!e!mOTUi]Ui_UihUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi$zUi${Ui$|Ui$}Ui%OUi%PUi%QUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O!S%cO!T%bOx%dX!P%dX~O%X'`O%Y'`O~P+{Ox'bO!P%cX~O!P'dO~Ox'eOy'gO!X%eX~Ol,qOs-OOx'eOy'hO!X%eX~P'UO!X'jO~Oj!oOk!oOl!rOm!sOhgipgixgiygi!tgi#_gi$jgi$mgi%Xgi~Oi!qO~P!.^Oigi~P!.^Oh,sOi,tOj,rOk,rOl,zOm,{O~Oq'lO~P!/gOT'qOl,qOs-OO!P'rO~P'UOx'sO!P'rO~O!P'uO~O!T'wO~Ox'sO!P'xO!S%cO!T%bO~P$bOh,sOi,tOj,rOk,rOl,zOm,{O!Pna!Sna!Tna%Yna!Xna!]na!Ona#Wnaqna!kna~PDWOT'|Ol,qOs-OOx#{X!X#{X~P'UOx%fO!X%aa~O!X(OO~Ox%fO!S%cO!T%bO!X%aa~P$bOT(SOl,qOs-OOx#xX!]#xX#_#xX$j#xX$m#xX!P#xXy#xX!k#xX%X#xX~P'UOx%kO!]%[a#_%[a$j%[a$m%[a!P%[ay%[a!k%[a%X%[a~O!](VO~Ox%kO!S%cO!T%bO!]%[a~P$bOx(YO!S%cO!T%bO!]%ba~P$bOx(]Oy%pX!]%pX!k%pX~Oy(`O!](bO!k(cO~Ox#jOy$ui!t$ui#_$ui$j$ui$m$ui%X$ui~O!e&WOf%|a$j%|a#W%|a#_%|a$m%|a#V%|a~O$j(gO~OT#yO_#zOu#xO%SVO~Ox&_Oyta~OltOsuO~P'UOx%kO#_%[a$j%[a$m%[a!P%[ay%[a!]%[a!k%[a%X%[a~P$bOx(lO#_$uX$j$uX$m$uX%X$uX~O%X$SO#_Si$jSi$mSi~Ox#zX#_#zX$j#zX$m#zXk#zX~P'UOx&jO#_%^a$j%^a$m%^ak%^a~OT(rOf(tO%SVO~O#V(uO~O%SVOx$`X#_$`X$j$`X$m$`X~Ox&rO#_&Oa$j&Oa$m&Oa~Ol,qOs-OOx$[X#_$[X$j$[X$m$[Xy$[X~P'UOx&tO#_%{a$j%{a$m%{ay%{a~Oq(|O#b({OP#`iT#`id#`if#`il#`ip#`is#`iu#`i}#`i!O#`i!S#`i!T#`i!W#`i![#`i!g#`i!n#`i!o#`i!p#`i!w#`i!y#`i!{#`i!}#`i#P#`i#T#`i#V#`i#Y#`i#Z#`i#]#`i#d#`i#g#`i#k#`i#m#`i#r#`i#u#`i$i#`i$j#`i$|#`i$}#`i%R#`i%S#`i%g#`i%h#`i%k#`i%n#`i%t#`i%w#`i%y#`i$m#`i$n#`i$o#`i~Oq(}OP#ciT#cid#cif#cil#cip#cis#ciu#ci}#ci!O#ci!S#ci!T#ci!W#ci![#ci!g#ci!n#ci!o#ci!p#ci!w#ci!y#ci!{#ci!}#ci#P#ci#T#ci#V#ci#Y#ci#Z#ci#]#ci#d#ci#g#ci#k#ci#m#ci#r#ci#u#ci$i#ci$j#ci$|#ci$}#ci%R#ci%S#ci%g#ci%h#ci%k#ci%n#ci%t#ci%w#ci%y#ci$m#ci$n#ci$o#ci~OT)POk$dXx$dX~P'UOx&xOk&Qa~Ox&xOk&Qa~P$bOk)TO~OPhOTeOltOp!SOsuO}vO!O!PO!S!VO!T!UO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#d!TO#g!WO#k!XO#m!YO#r!ZO#ulO~P'UOq)ZO#h'SO#i)YOP#fiT#fid#fif#fil#fip#fis#fiu#fi}#fi!O#fi!S#fi!T#fi!W#fi![#fi!g#fi!n#fi!o#fi!p#fi!w#fi!y#fi!{#fi!}#fi#P#fi#T#fi#V#fi#Y#fi#Z#fi#]#fi#d#fi#g#fi#k#fi#m#fi#r#fi#u#fi$i#fi$j#fi$|#fi$}#fi%R#fi%S#fi%g#fi%h#fi%k#fi%n#fi%t#fi%w#fi%y#fi$m#fi$n#fi$o#fi~Ol,qOs-OOy$mO~P'UOl,qOs-OOx$fXy$fX~P'UOx'VOy&Ra~OT)dO_)eOu)cO%O)fO%SVO~O!P)hO~P!IoOy$mO&U)jO~OT$|O_$|Ol,qOs-OOx#}X!P#}X~P'UOx'bO!P%ca~Ol,qOs-OOy)rOx$OX!X$OX~P'UOx'eO!X%ea~Ol,qOs-OOx'eOy)uO!X%ea~P'UOl,qOs-OOx'eO!X%ea~P'UOx'eOy)uO!X%ea~Oj,rOk,rOl,zOm,{Ohgipgixgi!Pgi!Sgi!Tgi%Ygi!Xgiygi!]gi#_gi$jgi$mgi!Ogi#Wgiqgi!kgi%Xgi~Oi,tO~P!LlOigi~P!LlOT'qOl,qOs-OO!P)zO~P'UOk)|O~Ox*OO!P)zO~O!P*PO~Ox%fO!X%ai~O!X*RO~Ox(YO!S%cO!T%bO!]%bi~Ox%kO!]%[i#_%[i$j%[i$m%[i!P%[iy%[i!k%[i%X%[i~O!]*VO~O_*XOl,qOs-OOx#|X!]#|X~P'UOx(YO!]%bi~O!]*ZO~OT*]Ol,qOs-OOx$SXy$SX!]$SX!k$SX~P'UOx(]Oy%pa!]%pa!k%pa~O![#]O%r*`O!]!lX~O!]*bO~Oy(`O!]*cO~Ox$Yiy$Yi!t$Yi#_$Yi$j$Yi$m$Yi%X$Yi~P$bOT&QOl,qOs-OOx$YX#_$YX$j$YX$m$YX%X$YX~P'UOx(lO#_$ua$j$ua$m$ua%X$ua~Ox#za#_#za$j#za$m#zak#za~P$bOx*eO#_#Sq$j#Sq$m#Sq~Ox*fO#W*hO#_%}X$j%}X$m%}X!P%}X~OT*jOf*kO%SVO~Oq*mO#b({OP#`qT#`qd#`qf#`ql#`qp#`qs#`qu#`q}#`q!O#`q!S#`q!T#`q!W#`q![#`q!g#`q!n#`q!o#`q!p#`q!w#`q!y#`q!{#`q!}#`q#P#`q#T#`q#V#`q#Y#`q#Z#`q#]#`q#d#`q#g#`q#k#`q#m#`q#r#`q#u#`q$i#`q$j#`q$|#`q$}#`q%R#`q%S#`q%g#`q%h#`q%k#`q%n#`q%t#`q%w#`q%y#`q$m#`q$n#`q$o#`q~Ok$dax$da~P$bOx&xOk&Qi~O$m*yO$n*wO$o*yO~Ox*}Oy$mO#W*}O~O#i+OOP#fqT#fqd#fqf#fql#fqp#fqs#fqu#fq}#fq!O#fq!S#fq!T#fq!W#fq![#fq!g#fq!n#fq!o#fq!p#fq!w#fq!y#fq!{#fq!}#fq#P#fq#T#fq#V#fq#Y#fq#Z#fq#]#fq#d#fq#g#fq#k#fq#m#fq#r#fq#u#fq$i#fq$j#fq$|#fq$}#fq%R#fq%S#fq%g#fq%h#fq%k#fq%n#fq%t#fq%w#fq%y#fq$m#fq$n#fq$o#fq~O#W+POx$fay$fa~Ox'VOy&Ri~Oy$RO%X+ROx&TX!P&TX~O%SVOx&TX!P&TX~Ox+VO!P&SX~O!P+XO~Oy+ZOx$Oa!X$Oa~Ol,qOs-OOy+[Ox$Oa!X$Oa~P'UOx'eO!X%ei~Ol,qOs-OOx'eO!X%ei~P'UOx'eOy+`O!X%ei~Ox#yi!P#yi~P$bOT'qOl,qOs-OO~P'UOk+bO~OT'qOl,qOs-OO!P+cO~P'UOx#{i!X#{i~P$bOx#xi!]#xi#_#xi$j#xi$m#xi!P#xiy#xi!k#xi%X#xi~P$bOx(YO!]%bq~O!]+dO~Oy+eO~Ox(]Oy%pi!]%pi!k%pi~O![#]O%r*`O!]!la~Ox(lO#_$ui$j$ui$m$ui%X$ui~O%SVOx$_X#_$_X$j$_X$m$_X!P$_X~Ox*fO#_%}a$j%}a$m%}a!P%}a~O!P+mO~Ok$dix$di~P$bOq+qOP#eyT#eyd#eyf#eyl#eyp#eys#eyu#ey}#ey!O#ey!S#ey!T#ey!W#ey![#ey!g#ey!n#ey!o#ey!p#ey!w#ey!y#ey!{#ey!}#ey#P#ey#T#ey#V#ey#Y#ey#Z#ey#]#ey#d#ey#g#ey#k#ey#m#ey#r#ey#u#ey$i#ey$j#ey$|#ey$}#ey%R#ey%S#ey%g#ey%h#ey%k#ey%n#ey%t#ey%w#ey%y#ey$m#ey$n#ey$o#ey~O$m+vO$n*wO$o+vO~O#i+wOP#fyT#fyd#fyf#fyl#fyp#fys#fyu#fy}#fy!O#fy!S#fy!T#fy!W#fy![#fy!g#fy!n#fy!o#fy!p#fy!w#fy!y#fy!{#fy!}#fy#P#fy#T#fy#V#fy#Y#fy#Z#fy#]#fy#d#fy#g#fy#k#fy#m#fy#r#fy#u#fy$i#fy$j#fy$|#fy$}#fy%R#fy%S#fy%g#fy%h#fy%k#fy%n#fy%t#fy%w#fy%y#fy$m#fy$n#fy$o#fy~Ox'VOy&Rq~O%X+ROx&Ta!P&Ta~Ox$gX!P$gX~P!IoOx+VO!P&Sa~Ol,qOs-OOy,POx$Oi!X$Oi~P'UOl,qOs-OOx$Oi!X$Oi~P'UOy,POx$Oi!X$Oi~Ox'eO!X%eq~Ol,qOs-OOx'eO!X%eq~P'UOp,UO!S%cO!T%bO!P%]q!X%]q!]%]qx%]q~P!/gOx#|i!]#|i~P$bO#W,YOx$_a#_$_a$j$_a$m$_a!P$_a~Ox*fO#_%}i$j%}i$m%}i!P%}i~O!P,[O~Oq,^OP#e!RT#e!Rd#e!Rf#e!Rl#e!Rp#e!Rs#e!Ru#e!R}#e!R!O#e!R!S#e!R!T#e!R!W#e!R![#e!R!g#e!R!n#e!R!o#e!R!p#e!R!w#e!R!y#e!R!{#e!R!}#e!R#P#e!R#T#e!R#V#e!R#Y#e!R#Z#e!R#]#e!R#d#e!R#g#e!R#k#e!R#m#e!R#r#e!R#u#e!R$i#e!R$j#e!R$|#e!R$}#e!R%R#e!R%S#e!R%g#e!R%h#e!R%k#e!R%n#e!R%t#e!R%w#e!R%y#e!R$m#e!R$n#e!R$o#e!R~Ol,qOs-OOx$Oq!X$Oq~P'UOy,cOx$Oq!X$Oq~Ox'eO!X%ey~Ol,qOs,gO~P'UOp,UO!S%cO!T%bO!P%]y!X%]y!]%]yx%]y~P!/gOx*fO#_%}q$j%}q$m%}q!P%}q~Ol,qOs-OOx$Oy!X$Oy~P'UOx'eO!X%e!R~Op%`X!P%`X!S%`X!T%`X!X%`X!]%`Xx%`X~P!/gOp,UO!S%cO!T%bO!P%_a!X%_a!]%_ax%_a~Oy,oO~Ox(lO#_$ua$j$ua$m$ua%X$ua~P$bOk,vO~Ol,vO~P'UOy,wO~Oq,xO~P!/gO%h%k%w%y%g%n%t%S%g~",
  goto: "!&h&UPPPP&VP&_(|)d){*e+O+jP,VP&_,t,t&_P&_P/cPPPPPP/c1bPP1bP2}P3W7`PP7c7o7rPPP&_&_PP8O&_PP&_&_PP&_&_&_&_8S8x&_P8{P9O9O;qP<V&_PPP<Z<a&VP&V&VP&VP&VP&VP&VP&V&V&VP&VPP&VPP&VP<gP<n<tP<nP<n<nPPP<nP>mP>v>|?S>mP<n?YP?a?g?m?y@T@Z@e@o@uAcAiAoAuBPBVB]BcBiBoCRC]CcCiCoCyDPDVD]DcDmDsD}ETPPPPPPPPPE^EhEqE{FWPPPPPPPPPPPPI}JgNU!!qPP!!y!#X!#b!$W!#}!$a!$g!$j!$m!$p!$vPPPPPPPPPP!$y!$|PPPPPPPPP!%S!%`!%l!%x!%{!&R!&X!&_!&b]iOr#m$m'Q*w&XdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-Py!cP#i#v$X$g%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u{!dP#i#v$X$g$s%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u}!eP#i#v$X$g$s$t%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!P!fP#i#v$X$g$s$t$u%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!R!gP#i#v$X$g$s$t$u$v%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!T!hP#i#v$X$g$s$t$u$v$w%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!X!iP!n#i#v$X$g$s$t$u$v$w$x%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u&XSOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-P$yUOXYZhrtv|}!R!S!T!X!j!l!o!p!q!s!t#]#j#m$P$R$T$W$k$m$|%R%Y%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){)|*O*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,{-P$TWOXYZhrv|}!R!S!T!X!j!l#]#j#m$P$R$T$W$k$m$|%R%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){*O*]*e*w+S+Z+[+`+e+|,P,c,w,xQ#|uQ,m,gR,|-O&SdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-PW#pl!O!P$_W#xu&_,g-OQ$a!QQ$q!YQ$r!ZS${!j'bS&^#y#zQ'O$lQ(e&WQ(r&nW(s&p(t(u*kQ(v&rQ)b'XS)c'Z+VS+U)d)eQ+j*fQ+l*hQ+x*}Q+z+PR,j,YR&]#xe!wXY!S!T%_%f's({){*OR%]!vQ!{XQ%x#]Q&f$TR&i$WT,f,U,o!Y!kP!n#i#v$X$g$s$t$u$v$w$x$y%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,uQ&Z#qR'^$rR'a${R%U!m&WcOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-PT#gc#hS#^_#_S#a`#bS#ca#dS#eb#fT*`(`*aT(a%x(cQ$VwR+T)cX$Tw$U$V&hZkOr$m'Q*wXoOr'Q*wQ$n!WQ&v$eQ&w$fQ'Y$pQ']$rQ)U&}Q)['SQ)^'TQ)_'UQ)k'[Q)m'^Q*n({Q*p(|Q*q(}Q*s)SS*u)V)lQ*z)YQ*{)ZQ*|)]Q+o*mQ+p*oQ+r*tQ+s*vQ+y+OQ,]+qQ,_+wQ,`+xR,k,^WoOr'Q*wR#snQ'[$qR)V'OQ+S)cR+|+TQ)l'[R*v)VZmOnr'Q*wQrOR#urQ&`#{R(j&`S%l#Q#}S(T%l(WT(W%o&bQ%`!yS't%`'yR'y%dQ&k$XR(o&kQ%g!|S'}%g(PR(P%iQ(Z%pQ*T(UT*Y(Z*TQ'c$}R)p'cS'f%Q%RY)s'f)t+^,S,dU)t'g'h'iU+^)u)v)wS,S+_+`R,d,TQ#X]R%s#XQ#[^R%u#[Q#__R%y#_Q(^%vS*^(^*_R*_(_Q*a(`R+h*aQ#b`R%{#bQ#daR%|#dQ#fbR%}#fQ#hcR&O#hQ#kfQ&P#iW&S#k&P(m*dQ(m&eR*d,uQ$UwS&g$U&hR&h$VQ&u$cR(y&uQ&X#pR(f&XQ$_!PR&o$_Q*g(sS+k*g,ZR,Z+lQ&s$aR(w&sQ#njR&U#nQ*x)WR+u*xQ(z&vR*l(zQ&y$gS)Q&y)RR)R&zQ'R$nR)X'RQ'W$oS)a'W+QR+Q)bQ+W)gR,O+WWnOr'Q*wR#rnSqOrQ)W'QR+t*wWpOr'Q*wR'P$mYjOr$m'Q*wR&T#m[wOr#m$m'Q*wR&f$T$xPOXYZhrtv|}!R!S!T!X!j!l!o!p!q!s!t#]#j#m$P$R$T$W$k$m$|%R%Y%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){)|*O*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,{-PQ!nSQ#ieQ#vsU$Xx%b'wS$g!U$jQ$s!cQ$t!dQ$u!eQ$v!fQ$w!gQ$x!hQ$y!iQ%d!zQ%i!}Q%o#RQ%p#SQ&b$OQ&z$hQ(d&QQ(n&jQ)O&xQ)y'qQ*Q'|Q*S(SQ*r)PQ+f*XR,u,yQ!yXQ!|YQ$e!SQ$f!TW'p%_'s){*OQ'{%fR*o({[fOr#m$m'Q*wd!vXY!S!T%_%f's({){*OQ#QZQ#lhS#}v|Q$[}W$c!R$W&{)TS$o!X$kS$z!j'bQ%Q!lQ%v#]S&R#j(lQ&c$PQ&d$RQ&e$TQ'_$|Q'i%RQ'o%]Q(R%kQ(U%mQ(_%wQ(h&]S(k&a,wQ(p&lQ(q&mQ(x&tQ)]'SQ)`'VQ)n'aQ)q'eQ)v'gQ)w'hS)x'l,xQ*W(YQ*[(]Q+Y)jQ+])rQ+_)uQ+g*]Q+i*eQ+{+SQ,Q+ZQ,R+[Q,T+`Q,X+eQ,a+|Q,b,PR,l,cbTOr#j#m$m&a'Q'l*w#p!uXYZhv|}!R!S!T!X!j!l#]$P$R$T$W$k$|%R%]%_%f%k%m%w&]&l&m&t&{'S'V'a'b'e'g'h's(Y(](l({)T)j)r)u){*O*]*e+S+Z+[+`+e+|,P,c,w,xQ#wtW%V!o!s,r,{Q%W!pQ%X!qQ%Z!tQ%e,qS'k%Y,vQ'm,sQ'n,tQ+a)|Q,W+bS,e,U,oR,}-PU#{u,g-OR(i&_[gOr#m$m'Q*wX!xX#]$T$WQ#VZQ$QvR$Z|Q%a!yQ%h!|Q%n#QQ'_$zQ'z%dQ(Q%iQ(X%oQ([%pQ*U(UQ,V+aQ,i,WR,n,hQ$YxQ'v%bR)}'wQ,h,UR,p,oR#PYR#UZR%P!jQ$}!jR)o'bR%S!lR%x#]Q(b%xR*c(cQ$d!RQ&i$WQ)S&{R*t)TQ#qlQ$]!OQ$`!PR&q$_Q(r&pQ*i(tQ*j(uR+n*kR$b!QXpOr'Q*wQ$i!UR&|$jQ$p!XR&}$kR)i'ZQ)g'ZR+}+V",
  nodeNames: "⚠ print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ParenthesizedExpression ( BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList self VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from ) TupleExpression ComprehensionExpression async for LambdaExpression ArrayExpression [ ] ArrayComprehensionExpression DictionaryExpression { } DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At",
  maxTerm: 236,
  nodeProps: [
    [lezer.NodeProp.group, -14,4,81,83,84,86,88,90,92,94,95,96,98,101,104,"Statement Statement",-23,6,16,19,21,37,38,48,49,53,56,57,60,61,62,63,66,69,70,71,75,76,77,78,"Expression",-9,106,108,111,113,114,118,120,125,127,"Statement"]
  ],
  skippedNodes: [0,2],
  repeatNodeCount: 33,
  tokenData: "!E}MgR!^OX$}XY%wY[$}[]%w]p$}pq%wqr(crs*Ust2Otu$}uv4Qvw5Uwx5xxyAWyzAtz{Bb{|Cr|}Df}!OES!O!PFZ!P!QKa!Q!RLq!R![!(P![!]!)i!]!^!*m!^!_!+Z!_!`!,k!`!a!-_!a!b$}!b!c!.l!c!d!/b!d!e!1f!e!h!/b!h!i!8O!i!t!/b!t!u!=b!u!w!/b!w!x!?`!x!}!/b!}#O!@t#O#P!Ab#P#Q!Bc#Q#R!CP#R#S!/b#S#T$}#T#U!/b#U#V!1f#V#Y!/b#Y#Z!8O#Z#f!/b#f#g!=b#g#i!/b#i#j!?`#j#o!/b#o#p!Cs#p#q!D[#q#r!EO#r#s!Ea#s$g$}$g~!/b<r%`R%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i7[%nR%r7[O#o%i#p#q%i#r~%iMg&[Z%o`%up%r7[%x!b%z#t%iS%lW$q1sOX%iXY&}Y[%i[]&}]p%ipq&}q#O%i#O#P'w#P#o%i#p#q%i#r~%iHP'UZ%r7[$q1sOX%iXY&}Y[%i[]&}]p%ipq&}q#O%i#O#P'w#P#o%i#p#q%i#r~%iHP'|V%r7[OY%iYZ&}Z]%i]^&}^#o%i#p#q%i#r~%i<u(tY%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`#T%i#T#U)t#U#f%i#f#g)t#g#h)t#h#o%i#p#q%i#r~%i7_)kRjR%r7[O#o%i#p#q%i#r~%i7_){R!kR%r7[O#o%i#p#q%i#r~%iG{*e]%vp%o`%r7[%x!b%iS%g,XOY+^YZ.{Z]+^]^.{^r+^rs/]s#O+^#O#P0|#P#o+^#o#p1b#p#q+^#q#r1b#r~+^Bm+g]%r7[%lW%g,XOY,`YZ%iZ],`]^%i^r,`rs-`s#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be,g]%r7[%g,XOY,`YZ%iZ],`]^%i^r,`rs-`s#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be-gR%r7[%g,XO#o%i#p#q%i#r~%iBe-uT%r7[O#o,`#o#p.U#p#q,`#q#r.U#r~,`,X.ZV%g,XOY.UZ].U^r.Urs.ps#O.U#O#P.u#P~.U,X.uO%g,X,X.xPO~.U7d/SR%r7[%lWO#o%i#p#q%i#r~%iEc/dX%r7[%g,XOr.{rs0Ps#O.{#O#P0c#P#o.{#o#p0w#p#q.{#q#r0w#r~.{Ec0YR%m#|%r7[%k,XO#o%i#p#q%i#r~%i7d0hT%r7[O#o.{#o#p0w#p#q.{#q#r0w#r~.{W0|O%lWBm1RT%r7[O#o+^#o#p1b#p#q+^#q#r1b#r~+^,a1iV%lW%g,XOY.UZ].U^r.Urs.ps#O.U#O#P.u#P~.UMg2cXQ1s%o`%up%r7[%x!b%z#t%iS%lWOY3OYZ%iZ]3O]^%i^#o3O#o#p3r#p#q3O#q#r3r#r~3OHP3VXQ1s%r7[OY3OYZ%iZ]3O]^%i^#o3O#o#p3r#p#q3O#q#r3r#r~3O1s3wRQ1sOY3rZ]3r^~3rGz4eT%PQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iBd4{R!t,W%r7[O#o%i#p#q%i#r~%iGz5iT$yQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iG{6X_%s`%up%r7[%z#t%lW%g,XOY7WYZ:dZ]7W]^:d^r7Wrs:xsw7Wwx;|x#O7W#O#P>n#P#o7W#o#p?t#p#q7W#q#r?S#r~7WFq7e]%r7[%x!b%z#t%iS%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be8e]%r7[%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be9cT%r7[O#o8^#o#p9r#p#q8^#q#r9r#r~8^,X9wV%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9r,X:aPO~9r;h:oR%r7[%x!b%z#t%iSO#o%i#p#q%i#r~%iC{;T]%r7[%x!b%iS%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Fq<VZ%r7[%z#t%g,XOr:drs<xsw:dwx=[x#O:d#O#P=p#P#o:d#o#p>_#p#q:d#q#r>U#r~:d8r=RR%r7[%x!b%iSO#o%i#p#q%i#r~%iFq=gR%j!f%r7[%z#t%h,XO#o%i#p#q%i#r~%i;h=uT%r7[O#o:d#o#p>U#p#q:d#q#r>U#r~:d%[>_O%x!b%z#t%iS%[>dP%iS#o#p>g%W>nO%x!b%z#tFq>sT%r7[O#o7W#o#p?S#p#q7W#q#r?S#r~7W0e?_V%x!b%z#t%iS%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9r0e?{X%iS%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P#o9r#o#p@h#p~9r0a@qV%x!b%z#t%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9rG{AkRf,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i<uBXR!PR%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iG{BuVT,X%o`%up%r7[%x!b%z#t%iS%lWOz%iz{C[{!_%i!_!`4t!`#o%i#p#q%i#r~%iBeCcT_R%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{DVT$|,X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iG{DyRx,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iMgEgU$},X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`!aEy!a#o%i#p#q%i#r~%i<vFQR&U&j%r7[O#o%i#p#q%i#r~%iG{FnV!eQ%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!PGT!P!Q%i!Q![Gy![#o%i#p#q%i#r~%iBeGYT%r7[O!O%i!O!PGi!P#o%i#p#q%i#r~%iBeGpR!n,X%r7[O#o%i#p#q%i#r~%iBcHQ_!g,V%r7[O!Q%i!Q![Gy![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#SGy#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBcIUX%r7[O{%i{|Iq|}%i}!OIq!O!Q%i!Q![JV![#o%i#p#q%i#r~%iBcIvT%r7[O!Q%i!Q![JV![#o%i#p#q%i#r~%iBcJ^Z!g,V%r7[O!Q%i!Q![JV![!l%i!l!mKP!m#R%i#R#SJV#S#^%i#^#_KP#_#o%i#p#q%i#r~%iBcKWR!g,V%r7[O#o%i#p#q%i#r~%iG{KtV%OR%o`%up%r7[%x!b%z#t%iS%lWO!P%i!P!QLZ!Q!_%i!_!`4t!`#o%i#p#q%i#r~%iBdLbT%QQ%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iGyMUm!g,V%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!P! P!P!Q%i!Q![!!k![!d%i!d!e!#w!e!g%i!g!hIP!h!l%i!l!mKP!m!q%i!q!r!%V!r!z%i!z!{!&_!{#R%i#R#S!!k#S#U%i#U#V!#w#V#X%i#X#YIP#Y#^%i#^#_KP#_#c%i#c#d!%V#d#l%i#l#m!&_#m#o%i#p#q%i#r~%iBc! UT%r7[O!Q%i!Q![! e![#o%i#p#q%i#r~%iBc! l_!g,V%r7[O!Q%i!Q![! e![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S! e#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBc!!ra!g,V%r7[O!O%i!O!P! P!P!Q%i!Q![!!k![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S!!k#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBc!#|W%r7[O!Q%i!Q!R!$f!R!S!$f!S#R%i#R#S!$f#S#o%i#p#q%i#r~%iBc!$mW!g,V%r7[O!Q%i!Q!R!$f!R!S!$f!S#R%i#R#S!$f#S#o%i#p#q%i#r~%iBc!%[V%r7[O!Q%i!Q!Y!%q!Y#R%i#R#S!%q#S#o%i#p#q%i#r~%iBc!%xV!g,V%r7[O!Q%i!Q!Y!%q!Y#R%i#R#S!%q#S#o%i#p#q%i#r~%iBc!&dZ%r7[O!Q%i!Q![!'V![!c%i!c!i!'V!i#R%i#R#S!'V#S#T%i#T#Z!'V#Z#o%i#p#q%i#r~%iBc!'^Z!g,V%r7[O!Q%i!Q![!'V![!c%i!c!i!'V!i#R%i#R#S!'V#S#T%i#T#Z!'V#Z#o%i#p#q%i#r~%iGy!(da!g,V%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!P! P!P!Q%i!Q![!!k![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S!!k#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iMg!)|Ty1s%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`!*]!`#o%i#p#q%i#r~%i7_!*dR%YR%r7[O#o%i#p#q%i#r~%iG{!+QR#_,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iG{!+nVjR%o`%up%r7[%x!b%z#t%iS%lWO!^%i!^!_!,T!_!`)d!`!a)d!a#o%i#p#q%i#r~%iBd!,[T$zQ%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{!-OT%X,X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`#o%i#p#q%i#r~%iG{!-rUjR%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`!a!.U!a#o%i#p#q%i#r~%iBd!.]T${Q%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{!/RT]Q#uP%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iMg!/wZ%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XO!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jHP!0sZ%r7[%f&j%S,XO!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!1{c%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!t!0j!t!u!6v!u!}!0j!}#R%i#R#S!0j#S#T%i#T#f!0j#f#g!6v#g#o!0j#p#q%i#r$g%i$g~!0jBe!3_]%r7[%g,XOY,`YZ%iZ],`]^%i^r,`rs!4Ws#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be!4_T%r7[%g,XOr%irs!4ns#o%i#p#q%i#r~%iBe!4uR%r7[%k,XO#o%i#p#q%i#r~%iBe!5V]%r7[%g,XOY8^YZ%iZ]8^]^%i^w8^wx!6Ox#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be!6VT%r7[%g,XOw%iwx!6fx#o%i#p#q%i#r~%iBe!6mR%r7[%h,XO#o%i#p#q%i#r~%iHP!7P_%r7[%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!8ec%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!9psw%iwx!:|x!Q%i!Q![!0j![!c%i!c!t!0j!t!u!<Y!u!}!0j!}#R%i#R#S!0j#S#T%i#T#f!0j#f#g!<Y#g#o!0j#p#q%i#r$g%i$g~!0jBe!9wT%r7[%t,XOr%irs!:Ws#o%i#p#q%i#r~%iBe!:]T%r7[Or%irs!:ls#o%i#p#q%i#r~%iBe!:sR%r7[%y,XO#o%i#p#q%i#r~%iBe!;TT%r7[%n,XOw%iwx!;dx#o%i#p#q%i#r~%iBe!;iT%r7[Ow%iwx!;xx#o%i#p#q%i#r~%iBe!<PR%r7[%w,XO#o%i#p#q%i#r~%iHP!<c_%r7[%f&j%S,XOr%irs!9psw%iwx!:|x!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!=wg%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!h!0j!h!i!<Y!i!t!0j!t!u!6v!u!}!0j!}#R%i#R#S!0j#S#T%i#T#U!0j#U#V!6v#V#Y!0j#Y#Z!<Y#Z#o!0j#p#q%i#r$g%i$g~!0jMg!?u_%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jG{!AXR!W,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iMg!AgX%r7[OY$}YZ%wZ]$}]^%w^#o$}#o#p!BS#p#q$}#q#r!BS#r~$}&f!BcO%o`%up%x!b%z#t%iS%lW<u!BvR!XR%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iGz!CdT$xQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iGy!C|P![Gm%iS%lW#o#p!DP&Y!D[O%o`%up%x!b%z#tGz!DoT$wQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%i<u!EaO!]7_%o`%up%x!b%z#t%iS%lWGy!EtR%R,V%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i",
  tokenizers: [legacyPrint, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, newlines, bodyContinue],
  topRules: {"Script":[0,3]},
  specialized: [{term: 188, get: value => spec_identifier[value] || -1}],
  tokenPrec: 6067
});

exports.parser = parser;


/***/ }),

/***/ "./node_modules/lezer-tree/dist/tree.cjs":
/*!***********************************************!*\
  !*** ./node_modules/lezer-tree/dist/tree.cjs ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

/// The default maximum length of a `TreeBuffer` node.
const DefaultBufferLength = 1024;
let nextPropID = 0;
const CachedNode = new WeakMap();
/// Each [node type](#tree.NodeType) can have metadata associated with
/// it in props. Instances of this class represent prop names.
class NodeProp {
    /// Create a new node prop type. You can optionally pass a
    /// `deserialize` function.
    constructor({ deserialize } = {}) {
        this.id = nextPropID++;
        this.deserialize = deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// Create a string-valued node prop whose deserialize function is
    /// the identity function.
    static string() { return new NodeProp({ deserialize: str => str }); }
    /// Create a number-valued node prop whose deserialize function is
    /// just `Number`.
    static number() { return new NodeProp({ deserialize: Number }); }
    /// Creates a boolean-valued node prop whose deserialize function
    /// returns true for any input.
    static flag() { return new NodeProp({ deserialize: () => true }); }
    /// Store a value for this prop in the given object. This can be
    /// useful when building up a prop object to pass to the
    /// [`NodeType`](#tree.NodeType) constructor. Returns its first
    /// argument.
    set(propObj, value) {
        propObj[this.id] = value;
        return propObj;
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#tree.NodeSet.extend) or
    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop
    /// values for each node type in the set. Takes a [match
    /// object](#tree.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src)
                    src[0].set(props, src[1]);
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#tree.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#tree.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a number array. Each parser
/// [has](#lezer.Parser.nodeSet) a node set, and [tree
/// buffers](#tree.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536)
/// node types in it, so that the ids fit into 16-bit typed array
/// slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#tree.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    add[0].set(newProps, add[1]);
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the `TreeCursor` interface instead, which provides a view on
/// some part of this data structure, and can be used to move around
/// to adjacent nodes.
class Tree {
    /// Construct a new tree. You usually want to go through
    /// [`Tree.build`](#tree.Tree^build) instead.
    constructor(type, 
    /// The tree's child nodes. Children small enough to fit in a
    /// `TreeBuffer will be represented as such, other children can be
    /// further `Tree` instances with their own internal structure.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
    }
    /// @internal
    toString() {
        let children = this.children.map(c => c.toString()).join();
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular
    /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)
    /// nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, true);
    }
    /// Get a [syntax node](#tree.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#tree.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        return this.cursor(pos, side).node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, the given node
    /// will not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor();;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Balance the direct children of this tree.
    balance(maxBufferLength = DefaultBufferLength) {
        return this.children.length <= BalanceBranchFactor ? this
            : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length);
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer @internal
    constructor(
    /// @internal
    buffer, 
    // The total length of the group of nodes in the buffer.
    length, 
    /// @internal
    set, type = NodeType.none) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
        this.type = type;
    }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, after) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (after != -100000000 /* None */) {
                let start = buffer[i + 1], end = buffer[i + 2];
                if (dir > 0) {
                    if (end > after)
                        pick = i;
                    if (end > after)
                        break;
                }
                else {
                    if (start < after)
                        pick = i;
                    if (end >= after)
                        break;
                }
            }
            else {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
}
class TreeNode {
    constructor(node, from, index, _parent) {
        this.node = node;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get to() { return this.from + this.node.length; }
    nextChild(i, dir, after, full = false) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (after != -100000000 /* None */ && (dir < 0 ? start >= after : start + next.length <= after))
                    continue;
                if (next instanceof TreeBuffer) {
                    let index = next.findChild(0, next.buffer.length, dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - start);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if (full || (!next.type.isAnonymous || hasChild(next))) {
                    let inner = new TreeNode(next, start, i, parent);
                    return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);
                }
            }
            if (full || !parent.type.isAnonymous)
                return null;
            i = parent.index + dir;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, -100000000 /* None */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, -100000000 /* None */); }
    childAfter(pos) { return this.nextChild(0, 1, pos); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos); }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;
    }
    get prevSibling() {
        return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, after) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.context.start);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, -100000000 /* None */); }
    get lastChild() { return this.child(-1, -100000000 /* None */); }
    childAfter(pos) { return this.child(1, pos); }
    childBefore(pos) { return this.child(-1, pos); }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, full = false) {
        this.full = full;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enter(dir, after) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.buffer.start);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enter(1, -100000000 /* None */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enter(-1, -100000000 /* None */); }
    /// Move the cursor to the first child that starts at or after `pos`.
    childAfter(pos) { return this.enter(1, pos); }
    /// Move to the last child that ends at or before `pos`.
    childBefore(pos) { return this.enter(-1, pos); }
    /// Move the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000 /* None */, this.full));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000 /* None */, this.full)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                let child = parent.node.children[i];
                if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))
                    return false;
            }
        }
        return true;
    }
    move(dir) {
        if (this.enter(dir, -100000000 /* None */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty, its next sibling or the next sibling of
    /// the first parent node that has one.
    next() { return this.move(1); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by ist last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev() { return this.move(-1); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        for (;;) {
            if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))
                break;
            if (this.from == this.to ||
                (side < 1 ? this.from >= pos : this.from > pos) ||
                (side > -1 ? this.to <= pos : this.to < pos)) {
                this.parent();
                break;
            }
        }
        return this;
    }
    /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#tree.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#tree.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));
}
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
const BalanceBranchFactor = 8;
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        while (id == inRepeat) {
            cursor.next();
            ({ id, start, end, size } = cursor);
        }
        let startPos = start - parentStart;
        if (size < 0) { // Reused node
            children.push(reused[id]);
            positions.push(startPos);
            cursor.next();
            return;
        }
        let type = types[id], node, buffer;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index, inRepeat);
            node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            while (cursor.pos > endPos)
                takeNode(start, endPos, localChildren, localPositions, localInRepeat);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)
                node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start);
            else
                node = new Tree(type, localChildren, localPositions, end - start);
        }
        children.push(node);
        positions.push(startPos);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let nodeSize = fork.size, startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0)
                    break scan;
                if (fork.id >= minRepeatType)
                    localSkipped += 4;
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index, inRepeat) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (id == inRepeat)
            return index;
        let startIndex = index;
        if (size > 4) {
            let endPos = cursor.pos - (size - 4);
            while (cursor.pos > endPos)
                index = copyToBuffer(bufferStart, buffer, index, inRepeat);
        }
        if (id < minRepeatType) { // Don't copy repeat nodes into buffers
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[topID], children.reverse(), positions.reverse(), length);
}
function balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length) {
    let localChildren = [], localPositions = [];
    if (length <= maxBufferLength) {
        for (let i = from; i < to; i++) {
            localChildren.push(children[i]);
            localPositions.push(positions[i] - start);
        }
    }
    else {
        let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i];
            i++;
            for (; i < to; i++) {
                let nextEnd = positions[i] + children[i].length;
                if (nextEnd - groupStart > maxChild)
                    break;
            }
            if (i == groupFrom + 1) {
                let only = children[groupFrom];
                if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse
                    for (let j = 0; j < only.children.length; j++) {
                        localChildren.push(only.children[j]);
                        localPositions.push(only.positions[j] + groupStart - start);
                    }
                    continue;
                }
                localChildren.push(only);
            }
            else if (i == groupFrom + 1) {
                localChildren.push(children[groupFrom]);
            }
            else {
                let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart);
                if (innerType != NodeType.none && !containsType(inner.children, innerType))
                    inner = new Tree(NodeType.none, inner.children, inner.positions, inner.length);
                localChildren.push(inner);
            }
            localPositions.push(groupStart - start);
        }
    }
    return new Tree(outerType, localChildren, localPositions, length);
}
function containsType(nodes, type) {
    for (let elt of nodes)
        if (elt.type == type)
            return true;
    return false;
}
/// Tree fragments are used during [incremental
/// parsing](#lezer.ParseOptions.fragments) to track parts of old
/// trees that can be reused in a new parse. An array of fragments is
/// used to track regions of an old tree whose nodes might be reused
/// in new parses. Use the static
/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update
/// fragments for document changes.
class TreeFragment {
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, open) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = open;
    }
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        let cI = 0, pos = 0, off = 0;
        for (;;) {
            let nextC = cI < changes.length ? changes[cI++] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null :
                            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 /* Start */ : 0) | (nextC ? 2 /* End */ : 0));
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the token at its
    /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 /* End */ : 0)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
}
// Creates an `Input` that is backed by a single, flat string.
function stringInput(input) { return new StringInput(input); }
class StringInput {
    constructor(string, length = string.length) {
        this.string = string;
        this.length = length;
    }
    get(pos) {
        return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);
    }
    lineAfter(pos) {
        if (pos < 0)
            return "";
        let end = this.string.indexOf("\n", pos);
        return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));
    }
    read(from, to) { return this.string.slice(from, Math.min(this.length, to)); }
    clip(at) { return new StringInput(this.string, at); }
}

exports.DefaultBufferLength = DefaultBufferLength;
exports.NodeProp = NodeProp;
exports.NodeSet = NodeSet;
exports.NodeType = NodeType;
exports.Tree = Tree;
exports.TreeBuffer = TreeBuffer;
exports.TreeCursor = TreeCursor;
exports.TreeFragment = TreeFragment;
exports.stringInput = stringInput;
//# sourceMappingURL=tree.cjs.map


/***/ }),

/***/ "./node_modules/lezer/dist/index.cjs":
/*!*******************************************!*\
  !*** ./node_modules/lezer/dist/index.cjs ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var lezerTree = __webpack_require__(/*! lezer-tree */ "./node_modules/lezer-tree/dist/tree.cjs");

/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// A group of values that the stack will share with all
    /// split instances
    ///@internal
    cx, 
    /// Holds state, pos, value stack pos (15 bits array index, 15 bits
    /// buffer index) triplets for all but the top state
    /// @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.cx = cx;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(cx, state, pos = 0) {
        return new Stack(cx, [], state, pos, pos, 0, [], 0, null);
    }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.cx;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            // Zero-depth reductions are a special case—they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let start = this.pos, nextState = action, { parser } = this.cx;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            if (next <= this.cx.parser.maxNode)
                this.buffer.push(next, this.pos, nextEnd, 4);
            this.pos = nextEnd;
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt node into the buffer. This may be a reused node or
    // the result of running a nested parser.
    /// @internal
    useNode(value, next) {
        let index = this.cx.reused.length - 1;
        if (index < 0 || this.cx.reused[index] != value) {
            this.cx.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.cx.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 200 /* Token */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.cx.parser.stateSlot(sim.top, 4 /* DefaultReduce */) || this.cx.parser.hasAction(sim.top, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    /// Find the start position of the rule that is currently being parsed.
    get ruleStart() {
        for (let state = this.state, base = this.stack.length;;) {
            let force = this.cx.parser.stateSlot(state, 5 /* ForcedReduce */);
            if (!(force & 65536 /* ReduceFlag */))
                return 0;
            base -= 3 * (force >> 19 /* ReduceDepthShift */);
            if ((force & 65535 /* ValueMask */) < this.cx.parser.minRepeatTerm)
                return this.stack[base + 1];
            state = this.stack[base];
        }
    }
    /// Find the start position of an instance of any of the given term
    /// types, or return `null` when none of them are found.
    ///
    /// **Note:** this is only reliable when there is at least some
    /// state that unambiguously matches the given rule on the stack.
    /// I.e. if you have a grammar like this, where the difference
    /// between `a` and `b` is only apparent at the third token:
    ///
    ///     a { b | c }
    ///     b { "x" "y" "x" }
    ///     c { "x" "y" "z" }
    ///
    /// Then a parse state after `"x"` will not reliably tell you that
    /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check
    /// for either of those two rules (assuming that `a` isn't part of
    /// some rule that includes other things starting with `"x"`).
    ///
    /// When `before` is given, this keeps scanning up the stack until
    /// it finds a match that starts before that position.
    startOf(types, before) {
        let state = this.state, frame = this.stack.length, { parser } = this.cx;
        for (;;) {
            let force = parser.stateSlot(state, 5 /* ForcedReduce */);
            let depth = force >> 19 /* ReduceDepthShift */, term = force & 65535 /* ValueMask */;
            if (types.indexOf(term) > -1) {
                let base = frame - (3 * (force >> 19 /* ReduceDepthShift */)), pos = this.stack[base + 1];
                if (before == null || before > pos)
                    return pos;
            }
            if (frame == 0)
                return null;
            if (depth == 0) {
                frame -= 3;
                state = this.stack[frame];
            }
            else {
                frame -= 3 * (depth - 1);
                state = parser.getGoto(this.stack[frame - 3], term, true);
            }
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.cx.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = nextStates.filter(s => s != this.state && this.cx.parser.hasAction(s, next));
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ && i < nextStates.length; i++)
                    if (best.indexOf(nextStates[i]) < 0)
                        best.push(nextStates[i]);
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i++) {
            if (nextStates[i] == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(nextStates[i], this.pos);
            stack.score -= 200 /* Token */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.cx.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        if (!this.cx.parser.validAction(this.state, reduce)) {
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.cx.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.cx;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.cx.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.cx.parser.dialect.flags[dialectID]; }
}
var Recover;
(function (Recover) {
    Recover[Recover["Token"] = 200] = "Token";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(stack) {
        this.stack = stack;
        this.top = stack.state;
        this.rest = stack.stack;
        this.offset = this.rest.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.rest == this.stack.stack)
                this.rest = this.rest.slice();
            this.rest.push(this.top, 0, 0);
            this.offset += 3;
        }
        else {
            this.offset -= (depth - 1) * 3;
        }
        let goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);
        this.top = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack) {
        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

/// Tokenizers write the tokens they read into instances of this class.
class Token {
    constructor() {
        /// The start of the token. This is set by the parser, and should not
        /// be mutated by the tokenizer.
        this.start = -1;
        /// This starts at -1, and should be updated to a term id when a
        /// matching token is found.
        this.value = -1;
        /// When setting `.value`, you should also set `.end` to the end
        /// position of the token. (You'll usually want to use the `accept`
        /// method.)
        this.end = -1;
    }
    /// Accept a token, setting `value` and `end` to the given values.
    accept(value, end) {
        this.value = value;
        this.end = end;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, token, stack) { readToken(this.data, input, token, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// Exports that are used for `@external tokens` in the grammar should
/// export an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream and a token object,
    /// [fills](#lezer.Token.accept) the token object if it recognizes a
    /// token. `token.start` should be used as the start position to
    /// scan from.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, token, stack, group) {
    let state = 0, groupMask = 1 << group, dialect = stack.cx.parser.dialect;
    scan: for (let pos = token.start;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (token.value == -1 || token.value == term || stack.cx.parser.overrides(term, token.value))) {
                    token.accept(term, pos);
                    break;
                }
            }
        let next = input.get(pos++);
        // Do a binary search on the state's edges
        for (let low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
function cutAt(tree, pos, side) {
    let cursor = tree.cursor(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to <= pos : cursor.from >= pos) && !cursor.type.isError)
                    return side < 0 ? cursor.to - 1 : cursor.from + 1;
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments) {
        this.fragments = fragments;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            else if (start == pos && start + next.length <= this.safeTo) {
                return start == pos && start >= this.safeFrom ? next : null;
            }
            if (next instanceof lezerTree.TreeBuffer) {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
            else {
                this.index[last]++;
                if (start + next.length >= pos) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
        }
    }
}
class CachedToken extends Token {
    constructor() {
        super(...arguments);
        this.extended = -1;
        this.mask = 0;
    }
    clear(start) {
        this.start = start;
        this.value = this.extended = -1;
    }
}
const dummyToken = new Token;
class TokenCache {
    constructor(parser) {
        this.tokens = [];
        this.mainToken = dummyToken;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack, input) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.cx, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask) {
                this.updateCachedToken(token, tokenizer, stack, input);
                token.mask = mask;
            }
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (!main) {
            main = dummyToken;
            main.start = stack.pos;
            if (stack.pos == input.length)
                main.accept(stack.cx.parser.eofTerm, stack.pos);
            else
                main.accept(0 /* Err */, stack.pos + 1);
        }
        this.mainToken = main;
        return this.actions;
    }
    updateCachedToken(token, tokenizer, stack, input) {
        token.clear(stack.pos);
        tokenizer.token(input, token, stack);
        if (token.value > -1) {
            let { parser } = stack.cx;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](input.read(token.start, token.end), stack);
                    if (result >= 0 && stack.cx.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else if (stack.pos == input.length) {
            token.accept(stack.cx.parser.eofTerm, stack.pos);
        }
        else {
            token.accept(0 /* Err */, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.cx, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 1), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    Rec[Rec["MinBufferLengthPrune"] = 200] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
})(Rec || (Rec = {}));
/// A parse context can be used for step-by-step parsing. After
/// creating it, you repeatedly call `.advance()` until it returns a
/// tree to indicate it has reached the end of the parse.
class Parse {
    constructor(parser, input, startPos, context) {
        this.parser = parser;
        this.input = input;
        this.startPos = startPos;
        this.context = context;
        // The position to which the parse has advanced.
        this.pos = 0;
        this.recovering = 0;
        this.nextStackID = 0x2654;
        this.nested = null;
        this.nestEnd = 0;
        this.nestWrap = null;
        this.reused = [];
        this.tokens = new TokenCache(parser);
        this.topTerm = parser.top[1];
        this.stacks = [Stack.start(this, parser.top[0], this.startPos)];
        let fragments = context === null || context === void 0 ? void 0 : context.fragments;
        this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        if (this.nested) {
            let result = this.nested.advance();
            this.pos = this.nested.pos;
            if (result) {
                this.finishNested(this.stacks[0], result);
                this.nested = null;
            }
            return null;
        }
        let stacks = this.stacks, pos = this.pos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        let maybeNest;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], nest;
            for (;;) {
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (nest = this.checkNest(stack)) {
                    if (!maybeNest || maybeNest.stack.score < stack.score)
                        maybeNest = nest;
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.mainToken;
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (maybeNest) {
            this.startNested(maybeNest);
            return null;
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + this.parser.getName(this.tokens.mainToken.value));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 200 /* MinBufferLengthPrune */ && other.buffer.length > 200 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.pos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.pos)
                this.pos = newStacks[i].pos;
        return null;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { input, parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.fragments) {
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof lezerTree.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof lezerTree.Tree)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        let actions = this.tokens.getActions(stack, input);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            let nest = this.checkNest(stack);
            if (nest)
                return nest;
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        let maybeNest;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done) {
                    if (done !== true)
                        maybeNest = done;
                    continue;
                }
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done) {
                    if (done !== true)
                        maybeNest = done;
                    break;
                }
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.input.length > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        if (finished)
            return finished;
        if (maybeNest)
            for (let s of this.stacks)
                if (s.score > maybeNest.stack.score) {
                    maybeNest = undefined;
                    break;
                }
        if (maybeNest)
            this.startNested(maybeNest);
        return null;
    }
    forceFinish() {
        let stack = this.stacks[0].split();
        if (this.nested)
            this.finishNested(stack, this.nested.forceFinish());
        return this.stackToTree(stack.forceAll());
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack, pos = stack.pos) {
        return lezerTree.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.startPos,
            length: pos - this.startPos,
            minRepeatType: this.parser.minRepeatTerm });
    }
    checkNest(stack) {
        let info = this.parser.findNested(stack.state);
        if (!info)
            return null;
        let spec = info.value;
        if (typeof spec == "function")
            spec = spec(this.input, stack);
        return spec ? { stack, info, spec } : null;
    }
    startNested(nest) {
        let { stack, info, spec } = nest;
        this.stacks = [stack];
        this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);
        this.nestWrap = typeof spec.wrapType == "number" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;
        if (spec.startParse) {
            this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);
        }
        else {
            this.finishNested(stack);
        }
    }
    scanForNestEnd(stack, endToken, filter) {
        for (let pos = stack.pos; pos < this.input.length; pos++) {
            dummyToken.start = pos;
            dummyToken.value = -1;
            endToken.token(this.input, dummyToken, stack);
            if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end))))
                return pos;
        }
        return this.input.length;
    }
    finishNested(stack, tree) {
        if (this.nestWrap)
            tree = new lezerTree.Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos);
        else if (!tree)
            tree = new lezerTree.Tree(lezerTree.NodeType.none, [], [], this.nestEnd - stack.pos);
        let info = this.parser.findNested(stack.state);
        stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));
        if (verbose)
            console.log(this.stackID(stack) + ` (via unnest)`);
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class Parser {
    /// @internal
    constructor(spec) {
        /// @internal
        this.bufferLength = lezerTree.DefaultBufferLength;
        /// @internal
        this.strict = false;
        this.nextStateCache = [];
        this.cachedDialect = null;
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let tokenArray = decodeArray(spec.tokenData);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        this.nodeSet = new lezerTree.NodeSet(nodeNames.map((name, i) => lezerTree.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {
            return { name, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder };
        });
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        for (let i = 0, l = this.states.length / 6 /* Size */; i < l; i++)
            this.nextStateCache[i] = null;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    /// Parse a given string or stream.
    parse(input, startPos = 0, context = {}) {
        if (typeof input == "string")
            input = lezerTree.stringInput(input);
        let cx = new Parse(this, input, startPos, context);
        for (;;) {
            let done = cx.advance();
            if (done)
                return done;
        }
    }
    /// Start an incremental parse.
    startParse(input, startPos = 0, context = {}) {
        if (typeof input == "string")
            input = lezerTree.stringInput(input);
        return new Parse(this, input, startPos, context);
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    findNested(state) {
        let flags = this.stateSlot(state, 0 /* Flags */);
        return flags & 4 /* StartNest */ ? this.nested[flags >> 10 /* NestShift */] : null;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let cached = this.nextStateCache[state];
        if (cached)
            return cached;
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0 && result.indexOf(this.data[i + 1]) < 0)
                result.push(this.data[i + 1]);
        }
        let table = this.goto, max = table[0];
        for (let term = 0; term < max; term++) {
            for (let pos = table[term + 1];;) {
                let groupTag = table[pos++], target = table[pos++];
                for (let end = pos + (groupTag >> 1); pos < end; pos++)
                    if (table[pos] == state && result.indexOf(target) < 0)
                        result.push(target);
                if (groupTag & 1)
                    break;
            }
        }
        return this.nextStateCache[state] = result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(Parser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.nested)
            copy.nested = this.nested.map(obj => {
                if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name))
                    return obj;
                return { name: obj.name, value: config.nested[obj.name], end: obj.end, placeholder: obj.placeholder };
            });
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// Tells you whether this grammar has any nested grammars.
    get hasNested() { return this.nested.length > 0; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        if (this.cachedDialect && this.cachedDialect.source == dialect)
            return this.cachedDialect;
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return this.cachedDialect = new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new Parser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        if (stack.pos == stack.cx.input.length &&
            stack.cx.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}

exports.NodeProp = lezerTree.NodeProp;
exports.NodeSet = lezerTree.NodeSet;
exports.NodeType = lezerTree.NodeType;
exports.Tree = lezerTree.Tree;
exports.TreeCursor = lezerTree.TreeCursor;
exports.ExternalTokenizer = ExternalTokenizer;
exports.Parser = Parser;
exports.Stack = Stack;
exports.Token = Token;
//# sourceMappingURL=index.cjs.map


/***/ }),

/***/ "./ast.ts":
/*!****************!*\
  !*** ./ast.ts ***!
  \****************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isuniOp = exports.issameOp = exports.isboolOp = exports.isintOp = exports.isOp = void 0;
var int_ops = { "+": true, "-": true, "*": true, "//": true, "%": true,
    ">": true, "<": true, ">=": true, "<=": true };
var same_ops = { "==": true, "!=": true };
var bool_ops = { "and": true, "or": true };
var spec_ops = { "is": true };
var uni_ops = { "not": true, "-": true };
function isOp(maybeOp) {
    return maybeOp in int_ops || maybeOp in bool_ops || maybeOp in same_ops || maybeOp in spec_ops;
}
exports.isOp = isOp;
function isintOp(maybeOp) {
    return maybeOp in int_ops;
}
exports.isintOp = isintOp;
function isboolOp(maybeOp) {
    return maybeOp in bool_ops;
}
exports.isboolOp = isboolOp;
function issameOp(maybeOp) {
    return maybeOp in same_ops;
}
exports.issameOp = issameOp;
function isuniOp(maybeOp) {
    return maybeOp in uni_ops;
}
exports.isuniOp = isuniOp;


/***/ }),

/***/ "./compiler.ts":
/*!*********************!*\
  !*** ./compiler.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compile = exports.codeGenStmt = exports.codeGenClass = exports.codeGenFunDef = exports.codeGenExpr = exports.opStmts = exports.runwatsrc = void 0;
var wabt_1 = __importDefault(__webpack_require__(/*! wabt */ "wabt"));
var parser_1 = __webpack_require__(/*! ./parser */ "./parser.ts");
var tc_1 = __webpack_require__(/*! ./tc */ "./tc.ts");
var loop_counter = 0;
var obj_field_type_idx;
var classes = new Map();
var obj_name_reg = "none";
var tmp_vars = [];
var unassigned_cls = 0;
var decl_of_funcs = [];
function variableNames(stmts, class_name) {
    if (class_name === void 0) { class_name = ""; }
    var vars = [];
    stmts.forEach(function (stmt) {
        if (stmt.tag === "assign" && !(vars.includes(stmt.name))) {
            if (class_name != "") {
                vars.push("".concat(class_name, ".").concat(stmt.name));
            }
            else {
                vars.push(stmt.name);
            }
        }
    });
    return vars;
}
function funs(stmts) {
    return stmts.filter(function (stmt) { return stmt.tag === "define"; });
}
function nonFuns(stmts) {
    return stmts.filter(function (stmt) { return stmt.tag !== "define"; });
}
function varsFunsStmts(stmts) {
    return [variableNames(stmts), funs(stmts), nonFuns(stmts)];
}
function runwatsrc(watSource, config) {
    return __awaiter(this, void 0, void 0, function () {
        var wabtApi, parsed, binary, wasmModule;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, wabt_1.default)()];
                case 1:
                    wabtApi = _a.sent();
                    parsed = wabtApi.parseWat("example", watSource);
                    binary = parsed.toBinary({});
                    return [4 /*yield*/, WebAssembly.instantiate(binary.buffer, config)];
                case 2:
                    wasmModule = _a.sent();
                    return [2 /*return*/, wasmModule.instance.exports._start()];
            }
        });
    });
}
exports.runwatsrc = runwatsrc;
function opStmts(op) {
    switch (op) {
        case "+": return ["i32.add"];
        case "-": return ["i32.sub"];
        case "*": return ["i32.mul"];
        case "//": return ["i32.div_s"];
        case "%": return ["i32.rem_s"];
        case ">": return ["i32.gt_s"];
        case "<": return ["i32.lt_s"];
        case ">=": return ["i32.ge_s"];
        case "<=": return ["i32.le_s"];
        case "==": return ["i32.eq"];
        case "!=": return ["i32.ne"];
        case "and": return ["i32.and"];
        case "or": return ["i32.or"];
        default:
            throw new Error("[Compiler.ts]Unhandled or unknown op: ".concat(op));
    }
}
exports.opStmts = opStmts;
function codeGenExpr(expr, locals) {
    var emptyEnv = new Map();
    switch (expr.tag) {
        case "number": return ["(i32.const ".concat(expr.value, ")")];
        case "true": return ["(i32.const 1)"];
        case "false": return ["(i32.const 0)"];
        case "none": return ["(i32.const 0)"];
        case "id":
            // Since we type-checked for making sure all variable exist, here we
            // just check if it's a local variable and assume it is global if not
            if (locals.has(expr.name)) {
                return ["(local.get $".concat(expr.name, ")")];
            }
            else {
                return ["(global.get $".concat(expr.name, ")")];
            }
        case "binop": {
            var lhsExprs = codeGenExpr(expr.lhs, locals);
            var rhsExprs = codeGenExpr(expr.rhs, locals);
            if (expr.op == 'is') {
                console.log("compiler lhs/rhs: ", expr.lhs, expr.rhs);
                console.log(expr.lhs.a == expr.rhs.a, expr.lhs.a === expr.rhs.a);
                if (expr.lhs.a === expr.rhs.a) {
                    // Same like return true
                    return ["(i32.const 1)"];
                }
                else {
                    return ["(i32.const 0)"];
                }
            }
            var opstmts = opStmts(expr.op);
            return __spreadArray(__spreadArray(__spreadArray([], lhsExprs, true), rhsExprs, true), opstmts, true);
        }
        case "call":
            console.log("classes:", classes);
            if (classes.has(expr.name)) {
                // Instantiate a new obj of class 'expr.name'
                var initvals = [];
                var classdata = classes.get(expr.name);
                if (classdata.tag != "class") {
                    throw new Error("Classdata has an non-class tag");
                }
                else {
                    // First we compile its field
                    if (obj_name_reg == "none") {
                        // Call class without an obj assignment
                        var tmp_obj_name = "RESERVED_".concat(unassigned_cls);
                        console.log("Creating tmp var ".concat(tmp_obj_name));
                        console.log("TMP_VARS: ".concat(tmp_vars));
                        tmp_vars.push(tmp_obj_name);
                        var str_push_tmp_name = "global.set $".concat(tmp_obj_name);
                        var prev_obj_name_reg = obj_name_reg;
                        obj_name_reg = tmp_obj_name;
                    }
                    classdata.fields.forEach(function (f, index) {
                        var offset = index * 4;
                        if (f.tag != "assign") {
                            throw new Error("field ".concat(f, " does not have an 'assign' tag"));
                        }
                        else {
                            var valToBe = codeGenExpr(f.value, locals);
                            if (valToBe.length > 1) {
                                throw new Error("The compiled fields is not a literal");
                            }
                            if (obj_field_type_idx.get(expr.name) === undefined) {
                                console.log("detect undefind for OFI: ".concat(expr.name));
                                obj_field_type_idx.set(expr.name, new Map());
                            }
                            if (obj_field_type_idx.get(obj_name_reg) === undefined) {
                                obj_field_type_idx.set(obj_name_reg, new Map());
                            }
                            console.log("adding this entry:".concat(f.name, ",").concat(index));
                            obj_field_type_idx.get(expr.name).set(f.name, [f.a, index]);
                            obj_field_type_idx.get(obj_name_reg).set(f.name, [f.a, index]);
                        }
                        initvals = __spreadArray(__spreadArray([], initvals, true), [
                            "(global.get $heap)",
                            "(i32.add (i32.const ".concat(offset, "))"),
                            valToBe[0],
                            "i32.store"
                        ], false);
                    });
                    console.log("ONR:", obj_name_reg);
                    classdata.methods.forEach(function (func, f_name) {
                        var new_name = "".concat(f_name, "$").concat(obj_name_reg);
                        var func_string = codeGenFunDef(__assign(__assign({}, func), { name: new_name }));
                        decl_of_funcs = [decl_of_funcs.join() + func_string.join()];
                        console.log("DOF:", decl_of_funcs);
                    });
                    var init_method;
                    if (classdata.methods.has("__init__")) {
                        init_method = "(call $__init__$".concat(obj_name_reg, ")");
                    }
                    decl_of_funcs = decl_of_funcs.flat();
                    console.log("DOF after flat:", decl_of_funcs);
                    if (prev_obj_name_reg !== undefined) {
                        obj_name_reg = prev_obj_name_reg;
                    }
                    var return_str;
                    return_str = __spreadArray(__spreadArray([], initvals, true), [
                        "(global.get $heap)",
                        "(global.set $heap (i32.add (global.get $heap) (i32.const ".concat(classdata.fields.length * 4, ")))"),
                        "(global.set $".concat(obj_name_reg, ")")
                    ], false);
                    console.log("STR TO PUSH", str_push_tmp_name);
                    if (str_push_tmp_name !== undefined) {
                        return_str.push(str_push_tmp_name);
                    }
                    if (init_method != undefined) {
                        return_str.push(init_method);
                        return_str.push("(local.set $scratch)");
                    }
                    return_str.push("(global.get $".concat(obj_name_reg, ")"));
                    return return_str;
                }
            }
            var valStmts = expr.args.map(function (e) { return codeGenExpr(e, locals); }).flat();
            var toCall = expr.name;
            if (expr.name === "print") {
                console.log("parse print, a = " + expr.args[0]);
                switch (expr.args[0].a) {
                    case "bool":
                        toCall = "print_bool";
                        break;
                    case "int":
                        toCall = "print_num";
                        break;
                    case "none":
                        toCall = "print_none";
                        break;
                    default:
                        throw new Error("PRINT ERROR: annotation = ".concat(expr.args[0].a));
                        break;
                }
            }
            valStmts.push("(call $".concat(toCall, ")"));
            console.log(valStmts);
            return valStmts;
        case "method":
            if (expr.tag == "method") {
                //Tricky here, use empty env to init
                var argInstrs = expr.args.map(function (a) { return codeGenExpr(a, emptyEnv); }).flat();
                var anno_obj = expr.obj.a;
                var method_support_type = void 0;
                (function (method_support_type) {
                    method_support_type[method_support_type["id"] = 0] = "id";
                    method_support_type[method_support_type["method"] = 1] = "method";
                    method_support_type[method_support_type["getfield"] = 2] = "getfield";
                    method_support_type[method_support_type["call"] = 3] = "call";
                })(method_support_type || (method_support_type = {}));
                if (anno_obj != "int" && anno_obj != "none" && anno_obj != "bool") {
                    var eobj = expr.obj;
                    var eobj_stmt = [];
                    var tmp_name = obj_name_reg;
                    if (eobj.tag == "id") {
                    }
                    else {
                        // Currently it can be a call
                        var prev_length = tmp_vars.length;
                        var eobj_stmt = codeGenExpr(eobj, locals);
                        if (prev_length != tmp_vars.length) {
                            tmp_name = tmp_vars[tmp_vars.length - 1];
                        }
                    }
                    if (eobj.tag == 'self') {
                        eobj = { tag: 'id', name: obj_name_reg, a: eobj.a };
                    }
                    if (eobj.tag == "id" || eobj.tag == "method" || eobj.tag == "getfield" || eobj.tag == "call") {
                        var method_stmts;
                        if (eobj_stmt.length > 0) {
                            console.log("Got recursive expr in obj: tmp_name", tmp_name);
                            method_stmts = __spreadArray(__spreadArray(__spreadArray([], eobj_stmt, true), argInstrs, true), ["call $".concat(expr.name, "$").concat(tmp_name)], false);
                        }
                        else {
                            method_stmts = __spreadArray(__spreadArray([], argInstrs, true), ["call $".concat(expr.name, "$").concat(eobj.name)], false);
                        }
                    }
                    else {
                        throw new Error("Here obj tag must be supported");
                    }
                }
            }
            console.log("method_stmts:", method_stmts);
            return method_stmts;
        case "getfield":
            var anno = expr.obj.a;
            if (anno != "int" && anno != "none" && anno != "bool") {
                var objexprs = codeGenExpr(expr.obj, locals);
                // if (expr.obj.tag=="self"){
                //   //donothing
                // }else{
                // }
                if (expr.obj.tag != 'id') {
                    if (expr.obj.tag == 'self') {
                        expr.a = obj_field_type_idx.get(obj_name_reg).get(expr.name)[0];
                        expr.obj = { tag: 'id', name: obj_name_reg, a: expr.obj.a };
                    }
                    else {
                        throw new Error("obj tag is not 'id' or 'self', instead it's ".concat(expr.obj.tag));
                    }
                }
                var objdata = obj_field_type_idx.get(expr.obj.name);
                if (objdata === undefined) {
                    throw new Error("RUNTIME ERROR: objdata of ".concat(expr.obj.name, " is undefined"));
                }
                console.log("getfield ".concat(expr.name, " of ").concat(expr.obj.name, ", objdata"));
                var iof = objdata.get(expr.name)[1];
                return ["(global.get $".concat(expr.obj.name, ")"), "(i32.add (i32.const ".concat(iof * 4, "))"), "(i32.load)"];
            }
            else {
                throw new Error("obj get an annotation of ".concat(anno));
            }
        case "self":
            if (locals.has(obj_name_reg)) {
                return ["(local.get $".concat(obj_name_reg, ")")];
            }
            else {
                return ["(global.get $".concat(obj_name_reg, ")")];
            }
        default:
            throw new Error("Expr ".concat(expr, " not implemented!"));
    }
}
exports.codeGenExpr = codeGenExpr;
function codeGenFunDef(m) {
    var emptyEnv = new Map();
    var withParamsAndVariables = new Map(emptyEnv.entries());
    var i = m.name.indexOf('$');
    if (i != -1) {
        var prev_obj_name_reg = obj_name_reg;
        obj_name_reg = m.name.slice(i + 1);
    }
    // Construct the environment for the function body
    var variables = variableNames(m.body);
    variables.forEach(function (v) { return withParamsAndVariables.set(v, true); });
    m.params.forEach(function (p) { return withParamsAndVariables.set(p.name, true); });
    // Construct the code for params and variable declarations in the body
    var params = m.params.map(function (p) {
        //Ignore self
        if (p.name != "self") {
            return "(param $".concat(p.name, " i32)");
        }
    }).join(" ");
    var varDecls = variables.map(function (v) { return "(local $".concat(v, " i32)"); }).join("\n");
    // Very Tricky here, we ignore the global variable
    var stmts = m.body.map(function (s) { return codeGenStmt(s, withParamsAndVariables, emptyEnv); }).flat();
    var stmtsBody = stmts.join("\n");
    if (prev_obj_name_reg !== undefined && prev_obj_name_reg != obj_name_reg) {
        obj_name_reg = prev_obj_name_reg;
    }
    return ["(func $".concat(m.name, " ").concat(params, " (result i32)\n        (local $scratch i32)\n        ").concat(varDecls, "\n        ").concat(stmtsBody, "\n        (i32.const 0))")];
}
exports.codeGenFunDef = codeGenFunDef;
function codeGenClass(c) {
    // Currently do not want add any globals when generating class
    var methods = [];
    if (c.tag != "class") {
        throw new Error("CGC ERROR: Statement tag is not 'class', should not call CGC");
    }
    else {
        c.methods.forEach(function (m, i) {
            var this_fun = codeGenFunDef(__assign(__assign({}, m), { name: "$".concat(m.name, "$").concat(c.name) }));
            methods.concat(this_fun);
        });
        methods = methods.flat();
    }
    return methods;
}
exports.codeGenClass = codeGenClass;
function codeGenStmt(stmt, locals, global_vars) {
    var withParamsAndVariables = new Map(locals.entries());
    var emptyEnv = new Map();
    switch (stmt.tag) {
        case "class":
            // push class_name to classes
            classes.set(stmt.name, stmt);
            // set class name reg to enable self-parsing
            // cls_name_reg = stmt.name;
            // // construct class variables
            // const cls_vars = variableNames(stmt.fields,stmt.name);
            // cls_vars.forEach(v => withParamsAndVariables.set(v, true));
            // //Construct methods for each class
            // const varDeclCls = cls_vars.map(cv => `local $${cv} i32`).join("\n");
            // // NOTE: very tricky here, we just don't pass global env to code gen when gen class methods
            // // NOTE: 0426, even more tricky, have to convert map into a list
            // const funcCls = codeGenClass(stmt)
            // const funcClsBody = funcCls.join("\n");
            // //Reset class name reg
            // cls_name_reg = "none";
            return;
        case "define":
            // Construct the environment for the function body
            var variables = variableNames(stmt.body);
            variables.forEach(function (v) { return withParamsAndVariables.set(v, true); });
            stmt.params.forEach(function (p) { return withParamsAndVariables.set(p.name, true); });
            // Construct the code for params and variable declarations in the body
            var params = stmt.params.map(function (p) { return "(param $".concat(p.name, " i32)"); }).join(" ");
            var varDecls = variables.map(function (v) { return "(local $".concat(v, " i32)"); }).join("\n");
            var stmts = stmt.body.map(function (s) { return codeGenStmt(s, withParamsAndVariables, global_vars); }).flat();
            var stmtsBody = stmts.join("\n");
            return ["(func $".concat(stmt.name, " ").concat(params, " (result i32)\n        (local $scratch i32)\n        ").concat(varDecls, "\n        ").concat(stmtsBody, "\n        (i32.const 0))")];
        case "return":
            var valStmts = codeGenExpr(stmt.value, locals);
            valStmts.push("return");
            return valStmts;
        case "assign":
            var ofi = obj_field_type_idx;
            if (stmt.value.tag == 'call' && classes.has(stmt.value.name)) {
                // We are creating an object
                console.log("Creating object ".concat(stmt.name, " from ").concat(stmt.value.name));
                var prev_obj_name_reg = obj_name_reg;
                obj_name_reg = stmt.name;
                console.log("prev_obj", prev_obj_name_reg, "obj", obj_name_reg);
                var svn = stmt.value.name;
                ofi.set(stmt.name, ofi.get(svn));
                ofi.delete(svn);
            }
            else {
                if (stmt.value.hasOwnProperty('a') && (0, tc_1.isObject)(stmt.value.a)) {
                    // shallow copy object to object
                    if (stmt.value.tag == 'id' && ofi.has(stmt.value.name)) {
                        var svn = stmt.value.name;
                        ofi.set(stmt.name, ofi.get(svn));
                    }
                    else {
                        throw new Error("try to copy object,but ".concat(stmt.value, " is NOT an object"));
                    }
                }
            }
            var valStmts = codeGenExpr(stmt.value, locals);
            if (stmt.name.includes(".")) {
                // Deal with Setfield
                var obj_name = stmt.name.split('.', 2)[0];
                if (obj_name == 'self') {
                    obj_name = obj_name_reg;
                }
                var fld_name = stmt.name.split('.', 2)[1];
                var iof = obj_field_type_idx.get(obj_name).get(fld_name)[1];
                var lst_of_stmts = __spreadArray(__spreadArray([
                    "(global.get $".concat(obj_name, ")"),
                    "(i32.add (i32.const ".concat(iof * 4, "))")
                ], valStmts, true), [
                    "i32.store"
                ], false);
                valStmts = lst_of_stmts;
            }
            else {
                if (locals.has(stmt.name)) {
                    valStmts.push("(local.set $".concat(stmt.name, ")"));
                }
                else {
                    // Dealing with globals
                    valStmts.push("(global.set $".concat(stmt.name, ")"));
                }
            }
            if (prev_obj_name_reg !== undefined && prev_obj_name_reg != obj_name_reg) {
                obj_name_reg = prev_obj_name_reg;
            }
            console.log("AFTER: prev_obj", prev_obj_name_reg, "obj", obj_name_reg);
            return valStmts;
        case "expr":
            var result = codeGenExpr(stmt.expr, locals);
            result.push("(local.set $scratch)");
            return result;
        case "pass":
            var donothing = [];
            return donothing;
        case "if":
            //  { a?: A, tag: "if", cond: Expr<A>, body: Stmt<A>[], else_body: Stmt<A>[]}
            var condExpr = codeGenExpr(stmt.cond, locals); //generate condition
            var out = condExpr.concat(["(if"]).concat(["(then"]);
            var body_stmts = stmt.body.map(function (s) { return (codeGenStmt(s, locals, global_vars)).flat().join("\n"); }); //generate then body
            out = out.concat(body_stmts).concat([")"]);
            if (stmt.else_body.length > 0) {
                out = out.concat("(else");
                var else_stmts = stmt.else_body.map(function (s) { return (codeGenStmt(s, locals, global_vars)).flat().join("\n"); }); //generate the else body
                out = out.concat(else_stmts).concat(")");
            }
            //end the if statement
            out = out.concat([")"]);
            return out;
        case "while":
            // { a?: A, tag: "while",cond: Expr <A>, body: Stmt<A>[]}
            var condwhile = codeGenExpr(stmt.cond, locals);
            var whileout = condwhile.concat(["(if"]).concat(["(then"]);
            // Need to check the cond before enter this loop
            whileout = whileout.concat(["(loop $myLoop".concat(loop_counter)]);
            var body_stmts = stmt.body.map(function (s) { return (codeGenStmt(s, locals, global_vars)).flat().join("\n"); });
            whileout = whileout.concat(body_stmts);
            whileout = whileout.concat(condwhile).concat(["br_if $myLoop".concat(loop_counter)]);
            //Endloop
            whileout = whileout.concat([")"]);
            //Endwhile(
            whileout = whileout.concat([")"]).concat([")"]);
            loop_counter += 1;
            return whileout;
    }
}
exports.codeGenStmt = codeGenStmt;
function compile(source) {
    var ast = (0, parser_1.parseProgram)(source);
    obj_field_type_idx = new Map();
    console.log("parsed program, ast:", ast);
    ast = (0, tc_1.tcProgram)(ast);
    console.log("after tc, ast:", ast);
    decl_of_funcs = [];
    var emptyEnv = new Map();
    tmp_vars = [];
    var _a = varsFunsStmts(ast), vars = _a[0], funs = _a[1], stmts = _a[2];
    var funsCode = funs.map(function (f) { return codeGenStmt(f, emptyEnv, emptyEnv); }).map(function (f) { return f.join("\n"); });
    var allFuns = funsCode.join("\n\n");
    var varDecls = vars.map(function (v) { return "(global $".concat(v, " (mut i32) (i32.const 0))"); }).join("\n");
    console.log("compile-stmts:", stmts);
    var allStmts = stmts.map(function (s) { return codeGenStmt(s, emptyEnv, emptyEnv); }).flat();
    var main = __spreadArray(["(local $scratch i32)"], allStmts, true).join("\n");
    var lastStmt = ast[ast.length - 1];
    var isExpr = lastStmt.tag === "expr";
    var retType = "";
    var retVal = "";
    if (isExpr) {
        retType = "(result i32)";
        retVal = "(local.get $scratch)";
    }
    var tmpvarDecls = tmp_vars.map(function (v) { return "(global $".concat(v, " (mut i32) (i32.const 0))"); }).join("\n");
    return "\n    (module\n      (func $print_num (import \"imports\" \"print_num\") (param i32) (result i32))\n      (func $print_bool (import \"imports\" \"print_bool\") (param i32) (result i32))\n      (func $print_none (import \"imports\" \"print_none\") (param i32) (result i32))\n      (memory (import \"imports\" \"mem\") 1)\n      (global $heap (mut i32) (i32.const 4))\n      ".concat(varDecls, "\n      ").concat(tmpvarDecls, "\n      ").concat(decl_of_funcs, "\n      ").concat(allFuns, "\n      (func (export \"_start\") ").concat(retType, "\n        ").concat(main, "\n        ").concat(retVal, "\n      )\n    ) \n  ");
}
exports.compile = compile;


/***/ }),

/***/ "./parser.ts":
/*!*******************!*\
  !*** ./parser.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = exports.traverse = exports.traverseArguments = exports.traverseExpr = exports.traverseParameters = exports.traverseType = exports.traverseStmt = exports.traverseStmts = exports.parseProgram = void 0;
var lezer_python_1 = __webpack_require__(/*! lezer-python */ "./node_modules/lezer-python/dist/index.cjs");
var ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
var supportedTypes = ["int", "none", "bool"];
var cls_name_reg = "none";
function parseProgram(source) {
    var t = lezer_python_1.parser.parse(source).cursor();
    return traverseStmts(source, t);
}
exports.parseProgram = parseProgram;
function traverseStmts(s, t) {
    // The top node in the program is a Script node with a list of children
    // that are various statements
    t.firstChild();
    var stmts = [];
    do {
        stmts.push(traverseStmt(s, t));
    } while (t.nextSibling()); // t.nextSibling() returns false when it reaches
    //  the end of the list of children
    t.parent();
    return stmts;
}
exports.traverseStmts = traverseStmts;
/*
  Invariant – t must focus on the same node at the end of the traversal
*/
function traverseStmt(s, t) {
    switch (t.type.name) {
        case "ReturnStatement":
            t.firstChild(); // Focus return keyword
            t.nextSibling(); // Focus expression
            var value;
            if (s.substring(t.from, t.to) == "") {
                value = { tag: "none" };
            }
            else {
                value = traverseExpr(s, t);
            }
            t.parent();
            return { tag: "return", value: value };
        case "AssignStatement":
            t.firstChild(); // focused on name (the first child)
            var name = s.substring(t.from, t.to);
            t.nextSibling(); // focused on :type part, explained in Chocopy
            var anno = s.substring(t.from + 1, t.to).trim(); // Use +2 to skip the :
            t.nextSibling(); // focused on = sign. May need this for complex tasks, like +=!
            t.nextSibling(); // focused on the value expression
            var value = traverseExpr(s, t);
            t.parent();
            console.log("Assign-return:", { a: anno, tag: "assign", name: name, value: value });
            return { a: anno, tag: "assign", name: name, value: value };
        case "ExpressionStatement":
            t.firstChild(); // The child is some kind of expression, the
            // ExpressionStatement is just a wrapper with no information
            var expr = traverseExpr(s, t);
            t.parent();
            return { tag: "expr", expr: expr };
        case "FunctionDefinition":
            t.firstChild(); // Focus on def
            t.nextSibling(); // Focus on name of function
            var name = s.substring(t.from, t.to);
            t.nextSibling(); // Focus on ParamList
            var params = traverseParameters(s, t);
            t.nextSibling(); // Focus on Body or TypeDef
            var ret = "none";
            var maybeTD = t;
            if (maybeTD.type.name === "TypeDef") {
                t.firstChild();
                ret = traverseType(s, t);
                t.parent();
            }
            t.nextSibling(); // Focus on single statement (for now)
            t.firstChild(); // Focus on :
            var body = [];
            while (t.nextSibling()) {
                body.push(traverseStmt(s, t));
            }
            t.parent(); // Pop to Body
            t.parent(); // Pop to FunctionDefinition
            return {
                tag: "define",
                name: name,
                params: params,
                body: body,
                ret: ret
            };
        case "ClassDefinition":
            t.firstChild(); // Focus on def
            t.nextSibling(); // Focus on name of function
            var name = s.substring(t.from, t.to);
            supportedTypes.push(name);
            cls_name_reg = name;
            t.nextSibling(); // Focus on object, the original param list
            //no params here, as only "object" is allowed
            t.nextSibling(); // Focus on Body or TypeDef
            t.nextSibling(); // Focus on single statement (for now)
            t.firstChild(); // Focus on :
            var varInits = [];
            var clsBody = new Map();
            while (t.nextSibling()) {
                var cls_stmt = traverseStmt(s, t);
                if (cls_stmt.tag == "define") {
                    // { a?: A, tag: "class", name:string, fields: Stmt<A>[], methods: Map <string, FunDef<A>>}
                    clsBody.set(cls_stmt.name, { name: cls_stmt.name, params: cls_stmt.params,
                        ret: cls_stmt.ret, inits: varInits, body: cls_stmt.body });
                }
                else {
                    if (cls_stmt.tag == "assign") {
                        varInits.push(cls_stmt);
                    }
                    else {
                        throw new Error("PARSER ERROR: unsupported statements type for class definition");
                    }
                }
            }
            t.parent(); // Pop to Body
            t.parent(); // Pop to FunctionDefinition
            console.log("class_name", name);
            cls_name_reg = "none";
            return {
                a: name,
                tag: "class",
                name: name,
                fields: varInits,
                methods: clsBody
            };
        case "PassStatement":
            return { tag: "pass" };
        case "IfStatement":
            t.firstChild();
            t.nextSibling();
            var cond_expr = traverseExpr(s, t);
            t.nextSibling(); //focus on body
            t.firstChild(); //focus on :
            var stmt_b = [];
            var else_stmt_b = [];
            while (t.nextSibling()) {
                stmt_b.push(traverseStmt(s, t));
            }
            t.parent();
            t.nextSibling();
            if (t.node.type.name === "else") {
                t.nextSibling(); //focus on body
                t.firstChild(); //focus on :
                while (t.nextSibling()) {
                    else_stmt_b.push(traverseStmt(s, t));
                }
                t.parent();
                t.parent();
                return { tag: "if", cond: cond_expr, body: stmt_b, else_body: else_stmt_b };
            }
            else {
                t.parent();
                return { tag: "if", cond: cond_expr, body: stmt_b, else_body: else_stmt_b };
            }
        case "WhileStatement":
            t.firstChild();
            t.nextSibling();
            var cond_while = traverseExpr(s, t);
            t.nextSibling(); //focus on body
            t.firstChild(); //focus on :
            var stmt_w = [];
            while (t.nextSibling()) {
                stmt_w.push(traverseStmt(s, t));
            }
            t.parent();
            t.parent();
            return { tag: "while", cond: cond_while, body: stmt_w };
    }
}
exports.traverseStmt = traverseStmt;
function traverseType(s, t) {
    switch (t.type.name) {
        case "VariableName":
            var name_1 = s.substring(t.from, t.to);
            // // if(name !== "int" && name !=="none" && name !== "bool") {
            // if (!supportedTypes.includes(name)){
            //   throw new Error("Unknown VariableName type: " + name)
            // }
            var return_name = name_1;
            return return_name;
        default:
            throw new Error("Unknown non-VariableName type: " + t.type.name);
    }
}
exports.traverseType = traverseType;
function traverseParameters(s, t) {
    t.firstChild(); // Focuses on open paren
    var parameters = [];
    t.nextSibling(); // Focuses on a VariableName
    while (t.type.name !== ")") {
        var name_2 = s.substring(t.from, t.to);
        t.nextSibling(); // Focuses on "TypeDef", hopefully, or "," if mistake
        var nextTagName = t.type.name; // NOTE(joe): a bit of a hack so the next line doesn't if-split
        if (nextTagName !== "TypeDef") {
            throw new Error("Missed type annotation for parameter " + name_2);
        }
        ;
        t.firstChild(); // Enter TypeDef
        t.nextSibling(); // Focuses on type itself
        var typ = traverseType(s, t);
        t.parent();
        t.nextSibling(); // Move on to comma or ")"
        parameters.push({ name: name_2, typ: typ });
        t.nextSibling(); // Focuses on a VariableName
    }
    t.parent(); // Pop to ParamList
    return parameters;
}
exports.traverseParameters = traverseParameters;
function traverseExpr(s, t) {
    switch (t.type.name) {
        case "None":
            return { tag: "none" };
        case "Boolean":
            if (s.substring(t.from, t.to) === "True") {
                return { tag: "true" };
            }
            else {
                return { tag: "false" };
            }
        case "Number":
            return { tag: "number", value: Number(s.substring(t.from, t.to)) };
        case "VariableName":
            return { tag: "id", name: s.substring(t.from, t.to) };
        case "CallExpression":
            t.firstChild(); // Focus name
            var name = s.substring(t.from, t.to);
            if (name.includes('.')) {
                var obj_parsed = traverseExpr(s, t);
            }
            var result;
            t.nextSibling(); // Focus ArgList
            t.firstChild(); // Focus open paren
            var args = traverseArguments(t, s);
            t.prevSibling();
            if (name.includes('.')) {
                if (obj_parsed.tag == "getfield") {
                    result = { tag: "method", obj: obj_parsed.obj, name: obj_parsed.name, args: args };
                }
            }
            else {
                result = { tag: "call", name: name, args: args };
            }
            t.parent();
            return result;
        case "UnaryExpression":
            t.firstChild();
            var uop = s.substring(t.from, t.to);
            switch (uop) {
                case '-':
                    t.nextSibling();
                    var this_var = traverseExpr(s, t);
                    if (this_var.tag == "id") {
                        t.parent();
                        return { tag: 'binop', op: '*', lhs: { a: "int", tag: "number", value: -1 }, rhs: this_var };
                    }
                    var num = Number(uop + s.substring(t.from, t.to));
                    if (isNaN(num)) {
                        throw new Error("PARSE ERROR: unary operation failed");
                    }
                    t.parent();
                    return { tag: "number", value: num };
                case '+':
                    t.nextSibling();
                    var this_var = traverseExpr(s, t);
                    if (this_var.tag == "id") {
                        t.parent();
                        return { tag: 'binop', op: '*', lhs: { a: "int", tag: "number", value: 1 }, rhs: this_var };
                    }
                    var num = Number(uop + s.substring(t.from, t.to));
                    if (isNaN(num)) {
                        throw new Error("PARSE ERROR: unary operation failed");
                    }
                    t.parent();
                    return { tag: "number", value: num };
                case "not":
                    var not_result;
                    t.nextSibling();
                    if (s.substring(t.from, t.to) === "True") {
                        not_result = { tag: "false" };
                    }
                    else {
                        not_result = { tag: "true" };
                    }
                    t.parent();
                    return not_result;
                case "default":
                    throw new Error("PARSE ERROR: unimplemented unary op");
            }
        case "BinaryExpression":
            t.firstChild(); // go to lhs
            var lhsExpr = traverseExpr(s, t);
            t.nextSibling(); // go to op
            var opStr = s.substring(t.from, t.to);
            if (!(0, ast_1.isOp)(opStr)) {
                throw new Error("Unknown or unhandled op: ".concat(opStr));
            }
            t.nextSibling(); // go to rhs
            var rhsExpr = traverseExpr(s, t);
            t.parent();
            return {
                tag: "binop",
                op: opStr,
                lhs: lhsExpr,
                rhs: rhsExpr
            };
        case "ParenthesizedExpression":
            t.firstChild(); // focus on (
            t.nextSibling();
            var paren_exp = traverseExpr(s, t);
            t.nextSibling(); // focus on )
            t.parent();
            return paren_exp;
        case "MemberExpression":
            t.firstChild(); //focus on variable name like "c","self"
            var cls_name = s.substring(t.from, t.to);
            var cls_obj = traverseExpr(s, t);
            t.nextSibling();
            t.nextSibling(); // focus on property name
            var property_name = s.substring(t.from, t.to);
            var result;
            // Try to parse self with a register
            if (cls_name == "self") {
                if (cls_name_reg == "none") {
                    throw new Error("Illegal self here");
                }
                else {
                    cls_name = cls_name_reg;
                }
            }
            t.parent();
            console.log("Member Expression, obj:".concat(cls_obj, ", name:").concat(property_name));
            result = { tag: "getfield", obj: cls_obj, name: property_name };
            return result;
        case "self":
            return { tag: "self", a: { tag: "object", class: cls_name_reg } };
        default:
            throw new Error("Expression not included in traverseExpr: ".concat(t.type.name, ", ").concat(s.substring(t.from, t.to)));
    }
}
exports.traverseExpr = traverseExpr;
function traverseArguments(c, s) {
    c.firstChild(); // Focuses on open paren
    var args = [];
    c.nextSibling();
    while (c.type.name !== ")") {
        var expr = traverseExpr(s, c);
        args.push(expr);
        c.nextSibling(); // Focuses on either "," or ")"
        c.nextSibling(); // Focuses on a VariableName
    }
    c.parent(); // Pop to ArgList
    return args;
}
exports.traverseArguments = traverseArguments;
function traverse(c, s) {
    switch (c.node.type.name) {
        case "Script":
            var stmts = [];
            c.firstChild();
            do {
                stmts.push(traverseStmt(s, c));
            } while (c.nextSibling());
            console.log("traversed " + stmts.length + " statements ", stmts, "stopped at ", c.node);
            return stmts;
        default:
            throw new Error("Could not parse program at " + c.node.from + " " + c.node.to);
    }
}
exports.traverse = traverse;
function parse(source) {
    var t = lezer_python_1.parser.parse(source);
    return traverse(t.cursor(), source);
}
exports.parse = parse;


/***/ }),

/***/ "./tc.ts":
/*!***************!*\
  !*** ./tc.ts ***!
  \***************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CLASS = exports.assignableTo = exports.isObject = exports.tcLiteral = exports.tcProgram = exports.tcStmt = exports.tcExpr = exports.tcParams = exports.tcVarInits = void 0;
var ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
var ast_2 = __webpack_require__(/*! ./ast */ "./ast.ts");
var objEnv;
var obj_name_reg = "none";
function duplicateEnv(env) {
    return { vars: new Map(env.vars), funs: new Map(env.funs), retType: env.retType };
}
function tcVarInits(inits, env) {
    var typedInits = [];
    inits.forEach(function (init) {
        var typedInit = tcLiteral(init.init);
        if (typedInit.a !== init.type)
            throw new Error("TYPE ERROR: init type does not match literal type");
        env.vars.set(init.name, init.type);
        typedInits.push(__assign(__assign({}, init), { a: init.type, init: typedInit }));
    });
    return typedInits;
}
exports.tcVarInits = tcVarInits;
function tcParams(params) {
    return params.map(function (param) {
        return __assign(__assign({}, param), { a: param.type });
    });
}
exports.tcParams = tcParams;
// export function tcFunDef(fun:FunDef<any>, cls : ClassEnv, env: TypeEnv): FunDef<Type>{
//   const localEnv = duplicateEnv(env)
//   //add params to env
//   fun.params.forEach(param=>{
//     localEnv.vars.set(param.name,param.type);
//   })
//   const typedParams = tcParams(fun.params);
//   //Add inits
//   const typedInits = tcVarInits(fun.inits, env);
//   fun.inits.forEach(init=>{
//     localEnv.vars.set(init.name,init.type);
//   })
//   localEnv.funs.set(fun.name,[fun.params.map(param=>param.type), fun.ret]);
//   //Check body
//   const typedStmts = tcStmt(fun.body,cls,localEnv.funs,localEnv.vars,localEnv.retType);
//   return {...fun,params: typedParams, inits:typedInits, body:typedStmts};
// }
function tcExpr(e, classes, functions, variables) {
    var emptyEnv = new Map();
    switch (e.tag) {
        case "number": return __assign(__assign({}, e), { a: "int" });
        case "true": return __assign(__assign({}, e), { a: "bool" });
        case "false": return __assign(__assign({}, e), { a: "bool" });
        case "none": return __assign(__assign({}, e), { a: "none" });
        case "binop": {
            // We currently enforce the lhs and rhs must be int
            var left = tcExpr(e.lhs, classes, functions, variables);
            var right = tcExpr(e.rhs, classes, functions, variables);
            e.lhs = left;
            e.rhs = right;
            if (e.op == 'is') {
                // "is" operator logic
                console.log("is op, left, right", left, right);
                if (left.a == "int" || left.a == "bool") {
                    throw new Error("TYPE ERROR: LHS of 'is' must be an object");
                }
                if (right.a == "int" || right.a == "bool") {
                    throw new Error("TYPE ERROR: RHS of 'is' must be an object");
                }
                return __assign(__assign({}, e), { a: "bool" });
            }
            if ((0, ast_2.isintOp)(e.op)) {
                if (e.lhs.a != "int" || e.rhs.a != "int") {
                    console.log("TC Variables", variables);
                    throw new Error("TYPE ERROR: LHS,RHS of ".concat(e.op, " must be both int, instead, we have ").concat(e.lhs.a, ",").concat(e.rhs.a));
                }
                var return_bool_ops = [">", "<", ">=", "<="];
                console.log(return_bool_ops.includes(e.op));
                if (return_bool_ops.includes(e.op)) {
                    return __assign(__assign({}, e), { a: "bool" });
                }
                return __assign(__assign({}, e), { a: "int" });
            }
            else {
                if ((0, ast_2.isboolOp)(e.op)) {
                    if (e.lhs.a != "bool" || e.rhs.a != "bool") {
                        throw new Error("TYPE ERROR: LHS,RHS of ".concat(e.op, " must be both bool, instead, we have ").concat(e.lhs.a, ",").concat(e.rhs.a));
                    }
                    return __assign(__assign({}, e), { a: "bool" });
                }
                else {
                    if ((0, ast_1.issameOp)(e.op)) {
                        if (e.lhs.a == e.rhs.a) {
                            return __assign(__assign({}, e), { a: "bool" });
                        }
                        else {
                            throw new Error("TYPE ERROR: LHS,RHS of ".concat(e.op, " must be of same type, instead, we have ").concat(e.lhs.a, ",").concat(e.rhs.a));
                        }
                    }
                    else {
                        throw new Error("TYPE ERROR: [tc.ts]Unhandled binary op ".concat(e.op));
                    }
                }
            }
        }
        case "id": return __assign(__assign({}, e), { a: variables.get(e.name) });
        case "call":
            var result;
            if (e.name === "print") {
                if (e.args.length !== 1) {
                    throw new Error("TYPE ERROR: print expects a single argument");
                }
                var newArgs_1 = [tcExpr(e.args[0], classes, functions, variables)];
                var res = __assign(__assign({}, e), { a: "none", args: newArgs_1 });
                return res;
            }
            if (classes.has(e.name)) {
                // Calling class()
                var class_stmt = classes.get(e.name);
                if (class_stmt.tag != "class") {
                    throw new Error("TYPE ERROR: Variable ".concat(e.name, " should be a class, however its tag is not"));
                }
                else {
                    class_stmt.fields.forEach(function (vi) {
                        if (vi.tag != "assign") {
                            throw new Error("TYPE ERROR: fields with non-assign tag");
                        }
                        else {
                            if (obj_name_reg == "none") {
                                //Comeon!
                            }
                            else {
                                variables.set("".concat(obj_name_reg, ".").concat(vi.name), vi.a);
                                console.log("Append this entry: ".concat(obj_name_reg, ".").concat(vi.name, " to variables"));
                            }
                        }
                    });
                    return __assign(__assign({}, e), { a: { tag: "object", class: class_stmt.name } });
                }
            }
            else {
                if (!functions.has(e.name)) {
                    throw new Error("TYPE ERROR: function ".concat(e.name, " not found"));
                }
                var _a = functions.get(e.name), args = _a[0], ret = _a[1];
                if (args.length !== e.args.length) {
                    throw new Error("TYPE ERROR: TC-call-function:Expected ".concat(args.length, " arguments but got ").concat(e.args.length));
                }
                var newArgs_2 = args.map(function (a, i) {
                    var argtyp = tcExpr(e.args[i], classes, functions, variables);
                    if (a !== argtyp.a) {
                        throw new Error("TYPE ERROR: Got ".concat(argtyp, " as argument ").concat(i + 1, ", expected ").concat(a));
                    }
                    return argtyp;
                });
                result = __assign(__assign({}, e), { a: ret, args: newArgs_2 });
            }
            return result;
        case "literal":
            e.literal = tcLiteral(e.literal);
            return __assign(__assign({}, e), { a: e.literal.a });
        case "builtin2":
            var arg1 = tcExpr(e.arg1, classes, functions, variables);
            var arg2 = tcExpr(e.arg2, classes, functions, variables);
            if (arg1.a != "int") {
                throw new Error("TYPE ERROR: Left must be int");
            }
            if (arg2.a != "int") {
                throw new Error("TYPE ERROR: Right must be int");
            }
            return __assign(__assign({}, e), { a: "int" });
        case "method":
            var newObj = tcExpr(e.obj, classes, functions, variables);
            var newArgs;
            if (newObj.a != "int" && newObj.a != "bool" && newObj.a != "none") {
                if (newObj.a.tag !== "object") {
                    throw "Non-object type in method call";
                }
                if (!classes.has(newObj.a.class)) {
                    throw "Compiler error, no such class";
                }
                var classdata = classes.get(newObj.a.class);
                if (classdata.tag == "class") {
                    if (!classdata.methods.has(e.name)) {
                        throw "No such method";
                    }
                    newArgs = e.args.map(function (a) { return tcExpr(a, classes, functions, variables); });
                    var thisfun = classdata.methods.get(e.name);
                    var argTyps = thisfun.params;
                    var retType = thisfun.ret;
                    // Here we must ignore self by adding 1 to the rhs
                    if (argTyps.length !== newArgs.length + 1) {
                        throw "tc: method arg mismatch";
                    }
                    argTyps.forEach(function (t, i) {
                        if (isObject(t.typ) && !t.typ.hasOwnProperty('tag')) {
                            t.typ = { tag: "object", class: String(t.typ) };
                        }
                        if (t.name != "self" && !assignableTo(t.typ, newArgs[i - 1].a)) {
                            throw new Error("TYPE ERROR: Arg Types mismatch for ".concat(t.typ, " and ").concat(newArgs[i - 1].a));
                        }
                    });
                }
                else {
                    throw "Tag says ".concat(e.name, " is a method, but annotation says it isn't an object");
                }
            }
            else {
                throw new Error("RUNTIME ERROR: The Type of ".concat(e.obj, " should be an obj, instead it is a ").concat(newObj.a));
            }
            if (isObject(retType) && !retType.hasOwnProperty('tag')) {
                //Just a normal string
                retType = { tag: "object", class: String(retType) };
            }
            return __assign(__assign({}, e), { a: retType, obj: newObj, args: newArgs });
        case "getfield":
            var cls_name;
            switch (e.obj.tag) {
                case "id":
                    var obj_type = objEnv.get(e.obj.name);
                    if (obj_type == "bool" || obj_type == "int" || obj_type == "none") {
                        throw new Error("RUNTIME ERROR: The Type of ".concat(e.obj.name, " should be an obj"));
                    }
                    else {
                        cls_name = obj_type.class;
                    }
                    break;
                case "self":
                    cls_name = e.obj.a.class;
                    break;
                case "getfield":
                    if (e.obj.a === undefined) {
                        var get_class = objEnv.get(e.obj.name);
                        if (get_class == "bool" || get_class == "int" || get_class == "none") {
                            throw new Error("TYPE ERROR: Weird. Class Statement ".concat(cls_stmt, " has tag ").concat(cls_stmt.tag));
                        }
                        else {
                            cls_name = get_class.class;
                        }
                    }
                    else {
                        cls_name = e.obj.a.class;
                    }
                    break;
                case "method":
                    cls_name = e.obj.a.class;
                    break;
                default:
                    throw new Error("TYPE ERROR: tc: getfield, not a supported datatype,but ".concat(e.obj.tag));
            }
            var cls_stmt = classes.get(cls_name);
            while (cls_stmt.tag == "assign") {
                // Parse cls_stmt
                cls_stmt = classes.get(cls_stmt.a.class);
            }
            if (cls_stmt.tag != "class") {
                throw new Error('TYPE ERROR: tc: statement is not class');
            }
            var anno;
            console.log("try to find type from this cls st_mt ".concat(cls_stmt));
            cls_stmt.fields.forEach(function (fld) {
                if (fld.tag == "assign" && fld.name == e.name) {
                    console.log(fld);
                    console.log("find type ".concat(fld.a, " for ").concat(e.name));
                    anno = fld.a;
                }
            });
            return __assign(__assign({}, e), { a: anno });
        case "self":
            return __assign({}, e);
    }
}
exports.tcExpr = tcExpr;
function tcStmt(s, classes, functions, variables, currentReturn) {
    console.log("tcStmt", s);
    switch (s.tag) {
        case "assign": {
            var self_flag = 0;
            if (s.value.tag == "call" && classes.has(s.value.name)) {
                console.log("Set ONR to ".concat(s.name));
                obj_name_reg = s.name;
                var obj_type = classes.get(s.value.name).a;
                if (isObject(obj_type) && !obj_type.hasOwnProperty('tag')) {
                    obj_type = CLASS(obj_type);
                }
                objEnv.set(s.name, obj_type);
            }
            console.log("pass the call class check");
            var rhs = tcExpr(s.value, classes, functions, variables);
            if (s.a === '') {
                if (s.name.startsWith('self.')) {
                    s.name = s.name.split('.', 2)[1];
                    self_flag = 1;
                }
                if (variables.has(s.name)) {
                    console.log("get_name", variables.get(s.name));
                    s.a = variables.get(s.name);
                }
                else {
                    throw new Error("RUNTIME ERROR: Cannot change the value of ".concat(s.name, " before its declaration"));
                }
            }
            console.log("tcStmt-assign", s.a, rhs.a);
            console.log("Assignable?", assignableTo(s.a, rhs.a));
            if (s.a == "none" && isObject(rhs.a)) {
                // check class type of lhs,rhs
                console.log("Assign class to none, with classes", classes);
                var cls_typ = objEnv.get(s.name);
                if (!assignableTo(cls_typ, rhs.a)) {
                    throw new Error("TYPE ERROR: Class Mismatch: Try to assign ".concat(rhs.a, " to ").concat(s.name, ", which is type ").concat(cls_typ));
                }
            }
            if (!assignableTo(s.a, rhs.a)) {
                // Make an exemption for assign "none" to "obj"
                throw new Error("TYPE ERROR: Cannot assign ".concat(rhs.a, " to ").concat(s.name, ", which requires ").concat(s.a));
            }
            else {
                if (rhs.a == "none" && isObject(s.a)) {
                    s.a = { tag: "object", class: s.a };
                    objEnv.set(s.name, s.a);
                }
            }
            if (variables.has(s.name) && !assignableTo(variables.get(s.name), rhs.a)) {
                throw new Error("TYPE ERROR: ".concat(s.name, " already declared, which requires ").concat(s.a));
            }
            else {
                if (rhs.a == "none") {
                    console.log("Assign None Result", variables.get(s.name));
                    variables.set(s.name, rhs.a);
                    // we don't want to change s.a here
                }
                else {
                    variables.set(s.name, rhs.a);
                }
                console.log(variables);
            }
            // classes.set(s.name,s);
            if (self_flag == 1) {
                s.name = 'self.' + s.name;
            }
            self_flag = 0;
            obj_name_reg = "none";
            return __assign(__assign({}, s), { value: rhs });
        }
        case "define": {
            var bodyvars_1 = new Map(variables.entries());
            s.params.forEach(function (p) { bodyvars_1.set(p.name, p.typ); });
            console.log("define-s.body", s.body);
            var return_flag = 0;
            var newStmts = s.body.map(function (bs) { return tcStmt(bs, classes, functions, bodyvars_1, s.ret); });
            if (s.ret != "none") {
                s.body.forEach(function (bs) {
                    if (bs.tag == "return") {
                        return_flag = 1;
                    }
                });
                if (return_flag == 0) {
                    throw new Error("TYPE ERROR: ".concat(s.ret, " never returns"));
                }
            }
            return __assign(__assign({}, s), { body: newStmts });
        }
        case "class": {
            var bodyvars = new Map(variables.entries());
            s.fields.forEach(function (vi) {
                var tc_vi = tcStmt(vi, classes, functions, bodyvars, "none");
                if (vi.tag != "assign") {
                    throw new Error("TYPE ERROR: vi ".concat(vi, "'s tag is not assign"));
                }
                else {
                    bodyvars.set(vi.name, tc_vi.a);
                }
            });
            console.log("s-fields:", s.fields);
            var new_methods = new Map();
            s.methods.forEach(function (mds, name) {
                // Trickey Here,mds here is the FunDef
                console.log(mds);
                console.log(mds.body);
                var stmt_from_mds = { a: mds.a, tag: "define", name: mds.name, params: mds.params, ret: mds.ret, body: mds.body };
                var result = tcStmt(stmt_from_mds, classes, functions, bodyvars, mds.ret);
                var mds_from_stmt = { a: result.a, name: mds.name, params: mds.params, ret: mds.ret, inits: mds.inits, body: mds.body };
                new_methods.set(name, mds_from_stmt);
            });
            s.methods = new_methods;
            return __assign(__assign({}, s), { a: "none" });
        }
        case "expr": {
            var ret = tcExpr(s.expr, classes, functions, variables);
            return __assign(__assign({}, s), { expr: ret, a: ret.a });
        }
        case "return": {
            var valTyp = tcExpr(s.value, classes, functions, variables);
            if (isObject(currentReturn)) {
                currentReturn = { tag: "object", class: String(currentReturn) };
            }
            if (!assignableTo(currentReturn, valTyp.a)) {
                throw new Error("TYPE ERROR: ".concat(valTyp, " returned but ").concat(currentReturn, " expected."));
            }
            return __assign(__assign({}, s), { value: valTyp });
        }
        case "pass": {
            return __assign({}, s);
        }
        case "if": {
            var cond = tcExpr(s.cond, classes, functions, variables);
            if (cond.a != "bool") {
                throw new Error("TYPE ERROR: ".concat(cond, " must be a bool, instead it is now ").concat(cond.a));
            }
            var new_bd_st = s.body.map(function (bs) { return tcStmt(bs, classes, functions, variables, currentReturn); });
            if (s.else_body.length === 0) {
                return __assign(__assign({}, s), { cond: cond, body: new_bd_st });
            }
            else {
                var new_elsebd_st = s.else_body.map(function (bs) { return tcStmt(bs, classes, functions, variables, currentReturn); });
                return __assign(__assign({}, s), { cond: cond, body: new_bd_st, else_body: new_elsebd_st });
            }
        }
        case "while": {
            var cond = tcExpr(s.cond, classes, functions, variables);
            if (cond.a != "bool") {
                throw new Error("TYPE ERROR: ".concat(cond, " must be a bool, instead it is now ").concat(cond.a));
            }
            var new_bd_st = s.body.map(function (bs) { return tcStmt(bs, classes, functions, variables, currentReturn); });
            return __assign(__assign({}, s), { cond: cond, body: new_bd_st });
        }
    }
}
exports.tcStmt = tcStmt;
function tcProgram(p) {
    console.log("tcprogram,p", p);
    var functions = new Map();
    var classes = new Map();
    objEnv = new Map();
    p.forEach(function (s) {
        if (s.tag === "define") {
            functions.set(s.name, [s.params.map(function (p) { return p.typ; }), s.ret]);
        }
        if (s.tag === "class") {
            classes.set(s.name, s);
        }
    });
    var globals = new Map();
    return p.map(function (s) {
        if (s.tag === "assign") {
            console.log("psmap, check assign", s.value);
            var rhs = tcExpr(s.value, classes, functions, globals);
            console.log("psmap, rhs:", rhs);
            var tc_s = tcStmt(s, classes, functions, globals, rhs.a);
            // globals.set(s.name, rhs.a);
            return __assign(__assign({}, s), { value: rhs });
        }
        else {
            var res = tcStmt(s, classes, functions, globals, "none");
            return res;
        }
    });
}
exports.tcProgram = tcProgram;
function tcLiteral(literal) {
    switch (literal.tag) {
        case "number":
            return __assign(__assign({}, literal), { a: "int" });
        case "bool":
            return __assign(__assign({}, literal), { a: "bool" });
        case "none":
            return __assign(__assign({}, literal), { a: "none" });
    }
}
exports.tcLiteral = tcLiteral;
function isObject(tp) {
    return !(tp == "int" || tp == "bool" || tp == "none");
}
exports.isObject = isObject;
function assignableTo(type_a, type_b) {
    // Rule No.0: if strictly equal, allow!
    if (type_b === type_a) {
        return true;
    }
    // Rule No.1: None is able to be assigned to everyone.
    if (type_b == "none") {
        // Very Tricky here,must be fixed later
        return isObject(type_a);
    }
    // Rule No1.5 Object is assignable to None
    if (type_a == "none" && isObject(type_b)) {
        return true;
    }
    // Rule No.2: Only Object is allowed to assign object.
    if (type_b != "int" && type_b != "bool") {
        if (type_a != "int" && type_a != "none" && type_a != "bool") {
            return type_a.class == type_b.class;
        }
    }
    return false;
}
exports.assignableTo = assignableTo;
function CLASS(name) {
    return { tag: "object", class: name };
}
exports.CLASS = CLASS;
;


/***/ }),

/***/ "./webstart.ts":
/*!*********************!*\
  !*** ./webstart.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var compiler_1 = __webpack_require__(/*! ./compiler */ "./compiler.ts");
document.addEventListener("DOMContentLoaded", function () { return __awaiter(void 0, void 0, void 0, function () {
    function display(arg) {
        var elt = document.createElement("pre");
        document.getElementById("output").appendChild(elt);
        elt.innerText = arg;
    }
    var memory, importObject, runButton, userCode;
    return __generator(this, function (_a) {
        memory = new WebAssembly.Memory({ initial: 10, maximum: 100 });
        importObject = {
            imports: {
                mem: memory,
                print_num: function (arg) {
                    console.log("Logging from WASM: ", arg);
                    display(String(arg));
                    return arg;
                },
                print_bool: function (arg) {
                    if (arg === 0) {
                        display("False");
                    }
                    else {
                        display("True");
                    }
                    return arg;
                },
                print_none: function (arg) {
                    display("None");
                    return arg;
                }
            },
        };
        runButton = document.getElementById("run");
        userCode = document.getElementById("user-code");
        runButton.addEventListener("click", function () { return __awaiter(void 0, void 0, void 0, function () {
            var program, output, wat, code, result, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        program = userCode.value;
                        output = document.getElementById("output");
                        output.innerHTML = '';
                        display("Program Output:");
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        wat = (0, compiler_1.compile)(program);
                        code = document.getElementById("generated-code");
                        code.textContent = 'Code Generated:' + wat;
                        return [4 /*yield*/, (0, compiler_1.runwatsrc)(wat, importObject)];
                    case 2:
                        result = _a.sent();
                        //output.textContent += (String(result));
                        // display(String(result));
                        output.setAttribute("style", "color: black");
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        console.error(e_1);
                        output.textContent = String(e_1);
                        output.setAttribute("style", "color: red");
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
        userCode.value = localStorage.getItem("program");
        userCode.addEventListener("keypress", function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                localStorage.setItem("program", userCode.value);
                return [2 /*return*/];
            });
        }); });
        return [2 /*return*/];
    });
}); });


/***/ }),

/***/ "wabt":
/*!***********************!*\
  !*** external "wabt" ***!
  \***********************/
/***/ ((module) => {

module.exports = wabt;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./webstart.ts");
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9sZXplci1weXRob24vZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvbGV6ZXItdHJlZS9kaXN0L3RyZWUuY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL2xlemVyL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vYXN0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vY29tcGlsZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9wYXJzZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi90Yy50cyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL3dlYnN0YXJ0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0L2V4dGVybmFsIFwid2FidFwiIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxZQUFZLG1CQUFPLENBQUMsa0RBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0FBbUM7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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REFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUyxFQUFFLEVBQUU7QUFDYjtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUyxFQUFFLEVBQUU7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDLEVBQUUsRUFBRTs7Ozs7Ozs7Ozs7QUNsSEwsc0I7Ozs7OztVQ0FBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7VUNyQkE7VUFDQTtVQUNBO1VBQ0EiLCJmaWxlIjoid2Vic3RhcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBsZXplciA9IHJlcXVpcmUoJ2xlemVyJyk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgXG4gIHByaW50S2V5d29yZCA9IDEsXG4gIG5ld2xpbmUgPSAxNjQsXG4gIG5ld2xpbmVCcmFja2V0ZWQgPSAxNjUsXG4gIG5ld2xpbmVFbXB0eSA9IDE2NixcbiAgZW9mID0gMTY3LFxuICBjb250aW51ZUJvZHkgPSAxNjgsXG4gIGVuZEJvZHkgPSAxNjksXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gMjEsXG4gIFR1cGxlRXhwcmVzc2lvbiA9IDQ4LFxuICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDQ5LFxuICBBcnJheUV4cHJlc3Npb24gPSA1MyxcbiAgQXJyYXlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDU2LFxuICBEaWN0aW9uYXJ5RXhwcmVzc2lvbiA9IDU3LFxuICBEaWN0aW9uYXJ5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA2MCxcbiAgU2V0RXhwcmVzc2lvbiA9IDYxLFxuICBTZXRDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDYyLFxuICBjb21wb3VuZFN0YXRlbWVudCA9IDIzMTtcblxuY29uc3QgbmV3bGluZSQxID0gMTAsIGNhcnJpYWdlUmV0dXJuID0gMTMsIHNwYWNlID0gMzIsIHRhYiA9IDksIGhhc2ggPSAzNSwgcGFyZW5PcGVuID0gNDAsIGRvdCA9IDQ2O1xuXG5jb25zdCBicmFja2V0ZWQgPSBbXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uLCBUdXBsZUV4cHJlc3Npb24sIENvbXByZWhlbnNpb25FeHByZXNzaW9uLCBBcnJheUV4cHJlc3Npb24sIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24sXG4gIERpY3Rpb25hcnlFeHByZXNzaW9uLCBEaWN0aW9uYXJ5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24sIFNldEV4cHJlc3Npb24sIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uXG5dLCBwYXJlbnRTdGF0ZW1lbnQgPSBbY29tcG91bmRTdGF0ZW1lbnRdO1xuXG5jb25zdCBjYWNoZXMgPSBuZXcgV2Vha01hcDtcblxuLy8gUGVyLWlucHV0LXN0cmVhbSBpbmRlbnRhdGlvbiBjYWNoZS4gYHByZXZgIG1hcHMgaW5kZW50YXRpb24gZGVwdGhzXG4vLyB0byB0aGUgbGFzdCBwb3NpdGlvbiBhdCB3aGljaCBhIHN0YXRlbWVudCBpbmRlbnRlZCB0byB0aGF0IGRlcHRoXG4vLyB3YXMgc2Vlbi4gVGhlcmUncyBhbiBleHRyYSBzZXQgb2Ygc2xvdHMgZm9yIHRoZSBfY3VycmVudF9cbi8vIGluZGVudGF0aW9uLCBzaW5jZSB0aGF0IG5lZWRzIHRvIGJlIGF2YWlsYWJsZSBhbG9uZ3NpZGUgYSBwcmV2aW91c1xuLy8gaW5kZW50YXRpb24gcG9zaXRpb24gYXQgdGhlIHNhbWUgbGV2ZWwuXG5jbGFzcyBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGFzdCA9IHRoaXMubGFzdEluZGVudCA9IC0xO1xuICAgIHRoaXMucHJldiA9IFtdO1xuICB9XG5cbiAgZ2V0KHBvcykge1xuICAgIGlmICh0aGlzLmxhc3QgPT0gcG9zKSByZXR1cm4gdGhpcy5sYXN0SW5kZW50XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnByZXYubGVuZ3RoOyBpKyspIGlmICh0aGlzLnByZXZbaV0gPT0gcG9zKSByZXR1cm4gaVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgc2V0KHBvcywgaW5kZW50KSB7XG4gICAgaWYgKHBvcyA9PSB0aGlzLmxhc3QpIHJldHVyblxuICAgIGlmICh0aGlzLmxhc3QgPiAtMSkgdGhpcy5zZXRQcmV2KHRoaXMubGFzdCwgdGhpcy5sYXN0SW5kZW50KTtcbiAgICB0aGlzLmxhc3QgPSBwb3M7XG4gICAgdGhpcy5sYXN0SW5kZW50ID0gaW5kZW50O1xuICB9XG5cbiAgc2V0UHJldihwb3MsIGluZGVudCkge1xuICAgIHdoaWxlICh0aGlzLnByZXYubGVuZ3RoIDwgaW5kZW50KSB0aGlzLnByZXYucHVzaCgtMSk7XG4gICAgdGhpcy5wcmV2W2luZGVudF0gPSBwb3M7XG4gIH1cblxuICBzdGF0aWMgZm9yKGlucHV0KSB7XG4gICAgbGV0IGZvdW5kID0gY2FjaGVzLmdldChpbnB1dCk7XG4gICAgaWYgKCFmb3VuZCkgY2FjaGVzLnNldChpbnB1dCwgZm91bmQgPSBuZXcgQ2FjaGUpO1xuICAgIHJldHVybiBmb3VuZFxuICB9XG59XG5cbmNvbnN0IG1heEluZGVudCA9IDUwO1xuXG5mdW5jdGlvbiBnZXRJbmRlbnQoaW5wdXQsIHBvcykge1xuICBsZXQgY2FjaGUgPSBDYWNoZS5mb3IoaW5wdXQpLCBmb3VuZCA9IGNhY2hlLmdldChwb3MpO1xuICBpZiAoZm91bmQgPiAtMSkgcmV0dXJuIGZvdW5kXG5cbiAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIHZlcnkgb2Z0ZW4gKG9yIGV2ZW4gYXQgYWxsKSBpbiBub3JtYWxcbiAgLy8gcGFyc2luZywgc2luY2UgdGhlIGluZGVudGF0aW9ucyBhcmUgc3RvcmVkIGJ5IHRoZSBuZXdsaW5lXG4gIC8vIHRva2VuaXplciBhaGVhZCBvZiB0aW1lLiBCdXQgaXQncyBraW5kIG9mIHRyaWNreSB0byBwcm92ZSB3aGV0aGVyXG4gIC8vIHRoYXQgYWx3YXlzIGhhcHBlbnMgaW4gaW5jcmVtZW50YWwgcGFyc2luZyBzY2VuYXJpb3MsIHNvIGhlcmUncyBhXG4gIC8vIGZhbGxiYWNrIGFueXdheS5cbiAgbGV0IGJlZm9yZSA9IGlucHV0LnJlYWQoTWF0aC5tYXgoMCwgcG9zIC0gbWF4SW5kZW50KSwgcG9zKTtcbiAgbGV0IGNvdW50ID0gMCwgc3RhcnQgPSBiZWZvcmUubGVuZ3RoO1xuICBmb3IgKDsgc3RhcnQgPiAwOyBzdGFydC0tKSB7XG4gICAgbGV0IG5leHQgPSBiZWZvcmUuY2hhckNvZGVBdChzdGFydCAtIDEpO1xuICAgIGlmIChuZXh0ID09IG5ld2xpbmUkMSB8fCBuZXh0ID09IGNhcnJpYWdlUmV0dXJuKSBicmVha1xuICB9XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaCA9IGJlZm9yZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjaCA9PSBzcGFjZSkgY291bnQrKztcbiAgICBlbHNlIGlmIChjaCA9PSB0YWIpIGNvdW50ICs9IDggLSAoY291bnQgJSA4KTtcbiAgICBlbHNlIGJyZWFrXG4gIH1cbiAgY2FjaGUuc2V0UHJldihwb3MsIGNvdW50KTtcbiAgcmV0dXJuIGNvdW50XG59XG5cbmNvbnN0IG5ld2xpbmVzID0gbmV3IGxlemVyLkV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgdG9rZW4sIHN0YWNrKSA9PiB7XG4gIGxldCBuZXh0ID0gaW5wdXQuZ2V0KHRva2VuLnN0YXJ0KTtcbiAgaWYgKG5leHQgPCAwKSB7XG4gICAgdG9rZW4uYWNjZXB0KGVvZiwgdG9rZW4uc3RhcnQpO1xuICAgIHJldHVyblxuICB9XG4gIGlmIChuZXh0ICE9IG5ld2xpbmUkMSAmJiBuZXh0ICE9IGNhcnJpYWdlUmV0dXJuKSByZXR1cm5cbiAgaWYgKHN0YWNrLnN0YXJ0T2YoYnJhY2tldGVkKSAhPSBudWxsKSB7XG4gICAgdG9rZW4uYWNjZXB0KG5ld2xpbmVCcmFja2V0ZWQsIHRva2VuLnN0YXJ0ICsgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IHNjYW4gPSB0b2tlbi5zdGFydCArIDEsIGluZGVudCA9IDA7XG4gIGZvciAoOyBzY2FuIDwgaW5wdXQubGVuZ3RoOyBzY2FuKyspIHtcbiAgICBsZXQgY2ggPSBpbnB1dC5nZXQoc2Nhbik7XG4gICAgaWYgKGNoID09IHNwYWNlKSBpbmRlbnQrKztcbiAgICBlbHNlIGlmIChjaCA9PSB0YWIpIGluZGVudCArPSA4IC0gKGluZGVudCAlIDgpO1xuICAgIGVsc2UgaWYgKGNoID09IG5ld2xpbmUkMSB8fCBpbmRlbnQgPT0gY2FycmlhZ2VSZXR1cm4gfHwgY2ggPT0gaGFzaCkge1xuICAgICAgdG9rZW4uYWNjZXB0KG5ld2xpbmVFbXB0eSwgdG9rZW4uc3RhcnQgKyAxKTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICB0b2tlbi5hY2NlcHQobmV3bGluZSwgdG9rZW4uc3RhcnQgKyAxKTtcbiAgQ2FjaGUuZm9yKGlucHV0KS5zZXQoc2NhbiwgaW5kZW50KTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlLCBmYWxsYmFjazogdHJ1ZX0pO1xuXG5jb25zdCBib2R5Q29udGludWUgPSBuZXcgbGV6ZXIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCB0b2tlbiwgc3RhY2spID0+IHtcbiAgbGV0IHBhcmVudCA9IHN0YWNrLnN0YXJ0T2YocGFyZW50U3RhdGVtZW50KTtcbiAgbGV0IHBhcmVudEluZGVudCA9IHBhcmVudCA9PSBudWxsID8gMCA6IGdldEluZGVudChpbnB1dCwgcGFyZW50KTtcbiAgbGV0IGluZGVudEhlcmUgPSBnZXRJbmRlbnQoaW5wdXQsIHRva2VuLnN0YXJ0KTtcbiAgdG9rZW4uYWNjZXB0KGluZGVudEhlcmUgPD0gcGFyZW50SW5kZW50ID8gZW5kQm9keSA6IGNvbnRpbnVlQm9keSwgdG9rZW4uc3RhcnQpO1xufSwge2NvbnRleHR1YWw6IHRydWUsIGZhbGxiYWNrOiB0cnVlfSk7XG5cbmNvbnN0IGxlZ2FjeVByaW50ID0gbmV3IGxlemVyLkV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgdG9rZW4pID0+IHtcbiAgbGV0IHBvcyA9IHRva2VuLnN0YXJ0O1xuICBmb3IgKGxldCBwcmludCA9IFwicHJpbnRcIiwgaSA9IDA7IGkgPCBwcmludC5sZW5ndGg7IGkrKywgcG9zKyspXG4gICAgaWYgKGlucHV0LmdldChwb3MpICE9IHByaW50LmNoYXJDb2RlQXQoaSkpIHJldHVyblxuICBsZXQgZW5kID0gcG9zO1xuICBpZiAoL1xcdy8udGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0LmdldChwb3MpKSkpIHJldHVyblxuICBmb3IgKDs7IHBvcysrKSB7XG4gICAgbGV0IG5leHQgPSBpbnB1dC5nZXQocG9zKTtcbiAgICBpZiAobmV4dCA9PSBzcGFjZSB8fCBuZXh0ID09IHRhYikgY29udGludWVcbiAgICBpZiAobmV4dCAhPSBwYXJlbk9wZW4gJiYgbmV4dCAhPSBkb3QgJiYgbmV4dCAhPSBuZXdsaW5lJDEgJiYgbmV4dCAhPSBjYXJyaWFnZVJldHVybiAmJiBuZXh0ICE9IGhhc2gpXG4gICAgICB0b2tlbi5hY2NlcHQocHJpbnRLZXl3b3JkLCBlbmQpO1xuICAgIHJldHVyblxuICB9XG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX2lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsYXdhaXQ6NDAsIG9yOjQ4LCBhbmQ6NTAsIGluOjU0LCBub3Q6NTYsIGlzOjU4LCBpZjo2NCwgZWxzZTo2NiwgbGFtYmRhOjcwLCBzZWxmOjc0LCB5aWVsZDo5MCwgZnJvbTo5MiwgYXN5bmM6MTAwLCBmb3I6MTAyLCBOb25lOjE1NCwgVHJ1ZToxNTYsIEZhbHNlOjE1NiwgZGVsOjE3MCwgcGFzczoxNzQsIGJyZWFrOjE3OCwgY29udGludWU6MTgyLCByZXR1cm46MTg2LCByYWlzZToxOTQsIGltcG9ydDoxOTgsIGFzOjIwMCwgZ2xvYmFsOjIwNCwgbm9ubG9jYWw6MjA2LCBhc3NlcnQ6MjEwLCBlbGlmOjIyMCwgd2hpbGU6MjI0LCB0cnk6MjMwLCBleGNlcHQ6MjMyLCBmaW5hbGx5OjIzNCwgd2l0aDoyMzgsIGRlZjoyNDIsIGNsYXNzOjI1Mn07XG5jb25zdCBwYXJzZXIgPSBsZXplci5QYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxMyxcbiAgc3RhdGVzOiBcIiE7W09gUSFMVE9PTyVmUSFMVU8nI0djT09RIUxRJyNDbScjQ21PT1EhTFEnI0NuJyNDbk8nVVEhTFNPJyNDbE8oelEhTFVPJyNHYk9PUSFMUScjR2MnI0djT09RIUxRJyNEUycjRFNPT1EhTFEnI0diJyNHYk8paFEhTFNPJyNDcU8peFEhTFNPJyNEY08qWVEhTFNPJyNEZ09PUSFMUScjRHQnI0R0TyptT1dPJyNEdE8qdU9gTycjRHRPKn1PcE8nI0R1TytZTyFiTycjRHVPK2VPI3RPJyNEdU8rcE8mak8nI0R1Ty1yUSFMVU8nI0dTT09RIUxRJyNHUycjR1NPJ1VRIUxTTycjR1JPL1VRIUxVTycjR1JPT1EhTFEnI0VeJyNFXk8vbVEhTFNPJyNFX09PUSFMUScjR1EnI0dRTy93USFMU08nI0dQT09RJkZWJyNHUCcjR1BPMFNRIUxTTycjRlFPT1EhTFEnI0Z0JyNGdE8wWFEhTFNPJyNGUE9PUSZGVicjSF0nI0hdT09RJkZWJyNHTycjR09PT1EhTFInI0ZTJyNGU1FgUSFMVE9PTydVUSFMU08nI0NvTzBnUSFMU08nI0N6TzBuUSFMU08nI0RPTzFQUSFMU08nI0dnTzFhUSFMVU8nI0VSTydVUSFMU08nI0VTT09RIUxRJyNFVScjRVVPT1EhTFEnI0VXJyNFV09PUSFMUScjRVknI0VZTzF1USFMU08nI0VbTzJTUSFMU08nI0VgTzBTUSFMU08nI0ViTzJnUSFMVU8nI0ViTzBTUSFMU08nI0VlTy9tUSFMU08nI0VoTy9tUSFMU08nI0VsTy9tUSFMU08nI0VvTzJyUSFMU08nI0VxTzJ5USFMU08nI0V2TzNVUSFMU08nI0VyTy9tUSFMU08nI0V2TzBTUSFMU08nI0V4TzBTUSFMU08nI0V9T09RIUxRJyNDYycjQ2NPT1EhTFEnI0NkJyNDZE9PUSFMUScjQ2UnI0NlT09RIUxRJyNDZicjQ2ZPT1EhTFEnI0NnJyNDZ09PUSFMUScjQ2gnI0NoT09RIUxRJyNDaicjQ2pPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPM1pRIUxTTycjRG5PT1EhTFEsNTpYLDU6WE8zblEhTFNPLDU6W08ze1EjKVdPLDU6W080UVEhTFVPLDU5V08wZ1EhTFNPLDU5X08wZ1EhTFNPLDU5X08wZ1EhTFNPLDU5X082cFEhTFNPLDU5X082dVEhTFNPLDU5X082fFEhTFNPLDU5Z083VFEhTFNPJyNHYk84WlEhTFNPJyNHYU9PUSFMUScjR2EnI0dhT09RIUxRJyNEWScjRFlPOHJRIUxTTyw1OV1PJ1VRIUxTTyw1OV1POVFRIUxTTyw1OV1POVZRIUxTTyw1OlFPJ1VRIUxTTyw1OlFPT1EhTFEsNTl9LDU5fU85ZVEhTFNPLDU5fU85alEhTFNPLDU6V08nVVEhTFNPLDU6V08nVVEhTFNPLDU6VU9PUSFMUSw1OlIsNTpSTzl7USFMU08sNTpSTzpRUSFMU08sNTpWT09PTycjRl0nI0ZdTzpWT1dPLDU6YE9PUSFMUSw1OmAsNTpgT09PTycjRl4nI0ZeTzpfT2BPLDU6YE86Z1EhTFNPJyNEdk9PT08nI0ZfJyNGX086d09wTyw1OmFPT1EhTFEsNTphLDU6YU9PT08nI0ZiJyNGYk87U08hYk8sNTphT09PTycjRmMnI0ZjTztfTyN0Tyw1OmFPT09PJyNGZCcjRmRPO2pPJmpPLDU6YU9PUSFMUScjRmUnI0ZlTzt1USFMVU8sNTplTz5nUSFMVU8sNTxtTz9RUSM0Xk8nI0ZmTz90USFMVU8sNTxtT09RIUxRLDU6eSw1OnlPQF1RIUxUTycjRm1PQWxRIUxTTyw1O1VPT1EmRlYsNTxrLDU8a09Bd1EhTFVPJyNIWU9CYFEhTFNPLDU7bE9PUSFMUS1FOXItRTlyT09RJkZWLDU7ayw1O2tPM1BRIUxTTycjRXhPT1EhTFItRTlRLUU5UU9CaFEhTFVPLDU5Wk9Eb1EhTFVPLDU5Zk9FWVEhTFNPJyNHZE9FZVEhTFNPJyNHZE8wU1EhTFNPJyNHZE9FcFEhTFNPJyNEUU9FeFEhTFNPLDU5ak9FfVEhTFNPJyNHaE8nVVEhTFNPJyNHaE8vbVEhTFNPLDU9Uk9PUSFMUSw1PVIsNT1STy9tUSFMU08nI0R9T09RIUxRJyNFTycjRU9PRmxRIUxTTycjRmdPRnxRIUxTTyw1OHpPR1tRIUxTTyw1OHpPKWtRIUxTTyw1OmtPR2FRIUxVTycjR2pPT1EhTFEsNTpuLDU6bk9PUSFMUSw1OnYsNTp2T0d0USFMU08sNTp6T0hWUSFMU08sNTp8T09RIUxRJyNGaicjRmpPSGVRIUxVTyw1OnxPSHNRIUxTTyw1OnxPSHhRIUxTTycjSFtPT1EhTFEsNTtQLDU7UE9JV1EhTFNPJyNIWE9PUSFMUSw1O1MsNTtTTzNVUSFMU08sNTtXTzNVUSFMU08sNTtaT0lpUSFMVU8nI0heTydVUSFMU08nI0heT0lzUSFMU08sNTtdTzJyUSFMU08sNTtdTy9tUSFMU08sNTtiTzBTUSFMU08sNTtkT0l4USFMVE8nI0VtT0tSUSZGWE8sNTteT05qUSFMU08nI0hfTzNVUSFMU08sNTtiT051USFMU08sNTtkT056USFMU08sNTtpTyEjb1EhTFVPMUcuaE8hI3ZRIUxVTzFHLmhPISZnUSFMVU8xRy5oTyEmcVEhTFVPMUcuaE8hKVtRIUxVTzFHLmhPISlvUSFMVU8xRy5oTyEqU1EhTFVPMUcuaE8hLHJRIUxTTycjR3BPIS1RUSFMVU8nI0dTTy9tUSFMU08nI0dwTyEtW1EhTFNPJyNHb09PUSFMUSw1OlksNTpZTyEtZFEhTFNPLDU6WU8hLWlRIUxTTycjR3FPIS10USFMU08nI0dxTyEuWFEhTFNPMUcvdk9PUSFMUScjRHInI0RyT09RIUxRMUcvdjFHL3ZPT1EhTFExRy55MUcueU8hL1hRIUxVTzFHLnlPIS9gUSFMVU8xRy55TzBnUSFMU08xRy55TyEve1EhTFNPMUcvUk9PUSFMUScjRFgnI0RYTy9tUSFMU08sNTlyT09RIUxRMUcudzFHLndPITBTUSFMU08xRy9kTyEwZFEhTFNPMUcvZE8hMGxRIUxTTzFHL2VPJ1VRIUxTTycjR2lPITBxUSFMU08nI0dpTyEwdlEhTFVPMUcud08hMVdRIUxTTyw1OWZPITJeUSFMU08nI0ZYTyEycVEhTFNPLDU9WE8hMnlRIUxTTzFHL2xPITNPUSFMVU8xRy9sT09RIUxRMUcvaTFHL2lPITNgUSFMU08nI0ZVTyE0WVEhTFNPLDU9U08vbVEhTFNPMUcvcE8hNHdRIUxTTzFHL3JPITR8USFMVU8xRy9yTyE1XlEhTFVPMUcvcE9PUSFMUTFHL20xRy9tT09RIUxRMUcvcTFHL3FPT09PLUU5Wi1FOVpPT1EhTFExRy96MUcvek9PT08tRTlbLUU5W08hNW5RIUxTTycjR3xPL21RIUxTTycjR3xPITV8USFMU08sNTpiT09PTy1FOV0tRTldT09RIUxRMUcvezFHL3tPT09PLUU5YC1FOWBPT09PLUU5YS1FOWFPT09PLUU5Yi1FOWJPT1EhTFEtRTljLUU5Y08hNlhRIUxVTzFHMlhPJ1VRIUxTTyw1PFFPT1EhTFEsNTxRLDU8UU9PUSFMUS1FOWQtRTlkT09RIUxRLDU8WCw1PFhPT1EhTFEtRTlrLUU5a09PUSZGVjFHMHAxRzBwTzBTUSFMU08nI0ZpTyE2cFEhTFVPLDU9dE9PUSFMUTFHMVcxRzFXTyE3WFEhTFNPMUcxV09PUSFMUScjRFQnI0RUTy9tUSFMU08sNT1PT09RIUxRLDU9Tyw1PU9PITdeUSFMU08nI0ZUTyE3bFEhTFNPLDU5bE8hN3RRIUxTTzFHL1VPIThPUSFMVU8sNT1TT09RIUxRMUcybTFHMm1PT1EhTFEsNTppLDU6aU8hOG9RIUxTTycjR1JPT1EhTFEsNTxSLDU8Uk9PUSFMUS1FOWUtRTllTyE5UVEhTFNPMUcuZk9PUSFMUTFHMFYxRzBWTyE5YFEhTFNPJyNGV08hOXNRIUxTTyw1PVVPL21RIUxTTzFHMGZPL21RIUxTTzFHMGZPMFNRIUxTTzFHMGhPT1EhTFEtRTloLUU5aE8hOlVRIUxTTzFHMGhPITphUSFMU08xRzBoTyE6ZlEhTFNPJyNGbE8hOndRIUxTTyw1PXZPITtWUSFMU08nI0ZoTyE7cFEhTFNPLDU9c08hPFJRJkZYTzFHMHJPIT9nUSZGWE8xRzB1TyFCeFEhTFNPJyNGcE8hQ1ZRIUxTTyw1PXhPIUNfUSFMVU8sNT14Ty9tUSFMU08xRzB3TyFDaVEhTFNPMUcwd08zVVEhTFNPMUcwfE9OdVEhTFNPMUcxT09PUSZGViw1O1gsNTtYTyFDblEhTFRPLDU7WE8hRWFRJkZYTzFHMHhPIUh4USFMU08nI0ZxTzNVUSFMU08xRzB4TzNVUSFMU08xRzB4TyFJVlEhTFNPJyNGck8hSWdRIUxTTyw1PXlPMFNRIUxTTyw1PXlPT1EmRlYxRzB8MUcwfE8hSlFRIUxTTycjRXpPIUpYUSMpV08xRzFPT09RJkZWMUcxVDFHMVRPM1VRIUxTTzFHMVRPT1EhTFEsNT1bLDU9W09PUSFMUScjRG8nI0RvTy9tUSFMU08sNT1bTyFKYVEhTFNPJyNGWk8hSndRIUxTTyw1PVpPT1EhTFExRy90MUcvdE8hS1BRIUxTTycjRltPIUtkUSFMU08sNT1dTyFLbFEhTFNPLDU9XU8hTFBRIUxTTyw1PV1PIUxhUSFMU08sNT1dT09RIUxRNyslYjcrJWJPT1EhTFE3KyRlNyskZU8hN3RRIUxTTzcrJG1PIU5TUSFMU08xRy55TyFOWlEhTFNPMUcueU9PUSFMUTFHL14xRy9eT09RIUxRLDU7cSw1O3FPJ1VRIUxTTyw1O3FPT1EhTFE3KyVPNyslT08hTmJRIUxTTzcrJU9PT1EhTFEtRTlULUU5VE9PUSFMUTcrJVA3KyVQTyFOclEhTFNPLDU9VE8nVVEhTFNPLDU9VE9PUSFMUTcrJGM3KyRjTyFOd1EhTFNPNyslT08jIFBRIUxTTzcrJVBPT1EhTFEsNTtzLDU7c08nVVEhTFNPLDU7c09PUSFMUS1FOVYtRTlWT09RIUxRNyslVzcrJVdPIyBVUSFMU08xRzJzTyMgXlEhTFNPNyslV09PUSFMUSw1O3AsNTtwTydVUSFMU08sNTtwT09RIUxRLUU5Uy1FOVNPIyBjUSFMU083KyVbT09RIUxRNyslXjcrJV5PIyBxUSFMU08xRzJuTyMhYFEhTFNPNyslXk8jIWVRIUxTTycjRllPIyF4USFMU08xRzJ0TyMjUVEhTFNPNyslW08jI1ZRIUxTTycjRmBPIyNwUSFMU08sNT1oTyMjcFEhTFNPLDU9aE8jJE9PTWhPJyNEeE8jJFpPUU8nI0d9T09PTzFHL3wxRy98TyMkYFEhTFNPMUcvfE8jJGhRIUxVTzFHMWxPT1EhTFEsNTxULDU8VE9PUSFMUS1FOWctRTlnT09RIUxRNysmcjcrJnJPT1EhTFExRzJqMUcyak9PUSFMUSw1O28sNTtvT09RIUxRLUU5Ui1FOVJPT1EhTFE3KyRwNyskcE8jJVJRIUxTTycjRmZPIyVvUSFMU08sNTxtTyMmUVEhTFVPLDU7ck9PUSFMUS1FOVUtRTlVT09RIUxRNysmUTcrJlFPIyZlUSFMU083KyZRT09RIUxRNysmUzcrJlNPIyZzUSFMU08nI0haTzBTUSFMU083KyZTTyMnWFEhTFNPNysmU09PUSFMUSw1PFcsNTxXT09RIUxRLUU5ai1FOWpPT1EhTFEsNTxTLDU8U09PUSFMUS1FOWYtRTlmTyMnZFEmRlhPNysmXk8hSHhRIUxTTycjRm9PM1VRIUxTTzcrJl5PM1VRIUxTTzcrJmFPIyp4USFMVU8sNTxbTydVUSFMU08sNTxbT09RIUxRLUU5bi1FOW5PIytTUSFMU08xRzNkTzNVUSFMU083KyZjTy9tUSFMU083KyZjT09RJkZWNysmaDcrJmhPIUpYUSMpV083KyZqTyMrW1EmRldPMUcwc09PUSZGVi1FOW8tRTlvTzNVUSFMU083KyZkTzNVUSFMU083KyZkT09RJkZWLDU8XSw1PF1PIytnUSFMU08sNTxdT09RJkZWNysmZDcrJmRPIytyUSZGWE83KyZkTyMvVFEhTFNPLDU8Xk9PUSFMUS1FOXAtRTlwTyMvYFEhTFNPMUczZU8jL2hRIUxTTycjSGFPIy92USFMU08nI0hhTzBTUSFMU08nI0hhT09RIUxRJyNIYScjSGFPIzBSUSFMU08nI0hgT09RIUxRLDU7Ziw1O2ZPIzBaUSFMU08sNTtmTy9tUSFMU08nI0V8T09RJkZWNysmajcrJmpPM1VRIUxTTzcrJmpPT1EmRlY3KyZvNysmb09PUSFMUTFHMnYxRzJ2T09RIUxRLDU7dSw1O3VPT1EhTFEtRTlYLUU5WE8jMGBRIUxTTyw1O3ZPIzBrUSFMU08sNTt2T09RIUxRLUU5WS1FOVlPIzFPUSFMU08xRzJ3TyMxV1EhTFNPMUcyd08jMWhRIUxTTzFHMndPIzFPUSFMU08xRzJ3T09RIUxRPDxIWDw8SFhPIzFzUSFMVU8xRzFdT09RIUxRPDxIajw8SGpQIzF9USFMU08nI0ZWTzZ8USFMU08xRzJvTyMyW1EhTFNPMUcyb08jMmFRIUxTTzw8SGpPT1EhTFE8PEhrPDxIa08jMnFRIUxVTzFHMV9PT1EhTFE8PEhyPDxIck8jMntRIUxVTzFHMVtPIzNsUSFMU083KyhgTyMzdFEhTFNPPDxIdk9PUSFMUTw8SHg8PEh4TyMzeVEhTFNPLDU7dE8nVVEhTFNPLDU7dE9PUSFMUS1FOVctRTlXT09RIUxRPDxIdjw8SHZPT1EhTFEsNTt6LDU7ek8vbVEhTFNPLDU7ek9PUSFMUS1FOV4tRTleTyM0T1EhTFNPMUczU09PT08nI0ZhJyNGYU8jNF5PTWhPLDU6ZE9PT08sNT1pLDU9aU9PT083KyVoNyslaE8jNGlRIUxTTzFHMlhPL21RIUxTTzw8SWxPIzR6USFMU08nI0ZrTyM1YFEhTFNPLDU9dU8wU1EhTFNPLDU9dU8jNXFRIUxTTzw8SW5PT1EhTFE8PEluPDxJbk8wU1EhTFNPPDxJbk9PUSZGVi1FOW0tRTltTzNVUSFMU088PEl4T09RJkZWLDU8Wiw1PFpPM1VRIUxTTyw1PFpPT1EmRlY8PEl4PDxJeE9PUSZGVjw8SXs8PEl7TyM1dlEhTFVPMUcxdk8jNlFRJkZYTzw8SX1PM1VRIUxTTzw8SX1PT1EmRlY8PEpVPDxKVU8zVVEhTFNPPDxKVU8hQ25RIUxUTycjRm5PIzljUSZGV083KyZfT09RJkZWNysmXzcrJl9PT1EmRlY8PEpPPDxKT08jOW5RJkZYTzw8Sk9PT1EmRlYxRzF3MUcxd08wU1EhTFNPMUcxd08zVVEhTFNPPDxKT08wU1EhTFNPMUcxeE8jPVBRIUxTTzcrKVBPT1EhTFEnI0V7JyNFe08vbVEhTFNPLDU9e08jPVhRIUxTTyw1PXtPT1EhTFEsNT17LDU9e08jPWRRIUxTTycjRnNPIz1uUSFMU08sNT16T09RIUxRMUcxUTFHMVFPT1EhTFEsNTtoLDU7aE8jPXZRIUxTTzFHMWJPIz5aUSFMU08xRzFiTyM+a1EhTFNPMUcxYk8jPnZRIUxTTzcrKGNPIz52USFMU083KyhjTyM/T1EhTFNPNysoY08jP2BRIUxTTzcrKFpPNnxRIUxTTzcrKFpPT1EhTFFBTj5VQU4+VU9PUSFMUUFOPmJBTj5iTy9tUSFMU08xRzFgTyM/eVEhTFVPMUcxYE9PUSFMUTFHMWYxRzFmT09PTy1FOV8tRTlfT09RIUxRQU4/V0FOP1dPI0BUUSFMU08sNTxWT09RIUxRLUU5aS1FOWlPI0BpUSFMU08xRzNhT09RIUxRQU4/WUFOP1lPI0B6USFMU09BTj9ZT09RJkZWQU4/ZEFOP2RPT1EmRlYxRzF1MUcxdU8zVVEhTFNPQU4/aU8jQVBRJkZYT0FOP2lPT1EmRlZBTj9wQU4/cE9PUSZGVSw1PFksNTxZT09RJkZVLUU5bC1FOWxPT1EmRlY8PEl5PDxJeU8zVVEhTFNPQU4/ak8zVVEhTFNPNysnY09PUSZGVkFOP2pBTj9qT09RIUxRNysnZDcrJ2RPT1EhTFExRzNnMUczZ08vbVEhTFNPMUczZ09PUSFMUSw1PF8sNTxfT09RIUxRLUU5cS1FOXFPI0RiUSFMU083KyZ8TyNEclEhTFNPNysmfE9PUSFMUTcrJnw3KyZ8TyNEfVEhTFNPPDxLfU8jRH1RIUxTTzw8S31PI0VWUSFMU08nI0drT09RIUxRPDxLdTw8S3VPI0VhUSFMU088PEt1T09RIUxRNysmejcrJnpPMFNRIUxTTzFHMXFPI0V6USFMU083Kyh7T09RIUxRRzI0dEcyNHRPT1EmRlZHMjVURzI1VE8zVVEhTFNPRzI1VE9PUSZGVkcyNVVHMjVVT09RJkZWPDxKfTw8Sn1PT1EhTFE3KylSNyspUk9PUSFMUTw8Smg8PEpoTyNGXVEhTFNPPDxKaE8jRm1RIUxTT0FOQWlPI0Z1USFMU08nI0dsT09RIUxRJyNHbCcjR2xPMG5RIUxTTycjRGJPI0dgUSFMU08sNT1WT09RIUxRQU5BYUFOQWFPT1EhTFE3KyddNysnXU9PUSZGVkxEKm9MRCpvT09RIUxRQU5AU0FOQFNPI0d3USFMU08sNTl8T09RIUxRMUcycTFHMnFPI0VWUSFMU08xRy9oT09RIUxRNyslUzcrJVNPNnxRIUxTTycjQ3pPNnxRIUxTTyw1OV9PNnxRIUxTTyw1OV9PNnxRIUxTTyw1OV9PI0d8USFMVU8sNTxtTzZ8USFMU08xRy55Ty9tUSFMU08xRy9VTy9tUSFMU083KyRtTydVUSFMU08nI0dSTyNIYVEhTFNPLDU5X08jSGZRIUxTTyw1OV9PI0htUSFMU08sNTlqTyNIclEhTFNPMUcvUk8wblEhTFNPJyNET082fFEhTFNPLDU5Z1wiLFxuICBzdGF0ZURhdGE6IFwiI0lUfk8kcU9TJGxPUyRrT1NRT1N+T1BoT1RlT2RzT2ZYT2x0T3AhU09zdU91ZE99dk8hTyFQTyFTIVZPIVQhVU8hV1lPIVtaTyFnZE8hbmRPIW9kTyFwZE8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyNkIVRPI2chV08jayFYTyNtIVlPI3IhWk8jdWxPJGpxTyR8UU8kfVFPJVJSTyVTVk8lZ1tPJWhdTyVrXk8lbl9PJXRgTyV3YU8leWJPfk9UIWFPXSFhT18hYk9mIWpPIVchbE8hZSFtTyR3IVtPJHghXU8keSFeTyR6IV9PJHshX08kfCFgTyR9IWBPJU8hYU8lUCFhTyVRIWFPfk9oJVZYaSVWWGolVlhrJVZYbCVWWG0lVlhwJVZYeCVWWHklVlghdCVWWCNfJVZYJGolVlgkbSVWWCVYJVZYIVAlVlghUyVWWCFUJVZYJVklVlghWCVWWCFdJVZYIU8lVlgjVyVWWHElVlghayVWWH5QJGJPZHNPZlhPdWRPIVdZTyFbWk8hZ2RPIW5kTyFvZE8hcGRPJHxRTyR9UU8lUlJPJVNWTyVnW08laF1PJWteTyVuX08ldGBPJXdhTyV5Yk9+T3glVVh5JVVYI18lVVgkaiVVWCRtJVVYJVglVVh+T2ghcE9pIXFPaiFvT2shb09sIXJPbSFzT3AhdE8hdCVVWH5QKGZPVCF6T2wscU9zLU9PfXZPflAnVU9UIX1PbCxxT3MtT08hWCNPT35QJ1VPVCNST18jU09sLHFPcy1PTyFdI1RPflAnVU8laSNXTyVqI1lPfk8lbCNaTyVtI1lPfk8hWyNdTyVvI15PJXMjYE9+TyFbI11PJXUjYU8ldiNgT35PIVsjXU8laiNgTyV4I2NPfk8hWyNdTyVtI2BPJXojZU9+T1QkdlhdJHZYXyR2WGYkdlhoJHZYaSR2WGokdlhrJHZYbCR2WG0kdlhwJHZYeCR2WCFXJHZYIWUkdlgkdyR2WCR4JHZYJHkkdlgkeiR2WCR7JHZYJHwkdlgkfSR2WCVPJHZYJVAkdlglUSR2WCFQJHZYIVMkdlghVCR2WH5PJWdbTyVoXU8la15PJW5fTyV0YE8ld2FPJXliT3kkdlghdCR2WCNfJHZYJGokdlgkbSR2WCVYJHZYJVkkdlghWCR2WCFdJHZYIU8kdlgjVyR2WHEkdlghayR2WH5QK3tPeCNqT3kkdVghdCR1WCNfJHVYJGokdVgkbSR1WCVYJHVYfk9sLHFPcy1PT35QJ1VPI18jbU8kaiNvTyRtI29Pfk8lU1ZPfk8hUyN0TyNtIVlPI3IhWk8jdWxPfk9sdE9+UCdVT1QjeU9fI3pPdSN4TyVTVk95dFB+T1QkT09sLHFPcy1PTyFPJFBPflAnVU95JFJPIXQkV08lWCRTTyNfIXVYJGohdVgkbSF1WH5PVCRPT2wscU9zLU9PflAnVU9sLHFPcy1PTyNfI1NYJGojU1gkbSNTWH5QJ1VPIWUkXk8hbiReTyVTVk9+T1QkaE9+UCdVTyFUJGpPI2ska08jbSRsT35PeSRtT35PVCR8T18kfE9sLHFPcy1PTyFQJU9PflAnVU9sLHFPcy1PT3klUk9+UCdVTyVmJVRPfk9fIWJPZiFqTyFXIWxPIWUhbU9UYGFdYGFoYGFpYGFqYGFrYGFsYGFtYGFwYGF4YGF5YGEhdGBhI19gYSRqYGEkbWBhJHdgYSR4YGEkeWBhJHpgYSR7YGEkfGBhJH1gYSVPYGElUGBhJVFgYSVYYGEhUGBhIVNgYSFUYGElWWBhIVhgYSFdYGEhT2BhI1dgYXFgYSFrYGF+T2slWU9+T2wlWU9+UCdVT2wscU9+UCdVT2gsc09pLHRPaixyT2ssck9sLHpPbSx7T3AtUE8hUCVVWCFTJVVYIVQlVVglWSVVWCFYJVVYIV0lVVghTyVVWCNXJVVYIWslVVh+UChmTyVZJVtPeCVUWCFQJVRYIVMlVFghVCVUWCFYJVRYeSVUWH5PeCVfTyFQJV5PIVMlY08hVCViT35PIVAlXk9+T3glZk8hUyVjTyFUJWJPIVglYVh+TyFYJWpPfk94JWtPeSVtTyFTJWNPIVQlYk8hXSVbWH5PIV0lcU9+TyFdJXJPfk8laSNXTyVqJXRPfk8lbCNaTyVtJXRPfk9UJXdPbCxxT3MtT099dk9+UCdVTyFbI11PJW8jXk8lcyV6T35PIVsjXU8ldSNhTyV2JXpPfk8hWyNdTyVqJXpPJXgjY09+TyFbI11PJW0lek8leiNlT35PVCFtYV0hbWFfIW1hZiFtYWghbWFpIW1haiFtYWshbWFsIW1hbSFtYXAhbWF4IW1heSFtYSFXIW1hIWUhbWEhdCFtYSNfIW1hJGohbWEkbSFtYSR3IW1hJHghbWEkeSFtYSR6IW1hJHshbWEkfCFtYSR9IW1hJU8hbWElUCFtYSVRIW1hJVghbWEhUCFtYSFTIW1hIVQhbWElWSFtYSFYIW1hIV0hbWEhTyFtYSNXIW1hcSFtYSFrIW1hflAjeU94I2pPeSR1YSF0JHVhI18kdWEkaiR1YSRtJHVhJVgkdWF+UCRiT1QmUU9sdE9zdU94JFlYeSRZWCF0JFlYI18kWVgkaiRZWCRtJFlYJVgkWVh+UCdVT3gjak95JHVhIXQkdWEjXyR1YSRqJHVhJG0kdWElWCR1YX5PUGhPVGVPbHRPc3VPfXZPIU8hUE8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyNfJGFYJGokYVgkbSRhWH5QJ1VPI18jbU8kaiZWTyRtJlZPfk8hZSZXT2YlfFgkaiV8WCNXJXxYI18lfFgkbSV8WCNWJXxYfk9mIWpPJGomWU9+T2hjYWljYWpjYWtjYWxjYW1jYXBjYXhjYXljYSF0Y2EjX2NhJGpjYSRtY2ElWGNhIVBjYSFTY2EhVGNhJVljYSFYY2EhXWNhIU9jYSNXY2FxY2Eha2NhflAkYk9wbmF4bmF5bmEjX25hJGpuYSRtbmElWG5hfk9oIXBPaSFxT2ohb09rIW9PbCFyT20hc08hdG5hflBEV08lWCZbT3glV1h5JVdYfk8lU1ZPeCVXWHklV1h+T3gmX095dFh+T3kmYU9+T3gla08jXyVbWCRqJVtYJG0lW1ghUCVbWHklW1ghXSVbWCFrJVtYJVglW1h+T1QseU9sLHFPcy1PT312T35QJ1VPJVgkU08jX1NhJGpTYSRtU2F+TyVYJFNPfk94JmpPI18lXlgkaiVeWCRtJV5YayVeWH5QJGJPeCZtTyFPJmxPI18jU2EkaiNTYSRtI1Nhfk8jVyZuTyNfI1VhJGojVWEkbSNVYX5PIWUkXk8hbiReTyNWJnBPJVNWT35PI1YmcE9+T3gmck8jXyZPWCRqJk9YJG0mT1h+T3gmdE8jXyV7WCRqJXtYJG0le1h5JXtYfk94JnhPayZRWH5QJGJPayZ7T35PUGhPVGVPbHRPc3VPfXZPIU8hUE8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyRqJ1FPflAnVU9xJ1VPI2gnU08jaSdUT1AjZmFUI2ZhZCNmYWYjZmFsI2ZhcCNmYXMjZmF1I2ZhfSNmYSFPI2ZhIVMjZmEhVCNmYSFXI2ZhIVsjZmEhZyNmYSFuI2ZhIW8jZmEhcCNmYSF3I2ZhIXkjZmEheyNmYSF9I2ZhI1AjZmEjVCNmYSNWI2ZhI1kjZmEjWiNmYSNdI2ZhI2QjZmEjZyNmYSNrI2ZhI20jZmEjciNmYSN1I2ZhJGkjZmEkaiNmYSR8I2ZhJH0jZmElUiNmYSVTI2ZhJWcjZmElaCNmYSVrI2ZhJW4jZmEldCNmYSV3I2ZhJXkjZmEkbSNmYSRuI2ZhJG8jZmF+T3gnVk8jVydYT3kmUlh+T2YnWk9+T2Yhak95JG1Pfk9UIWFPXSFhT18hYk9mIWpPIVchbE8hZSFtTyR5IV5PJHohX08keyFfTyR8IWBPJH0hYE8lTyFhTyVQIWFPJVEhYU9oVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSVYVWkhUFVpIVNVaSFUVWklWVVpIVhVaSFdVWkhT1VpI1dVaXFVaSFrVWl+TyR4IV1PflAhIFNPJHhVaX5QISBTT1QhYU9dIWFPXyFiT2Yhak8hVyFsTyFlIW1PJHwhYE8kfSFgTyVPIWFPJVAhYU8lUSFhT2hVaWlVaWpVaWtVaWxVaW1VaXBVaXhVaXlVaSF0VWkjX1VpJGpVaSRtVWkkd1VpJHhVaSR5VWklWFVpIVBVaSFTVWkhVFVpJVlVaSFYVWkhXVVpIU9VaSNXVWlxVWkha1Vpfk8keiFfTyR7IV9PflAhI31PJHpVaSR7VWl+UCEjfU9fIWJPZiFqTyFXIWxPIWUhbU9oVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSR4VWkkeVVpJHpVaSR7VWkkfFVpJH1VaSVYVWkhUFVpIVNVaSFUVWklWVVpIVhVaSFdVWkhT1VpI1dVaXFVaSFrVWl+T1QhYU9dIWFPJU8hYU8lUCFhTyVRIWFPflAhJntPVFVpXVVpJU9VaSVQVWklUVVpflAhJntPZiFqTyFXIWxPIWUhbU9UVWldVWlfVWloVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSR4VWkkeVVpJHpVaSR7VWkkfFVpJH1VaSVPVWklUFVpJVFVaSVYVWkhUFVpIVNVaSFUVWklWVVpIVhVaSFdVWkhT1VpI1dVaXFVaSFrVWl+TyFTJWNPIVQlYk94JWRYIVAlZFh+TyVYJ2BPJVknYE9+UCt7T3gnYk8hUCVjWH5PIVAnZE9+T3gnZU95J2dPIVglZVh+T2wscU9zLU9PeCdlT3knaE8hWCVlWH5QJ1VPIVgnak9+T2ohb09rIW9PbCFyT20hc09oZ2lwZ2l4Z2l5Z2khdGdpI19naSRqZ2kkbWdpJVhnaX5PaSFxT35QIS5eT2lnaX5QIS5eT2gsc09pLHRPaixyT2ssck9sLHpPbSx7T35PcSdsT35QIS9nT1QncU9sLHFPcy1PTyFQJ3JPflAnVU94J3NPIVAnck9+TyFQJ3VPfk8hVCd3T35PeCdzTyFQJ3hPIVMlY08hVCViT35QJGJPaCxzT2ksdE9qLHJPayxyT2wsek9tLHtPIVBuYSFTbmEhVG5hJVluYSFYbmEhXW5hIU9uYSNXbmFxbmEha25hflBEV09UJ3xPbCxxT3MtT094I3tYIVgje1h+UCdVT3glZk8hWCVhYX5PIVgoT09+T3glZk8hUyVjTyFUJWJPIVglYWF+UCRiT1QoU09sLHFPcy1PT3gjeFghXSN4WCNfI3hYJGojeFgkbSN4WCFQI3hYeSN4WCFrI3hYJVgjeFh+UCdVT3gla08hXSVbYSNfJVthJGolW2EkbSVbYSFQJVtheSVbYSFrJVthJVglW2F+TyFdKFZPfk94JWtPIVMlY08hVCViTyFdJVthflAkYk94KFlPIVMlY08hVCViTyFdJWJhflAkYk94KF1PeSVwWCFdJXBYIWslcFh+T3koYE8hXShiTyFrKGNPfk94I2pPeSR1aSF0JHVpI18kdWkkaiR1aSRtJHVpJVgkdWl+TyFlJldPZiV8YSRqJXxhI1clfGEjXyV8YSRtJXxhI1YlfGF+TyRqKGdPfk9UI3lPXyN6T3UjeE8lU1ZPfk94Jl9PeXRhfk9sdE9zdU9+UCdVT3gla08jXyVbYSRqJVthJG0lW2EhUCVbYXklW2EhXSVbYSFrJVthJVglW2F+UCRiT3gobE8jXyR1WCRqJHVYJG0kdVglWCR1WH5PJVgkU08jX1NpJGpTaSRtU2l+T3gjelgjXyN6WCRqI3pYJG0jelhrI3pYflAnVU94JmpPI18lXmEkaiVeYSRtJV5hayVeYX5PVChyT2YodE8lU1ZPfk8jVih1T35PJVNWT3gkYFgjXyRgWCRqJGBYJG0kYFh+T3gmck8jXyZPYSRqJk9hJG0mT2F+T2wscU9zLU9PeCRbWCNfJFtYJGokW1gkbSRbWHkkW1h+UCdVT3gmdE8jXyV7YSRqJXthJG0le2F5JXthfk9xKHxPI2Ioe09QI2BpVCNgaWQjYGlmI2BpbCNgaXAjYGlzI2BpdSNgaX0jYGkhTyNgaSFTI2BpIVQjYGkhVyNgaSFbI2BpIWcjYGkhbiNgaSFvI2BpIXAjYGkhdyNgaSF5I2BpIXsjYGkhfSNgaSNQI2BpI1QjYGkjViNgaSNZI2BpI1ojYGkjXSNgaSNkI2BpI2cjYGkjayNgaSNtI2BpI3IjYGkjdSNgaSRpI2BpJGojYGkkfCNgaSR9I2BpJVIjYGklUyNgaSVnI2BpJWgjYGklayNgaSVuI2BpJXQjYGkldyNgaSV5I2BpJG0jYGkkbiNgaSRvI2Bpfk9xKH1PUCNjaVQjY2lkI2NpZiNjaWwjY2lwI2NpcyNjaXUjY2l9I2NpIU8jY2khUyNjaSFUI2NpIVcjY2khWyNjaSFnI2NpIW4jY2khbyNjaSFwI2NpIXcjY2kheSNjaSF7I2NpIX0jY2kjUCNjaSNUI2NpI1YjY2kjWSNjaSNaI2NpI10jY2kjZCNjaSNnI2NpI2sjY2kjbSNjaSNyI2NpI3UjY2kkaSNjaSRqI2NpJHwjY2kkfSNjaSVSI2NpJVMjY2klZyNjaSVoI2NpJWsjY2klbiNjaSV0I2NpJXcjY2kleSNjaSRtI2NpJG4jY2kkbyNjaX5PVClQT2skZFh4JGRYflAnVU94JnhPayZRYX5PeCZ4T2smUWF+UCRiT2spVE9+T1BoT1RlT2x0T3AhU09zdU99dk8hTyFQTyFTIVZPIVQhVU8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyNkIVRPI2chV08jayFYTyNtIVlPI3IhWk8jdWxPflAnVU9xKVpPI2gnU08jaSlZT1AjZmlUI2ZpZCNmaWYjZmlsI2ZpcCNmaXMjZml1I2ZpfSNmaSFPI2ZpIVMjZmkhVCNmaSFXI2ZpIVsjZmkhZyNmaSFuI2ZpIW8jZmkhcCNmaSF3I2ZpIXkjZmkheyNmaSF9I2ZpI1AjZmkjVCNmaSNWI2ZpI1kjZmkjWiNmaSNdI2ZpI2QjZmkjZyNmaSNrI2ZpI20jZmkjciNmaSN1I2ZpJGkjZmkkaiNmaSR8I2ZpJH0jZmklUiNmaSVTI2ZpJWcjZmklaCNmaSVrI2ZpJW4jZmkldCNmaSV3I2ZpJXkjZmkkbSNmaSRuI2ZpJG8jZml+T2wscU9zLU9PeSRtT35QJ1VPbCxxT3MtT094JGZYeSRmWH5QJ1VPeCdWT3kmUmF+T1QpZE9fKWVPdSljTyVPKWZPJVNWT35PIVApaE9+UCFJb095JG1PJlUpak9+T1QkfE9fJHxPbCxxT3MtT094I31YIVAjfVh+UCdVT3gnYk8hUCVjYX5PbCxxT3MtT095KXJPeCRPWCFYJE9YflAnVU94J2VPIVglZWF+T2wscU9zLU9PeCdlT3kpdU8hWCVlYX5QJ1VPbCxxT3MtT094J2VPIVglZWF+UCdVT3gnZU95KXVPIVglZWF+T2osck9rLHJPbCx6T20se09oZ2lwZ2l4Z2khUGdpIVNnaSFUZ2klWWdpIVhnaXlnaSFdZ2kjX2dpJGpnaSRtZ2khT2dpI1dnaXFnaSFrZ2klWGdpfk9pLHRPflAhTGxPaWdpflAhTGxPVCdxT2wscU9zLU9PIVApek9+UCdVT2spfE9+T3gqT08hUCl6T35PIVAqUE9+T3glZk8hWCVhaX5PIVgqUk9+T3goWU8hUyVjTyFUJWJPIV0lYml+T3gla08hXSVbaSNfJVtpJGolW2kkbSVbaSFQJVtpeSVbaSFrJVtpJVglW2l+TyFdKlZPfk9fKlhPbCxxT3MtT094I3xYIV0jfFh+UCdVT3goWU8hXSViaX5PIV0qWk9+T1QqXU9sLHFPcy1PT3gkU1h5JFNYIV0kU1ghayRTWH5QJ1VPeChdT3klcGEhXSVwYSFrJXBhfk8hWyNdTyVyKmBPIV0hbFh+TyFdKmJPfk95KGBPIV0qY09+T3gkWWl5JFlpIXQkWWkjXyRZaSRqJFlpJG0kWWklWCRZaX5QJGJPVCZRT2wscU9zLU9PeCRZWCNfJFlYJGokWVgkbSRZWCVYJFlYflAnVU94KGxPI18kdWEkaiR1YSRtJHVhJVgkdWF+T3gjemEjXyN6YSRqI3phJG0jemFrI3phflAkYk94KmVPI18jU3EkaiNTcSRtI1Nxfk94KmZPI1cqaE8jXyV9WCRqJX1YJG0lfVghUCV9WH5PVCpqT2Yqa08lU1ZPfk9xKm1PI2Ioe09QI2BxVCNgcWQjYHFmI2BxbCNgcXAjYHFzI2BxdSNgcX0jYHEhTyNgcSFTI2BxIVQjYHEhVyNgcSFbI2BxIWcjYHEhbiNgcSFvI2BxIXAjYHEhdyNgcSF5I2BxIXsjYHEhfSNgcSNQI2BxI1QjYHEjViNgcSNZI2BxI1ojYHEjXSNgcSNkI2BxI2cjYHEjayNgcSNtI2BxI3IjYHEjdSNgcSRpI2BxJGojYHEkfCNgcSR9I2BxJVIjYHElUyNgcSVnI2BxJWgjYHElayNgcSVuI2BxJXQjYHEldyNgcSV5I2BxJG0jYHEkbiNgcSRvI2Bxfk9rJGRheCRkYX5QJGJPeCZ4T2smUWl+TyRtKnlPJG4qd08kbyp5T35PeCp9T3kkbU8jVyp9T35PI2krT09QI2ZxVCNmcWQjZnFmI2ZxbCNmcXAjZnFzI2ZxdSNmcX0jZnEhTyNmcSFTI2ZxIVQjZnEhVyNmcSFbI2ZxIWcjZnEhbiNmcSFvI2ZxIXAjZnEhdyNmcSF5I2ZxIXsjZnEhfSNmcSNQI2ZxI1QjZnEjViNmcSNZI2ZxI1ojZnEjXSNmcSNkI2ZxI2cjZnEjayNmcSNtI2ZxI3IjZnEjdSNmcSRpI2ZxJGojZnEkfCNmcSR9I2ZxJVIjZnElUyNmcSVnI2ZxJWgjZnElayNmcSVuI2ZxJXQjZnEldyNmcSV5I2ZxJG0jZnEkbiNmcSRvI2Zxfk8jVytQT3gkZmF5JGZhfk94J1ZPeSZSaX5PeSRSTyVYK1JPeCZUWCFQJlRYfk8lU1ZPeCZUWCFQJlRYfk94K1ZPIVAmU1h+TyFQK1hPfk95K1pPeCRPYSFYJE9hfk9sLHFPcy1PT3krW094JE9hIVgkT2F+UCdVT3gnZU8hWCVlaX5PbCxxT3MtT094J2VPIVglZWl+UCdVT3gnZU95K2BPIVglZWl+T3gjeWkhUCN5aX5QJGJPVCdxT2wscU9zLU9PflAnVU9rK2JPfk9UJ3FPbCxxT3MtT08hUCtjT35QJ1VPeCN7aSFYI3tpflAkYk94I3hpIV0jeGkjXyN4aSRqI3hpJG0jeGkhUCN4aXkjeGkhayN4aSVYI3hpflAkYk94KFlPIV0lYnF+TyFdK2RPfk95K2VPfk94KF1PeSVwaSFdJXBpIWslcGl+TyFbI11PJXIqYE8hXSFsYX5PeChsTyNfJHVpJGokdWkkbSR1aSVYJHVpfk8lU1ZPeCRfWCNfJF9YJGokX1gkbSRfWCFQJF9Yfk94KmZPI18lfWEkaiV9YSRtJX1hIVAlfWF+TyFQK21Pfk9rJGRpeCRkaX5QJGJPcStxT1AjZXlUI2V5ZCNleWYjZXlsI2V5cCNleXMjZXl1I2V5fSNleSFPI2V5IVMjZXkhVCNleSFXI2V5IVsjZXkhZyNleSFuI2V5IW8jZXkhcCNleSF3I2V5IXkjZXkheyNleSF9I2V5I1AjZXkjVCNleSNWI2V5I1kjZXkjWiNleSNdI2V5I2QjZXkjZyNleSNrI2V5I20jZXkjciNleSN1I2V5JGkjZXkkaiNleSR8I2V5JH0jZXklUiNleSVTI2V5JWcjZXklaCNleSVrI2V5JW4jZXkldCNleSV3I2V5JXkjZXkkbSNleSRuI2V5JG8jZXl+TyRtK3ZPJG4qd08kbyt2T35PI2krd09QI2Z5VCNmeWQjZnlmI2Z5bCNmeXAjZnlzI2Z5dSNmeX0jZnkhTyNmeSFTI2Z5IVQjZnkhVyNmeSFbI2Z5IWcjZnkhbiNmeSFvI2Z5IXAjZnkhdyNmeSF5I2Z5IXsjZnkhfSNmeSNQI2Z5I1QjZnkjViNmeSNZI2Z5I1ojZnkjXSNmeSNkI2Z5I2cjZnkjayNmeSNtI2Z5I3IjZnkjdSNmeSRpI2Z5JGojZnkkfCNmeSR9I2Z5JVIjZnklUyNmeSVnI2Z5JWgjZnklayNmeSVuI2Z5JXQjZnkldyNmeSV5I2Z5JG0jZnkkbiNmeSRvI2Z5fk94J1ZPeSZScX5PJVgrUk94JlRhIVAmVGF+T3gkZ1ghUCRnWH5QIUlvT3grVk8hUCZTYX5PbCxxT3MtT095LFBPeCRPaSFYJE9pflAnVU9sLHFPcy1PT3gkT2khWCRPaX5QJ1VPeSxQT3gkT2khWCRPaX5PeCdlTyFYJWVxfk9sLHFPcy1PT3gnZU8hWCVlcX5QJ1VPcCxVTyFTJWNPIVQlYk8hUCVdcSFYJV1xIV0lXXF4JV1xflAhL2dPeCN8aSFdI3xpflAkYk8jVyxZT3gkX2EjXyRfYSRqJF9hJG0kX2EhUCRfYX5PeCpmTyNfJX1pJGolfWkkbSV9aSFQJX1pfk8hUCxbT35PcSxeT1AjZSFSVCNlIVJkI2UhUmYjZSFSbCNlIVJwI2UhUnMjZSFSdSNlIVJ9I2UhUiFPI2UhUiFTI2UhUiFUI2UhUiFXI2UhUiFbI2UhUiFnI2UhUiFuI2UhUiFvI2UhUiFwI2UhUiF3I2UhUiF5I2UhUiF7I2UhUiF9I2UhUiNQI2UhUiNUI2UhUiNWI2UhUiNZI2UhUiNaI2UhUiNdI2UhUiNkI2UhUiNnI2UhUiNrI2UhUiNtI2UhUiNyI2UhUiN1I2UhUiRpI2UhUiRqI2UhUiR8I2UhUiR9I2UhUiVSI2UhUiVTI2UhUiVnI2UhUiVoI2UhUiVrI2UhUiVuI2UhUiV0I2UhUiV3I2UhUiV5I2UhUiRtI2UhUiRuI2UhUiRvI2UhUn5PbCxxT3MtT094JE9xIVgkT3F+UCdVT3ksY094JE9xIVgkT3F+T3gnZU8hWCVleX5PbCxxT3MsZ09+UCdVT3AsVU8hUyVjTyFUJWJPIVAlXXkhWCVdeSFdJV15eCVdeX5QIS9nT3gqZk8jXyV9cSRqJX1xJG0lfXEhUCV9cX5PbCxxT3MtT094JE95IVgkT3l+UCdVT3gnZU8hWCVlIVJ+T3AlYFghUCVgWCFTJWBYIVQlYFghWCVgWCFdJWBYeCVgWH5QIS9nT3AsVU8hUyVjTyFUJWJPIVAlX2EhWCVfYSFdJV9heCVfYX5PeSxvT35PeChsTyNfJHVhJGokdWEkbSR1YSVYJHVhflAkYk9rLHZPfk9sLHZPflAnVU95LHdPfk9xLHhPflAhL2dPJWglayV3JXklZyVuJXQlUyVnflwiLFxuICBnb3RvOiBcIiEmaCZVUFBQUCZWUCZfKHwpZCl7KmUrTytqUCxWUCZfLHQsdCZfUCZfUC9jUFBQUFBQL2MxYlBQMWJQMn1QM1c3YFBQN2M3bzdyUFBQJl8mX1BQOE8mX1BQJl8mX1BQJl8mXyZfJl84Uzh4Jl9QOHtQOU85TztxUDxWJl9QUFA8WjxhJlZQJlYmVlAmVlAmVlAmVlAmVlAmViZWJlZQJlZQUCZWUFAmVlA8Z1A8bjx0UDxuUDxuPG5QUFA8blA+bVA+dj58P1M+bVA8bj9ZUD9hP2c/bT95QFRAWkBlQG9AdUFjQWlBb0F1QlBCVkJdQmNCaUJvQ1JDXUNjQ2lDb0N5RFBEVkRdRGNEbURzRH1FVFBQUFBQUFBQUEVeRWhFcUV7RldQUFBQUFBQUFBQUFBJfUpnTlUhIXFQUCEheSEjWCEjYiEkVyEjfSEkYSEkZyEkaiEkbSEkcCEkdlBQUFBQUFBQUFAhJHkhJHxQUFBQUFBQUFAhJVMhJWAhJWwhJXghJXshJlIhJlghJl8hJmJdaU9yI20kbSdRKncmWGRPU1hZWmVocnN0dnh8fSFSIVMhVCFVIVghYyFkIWUhZiFnIWghaSFqIWwhbyFwIXEhcyF0IXohfSNSI1MjXSNqI20kTyRQJFIkVCRXJGgkaiRrJG0kfCVSJVklXSVfJWIlZiVrJW0ldyZRJl0mYSZqJmwmbSZ0JngmeydRJ1MnVidhJ2InZSdnJ2gnbCdxJ3Mndyd8KFMoWShdKGwoeylQKVQpailyKXUpeyl8Kk8qWCpdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx5LHstUHkhY1AjaSN2JFgkZyVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdXshZFAjaSN2JFgkZyRzJWQlaSVvJXAmYiZ6KGQobilPKXkqUSpTKnIrZix1fSFlUCNpI3YkWCRnJHMkdCVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdSFQIWZQI2kjdiRYJGckcyR0JHUlZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUhUiFnUCNpI3YkWCRnJHMkdCR1JHYlZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUhVCFoUCNpI3YkWCRnJHMkdCR1JHYkdyVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdSFYIWlQIW4jaSN2JFgkZyRzJHQkdSR2JHckeCVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdSZYU09TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWohbCFvIXAhcSFzIXQheiF9I1IjUyNdI2ojbSRPJFAkUiRUJFckaCRqJGskbSR8JVIlWSVdJV8lYiVmJWslbSV3JlEmXSZhJmombCZtJnQmeCZ7J1EnUydWJ2EnYidlJ2cnaCdsJ3Encyd3J3woUyhZKF0obCh7KVApVClqKXIpdSl7KXwqTypYKl0qZSp3K1MrWitbK2ArYitlK3wsUCxVLGMsbyxxLHIscyx0LHYsdyx4LHksey1QJHlVT1hZWmhydHZ8fSFSIVMhVCFYIWohbCFvIXAhcSFzIXQjXSNqI20kUCRSJFQkVyRrJG0kfCVSJVklXSVfJWYlayVtJXcmXSZhJmwmbSZ0JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncyhZKF0obCh7KVQpailyKXUpeyl8Kk8qXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgsey1QJFRXT1hZWmhydnx9IVIhUyFUIVghaiFsI10jaiNtJFAkUiRUJFckayRtJHwlUiVdJV8lZiVrJW0ldyZdJmEmbCZtJnQmeydRJ1MnVidhJ2InZSdnJ2gnbCdzKFkoXShsKHspVClqKXIpdSl7Kk8qXSplKncrUytaK1srYCtlK3wsUCxjLHcseFEjfHVRLG0sZ1IsfC1PJlNkT1NYWVplaHJzdHZ4fH0hUiFTIVQhVSFYIWMhZCFlIWYhZyFoIWkhbCFvIXAhcSFzIXQheiF9I1IjUyNdI2ojbSRPJFAkUiRUJFckaCRqJGskbSR8JVIlWSVdJV8lYiVmJWslbSV3JlEmXSZhJmombCZtJnQmeCZ7J1EnUydWJ2EnZSdnJ2gnbCdxJ3Mndyd8KFMoWShdKGwoeylQKVQpailyKXUpeyl8Kk8qWCpdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx5LHstUFcjcGwhTyFQJF9XI3h1Jl8sZy1PUSRhIVFRJHEhWVEkciFaUyR7IWonYlMmXiN5I3pRJ08kbFEoZSZXUShyJm5XKHMmcCh0KHUqa1EodiZyUSliJ1hTKWMnWitWUytVKWQpZVEraipmUStsKmhRK3gqfVEreitQUixqLFlSJl0jeGUhd1hZIVMhVCVfJWYncyh7KXsqT1IlXSF2USF7WFEleCNdUSZmJFRSJmkkV1QsZixVLG8hWSFrUCFuI2kjdiRYJGckcyR0JHUkdiR3JHgkeSVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdVEmWiNxUideJHJSJ2Eke1IlVSFtJldjT1NYWVplaHJzdHZ4fH0hUiFTIVQhVSFYIWMhZCFlIWYhZyFoIWkhaiFsIW8hcCFxIXMhdCF6IX0jUiNTI10jaiNtJE8kUCRSJFQkVyRoJGokayRtJHwlUiVZJV0lXyViJWYlayVtJXcmUSZdJmEmaiZsJm0mdCZ4JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncSdzJ3cnfChTKFkoXShsKHspUClUKWopcil1KXspfCpPKlgqXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgseSx7LVBUI2djI2hTI15fI19TI2FgI2JTI2NhI2RTI2ViI2ZUKmAoYCphVChhJXgoY1EkVndSK1QpY1gkVHckVSRWJmhaa09yJG0nUSp3WG9PcidRKndRJG4hV1EmdiRlUSZ3JGZRJ1kkcFEnXSRyUSlVJn1RKVsnU1EpXidUUSlfJ1VRKWsnW1EpbSdeUSpuKHtRKnAofFEqcSh9USpzKVNTKnUpVilsUSp6KVlRKnspWlEqfCldUStvKm1RK3Aqb1Ercip0UStzKnZRK3krT1EsXStxUSxfK3dRLGAreFIsayxeV29PcidRKndSI3NuUSdbJHFSKVYnT1ErUyljUit8K1RRKWwnW1IqdilWWm1PbnInUSp3UXJPUiN1clEmYCN7UihqJmBTJWwjUSN9UyhUJWwoV1QoVyVvJmJRJWAheVMndCVgJ3lSJ3klZFEmayRYUihvJmtRJWchfFMnfSVnKFBSKFAlaVEoWiVwUSpUKFVUKlkoWipUUSdjJH1SKXAnY1MnZiVRJVJZKXMnZil0K14sUyxkVSl0J2cnaCdpVSteKXUpdil3UyxTK18rYFIsZCxUUSNYXVIlcyNYUSNbXlIldSNbUSNfX1IleSNfUSheJXZTKl4oXipfUipfKF9RKmEoYFIraCphUSNiYFIleyNiUSNkYVIlfCNkUSNmYlIlfSNmUSNoY1ImTyNoUSNrZlEmUCNpVyZTI2smUChtKmRRKG0mZVIqZCx1USRVd1MmZyRVJmhSJmgkVlEmdSRjUih5JnVRJlgjcFIoZiZYUSRfIVBSJm8kX1EqZyhzUytrKmcsWlIsWitsUSZzJGFSKHcmc1EjbmpSJlUjblEqeClXUit1KnhRKHomdlIqbCh6USZ5JGdTKVEmeSlSUilSJnpRJ1IkblIpWCdSUSdXJG9TKWEnVytRUitRKWJRK1cpZ1IsTytXV25PcidRKndSI3JuU3FPclEpVydRUit0KndXcE9yJ1Eqd1InUCRtWWpPciRtJ1Eqd1ImVCNtW3dPciNtJG0nUSp3UiZmJFQkeFBPWFlaaHJ0dnx9IVIhUyFUIVghaiFsIW8hcCFxIXMhdCNdI2ojbSRQJFIkVCRXJGskbSR8JVIlWSVdJV8lZiVrJW0ldyZdJmEmbCZtJnQmeydRJ1MnVidhJ2InZSdnJ2gnbCdzKFkoXShsKHspVClqKXIpdSl7KXwqTypdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx7LVBRIW5TUSNpZVEjdnNVJFh4JWInd1MkZyFVJGpRJHMhY1EkdCFkUSR1IWVRJHYhZlEkdyFnUSR4IWhRJHkhaVElZCF6USVpIX1RJW8jUlElcCNTUSZiJE9RJnokaFEoZCZRUShuJmpRKU8meFEpeSdxUSpRJ3xRKlMoU1EqcilQUStmKlhSLHUseVEheVhRIXxZUSRlIVNRJGYhVFcncCVfJ3MpeypPUSd7JWZSKm8oe1tmT3IjbSRtJ1Eqd2QhdlhZIVMhVCVfJWYncyh7KXsqT1EjUVpRI2xoUyN9dnxRJFt9VyRjIVIkVyZ7KVRTJG8hWCRrUyR6IWonYlElUSFsUSV2I11TJlIjaihsUSZjJFBRJmQkUlEmZSRUUSdfJHxRJ2klUlEnbyVdUShSJWtRKFUlbVEoXyV3UShoJl1TKGsmYSx3UShwJmxRKHEmbVEoeCZ0USldJ1NRKWAnVlEpbidhUSlxJ2VRKXYnZ1EpdydoUyl4J2wseFEqVyhZUSpbKF1RK1kpalErXSlyUStfKXVRK2cqXVEraSplUSt7K1NRLFErWlEsUitbUSxUK2BRLFgrZVEsYSt8USxiLFBSLGwsY2JUT3IjaiNtJG0mYSdRJ2wqdyNwIXVYWVpodnx9IVIhUyFUIVghaiFsI10kUCRSJFQkVyRrJHwlUiVdJV8lZiVrJW0ldyZdJmwmbSZ0JnsnUydWJ2EnYidlJ2cnaCdzKFkoXShsKHspVClqKXIpdSl7Kk8qXSplK1MrWitbK2ArZSt8LFAsYyx3LHhRI3d0VyVWIW8hcyxyLHtRJVchcFElWCFxUSVaIXRRJWUscVMnayVZLHZRJ20sc1Enbix0USthKXxRLFcrYlMsZSxVLG9SLH0tUFUje3UsZy1PUihpJl9bZ09yI20kbSdRKndYIXhYI10kVCRXUSNWWlEkUXZSJFp8USVhIXlRJWghfFElbiNRUSdfJHpRJ3olZFEoUSVpUShYJW9RKFslcFEqVShVUSxWK2FRLGksV1IsbixoUSRZeFEndiViUil9J3dRLGgsVVIscCxvUiNQWVIjVVpSJVAhalEkfSFqUilvJ2JSJVMhbFIleCNdUShiJXhSKmMoY1EkZCFSUSZpJFdRKVMme1IqdClUUSNxbFEkXSFPUSRgIVBSJnEkX1EociZwUSppKHRRKmoodVIrbiprUiRiIVFYcE9yJ1Eqd1EkaSFVUiZ8JGpRJHAhWFImfSRrUilpJ1pRKWcnWlIrfStWXCIsXG4gIG5vZGVOYW1lczogXCLimqAgcHJpbnQgQ29tbWVudCBTY3JpcHQgQXNzaWduU3RhdGVtZW50ICogQmluYXJ5RXhwcmVzc2lvbiBCaXRPcCBCaXRPcCBCaXRPcCBCaXRPcCBBcml0aE9wIEFyaXRoT3AgQCBBcml0aE9wICoqIFVuYXJ5RXhwcmVzc2lvbiBBcml0aE9wIEJpdE9wIEF3YWl0RXhwcmVzc2lvbiBhd2FpdCBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiAoIEJpbmFyeUV4cHJlc3Npb24gb3IgYW5kIENvbXBhcmVPcCBpbiBub3QgaXMgVW5hcnlFeHByZXNzaW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBpZiBlbHNlIExhbWJkYUV4cHJlc3Npb24gbGFtYmRhIFBhcmFtTGlzdCBzZWxmIFZhcmlhYmxlTmFtZSBBc3NpZ25PcCAsIDogTmFtZWRFeHByZXNzaW9uIEFzc2lnbk9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBmcm9tICkgVHVwbGVFeHByZXNzaW9uIENvbXByZWhlbnNpb25FeHByZXNzaW9uIGFzeW5jIGZvciBMYW1iZGFFeHByZXNzaW9uIEFycmF5RXhwcmVzc2lvbiBbIF0gQXJyYXlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBEaWN0aW9uYXJ5RXhwcmVzc2lvbiB7IH0gRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uIFNldEV4cHJlc3Npb24gU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gQ2FsbEV4cHJlc3Npb24gQXJnTGlzdCBBc3NpZ25PcCBNZW1iZXJFeHByZXNzaW9uIC4gUHJvcGVydHlOYW1lIE51bWJlciBTdHJpbmcgRm9ybWF0U3RyaW5nIEZvcm1hdFJlcGxhY2VtZW50IEZvcm1hdENvbnZlcnNpb24gRm9ybWF0U3BlYyBDb250aW51ZWRTdHJpbmcgRWxsaXBzaXMgTm9uZSBCb29sZWFuIFR5cGVEZWYgQXNzaWduT3AgVXBkYXRlU3RhdGVtZW50IFVwZGF0ZU9wIEV4cHJlc3Npb25TdGF0ZW1lbnQgRGVsZXRlU3RhdGVtZW50IGRlbCBQYXNzU3RhdGVtZW50IHBhc3MgQnJlYWtTdGF0ZW1lbnQgYnJlYWsgQ29udGludWVTdGF0ZW1lbnQgY29udGludWUgUmV0dXJuU3RhdGVtZW50IHJldHVybiBZaWVsZFN0YXRlbWVudCBQcmludFN0YXRlbWVudCBSYWlzZVN0YXRlbWVudCByYWlzZSBJbXBvcnRTdGF0ZW1lbnQgaW1wb3J0IGFzIFNjb3BlU3RhdGVtZW50IGdsb2JhbCBub25sb2NhbCBBc3NlcnRTdGF0ZW1lbnQgYXNzZXJ0IFN0YXRlbWVudEdyb3VwIDsgSWZTdGF0ZW1lbnQgQm9keSBlbGlmIFdoaWxlU3RhdGVtZW50IHdoaWxlIEZvclN0YXRlbWVudCBUcnlTdGF0ZW1lbnQgdHJ5IGV4Y2VwdCBmaW5hbGx5IFdpdGhTdGF0ZW1lbnQgd2l0aCBGdW5jdGlvbkRlZmluaXRpb24gZGVmIFBhcmFtTGlzdCBBc3NpZ25PcCBUeXBlRGVmIENsYXNzRGVmaW5pdGlvbiBjbGFzcyBEZWNvcmF0ZWRTdGF0ZW1lbnQgRGVjb3JhdG9yIEF0XCIsXG4gIG1heFRlcm06IDIzNixcbiAgbm9kZVByb3BzOiBbXG4gICAgW2xlemVyLk5vZGVQcm9wLmdyb3VwLCAtMTQsNCw4MSw4Myw4NCw4Niw4OCw5MCw5Miw5NCw5NSw5Niw5OCwxMDEsMTA0LFwiU3RhdGVtZW50IFN0YXRlbWVudFwiLC0yMyw2LDE2LDE5LDIxLDM3LDM4LDQ4LDQ5LDUzLDU2LDU3LDYwLDYxLDYyLDYzLDY2LDY5LDcwLDcxLDc1LDc2LDc3LDc4LFwiRXhwcmVzc2lvblwiLC05LDEwNiwxMDgsMTExLDExMywxMTQsMTE4LDEyMCwxMjUsMTI3LFwiU3RhdGVtZW50XCJdXG4gIF0sXG4gIHNraXBwZWROb2RlczogWzAsMl0sXG4gIHJlcGVhdE5vZGVDb3VudDogMzMsXG4gIHRva2VuRGF0YTogXCIhRX1NZ1IhXk9YJH1YWSV3WVskfVtdJXddcCR9cHEld3FyKGNycypVc3QyT3R1JH11djRRdnc1VXd4NXh4eUFXeXpBdHp7QmJ7fENyfH1EZn0hT0VTIU8hUEZaIVAhUUthIVEhUkxxIVIhWyEoUCFbIV0hKWkhXSFeISptIV4hXyErWiFfIWAhLGshYCFhIS1fIWEhYiR9IWIhYyEubCFjIWQhL2IhZCFlITFmIWUhaCEvYiFoIWkhOE8haSF0IS9iIXQhdSE9YiF1IXchL2IhdyF4IT9gIXghfSEvYiF9I08hQHQjTyNQIUFiI1AjUSFCYyNRI1IhQ1AjUiNTIS9iI1MjVCR9I1QjVSEvYiNVI1YhMWYjViNZIS9iI1kjWiE4TyNaI2YhL2IjZiNnIT1iI2cjaSEvYiNpI2ohP2AjaiNvIS9iI28jcCFDcyNwI3EhRFsjcSNyIUVPI3IjcyFFYSNzJGckfSRnfiEvYjxyJWBSJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laTdbJW5SJXI3W08jbyVpI3AjcSVpI3J+JWlNZyZbWiVvYCV1cCVyN1sleCFiJXojdCVpUyVsVyRxMXNPWCVpWFkmfVlbJWlbXSZ9XXAlaXBxJn1xI08laSNPI1AndyNQI28laSNwI3ElaSNyfiVpSFAnVVolcjdbJHExc09YJWlYWSZ9WVslaVtdJn1dcCVpcHEmfXEjTyVpI08jUCd3I1AjbyVpI3AjcSVpI3J+JWlIUCd8ViVyN1tPWSVpWVomfVpdJWldXiZ9XiNvJWkjcCNxJWkjcn4laTx1KHRZJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgKWQhYCNUJWkjVCNVKXQjVSNmJWkjZiNnKXQjZyNoKXQjaCNvJWkjcCNxJWkjcn4laTdfKWtSalIlcjdbTyNvJWkjcCNxJWkjcn4laTdfKXtSIWtSJXI3W08jbyVpI3AjcSVpI3J+JWlHeyplXSV2cCVvYCVyN1sleCFiJWlTJWcsWE9ZK15ZWi57Wl0rXl1eLntecitecnMvXXMjTyteI08jUDB8I1AjbyteI28jcDFiI3AjcSteI3EjcjFiI3J+K15CbStnXSVyN1slbFclZyxYT1ksYFlaJWlaXSxgXV4laV5yLGBycy1gcyNPLGAjTyNQLXAjUCNvLGAjbyNwLlUjcCNxLGAjcSNyLlUjcn4sYEJlLGddJXI3WyVnLFhPWSxgWVolaVpdLGBdXiVpXnIsYHJzLWBzI08sYCNPI1AtcCNQI28sYCNvI3AuVSNwI3EsYCNxI3IuVSNyfixgQmUtZ1IlcjdbJWcsWE8jbyVpI3AjcSVpI3J+JWlCZS11VCVyN1tPI28sYCNvI3AuVSNwI3EsYCNxI3IuVSNyfixgLFguWlYlZyxYT1kuVVpdLlVeci5VcnMucHMjTy5VI08jUC51I1B+LlUsWC51TyVnLFgsWC54UE9+LlU3ZC9TUiVyN1slbFdPI28laSNwI3ElaSNyfiVpRWMvZFglcjdbJWcsWE9yLntyczBQcyNPLnsjTyNQMGMjUCNvLnsjbyNwMHcjcCNxLnsjcSNyMHcjcn4ue0VjMFlSJW0jfCVyN1slayxYTyNvJWkjcCNxJWkjcn4laTdkMGhUJXI3W08jby57I28jcDB3I3AjcS57I3EjcjB3I3J+LntXMHxPJWxXQm0xUlQlcjdbTyNvK14jbyNwMWIjcCNxK14jcSNyMWIjcn4rXixhMWlWJWxXJWcsWE9ZLlVaXS5VXnIuVXJzLnBzI08uVSNPI1AudSNQfi5VTWcyY1hRMXMlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPWTNPWVolaVpdM09dXiVpXiNvM08jbyNwM3IjcCNxM08jcSNyM3Ijcn4zT0hQM1ZYUTFzJXI3W09ZM09ZWiVpWl0zT11eJWleI28zTyNvI3AzciNwI3EzTyNxI3IzciNyfjNPMXMzd1JRMXNPWTNyWl0zcl5+M3JHejRlVCVQUSVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlCZDR7UiF0LFclcjdbTyNvJWkjcCNxJWkjcn4laUd6NWlUJHlRJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7NlhfJXNgJXVwJXI3WyV6I3QlbFclZyxYT1k3V1laOmRaXTdXXV46ZF5yN1dyczp4c3c3V3d4O3x4I083VyNPI1A+biNQI283VyNvI3A/dCNwI3E3VyNxI3I/UyNyfjdXRnE3ZV0lcjdbJXghYiV6I3QlaVMlZyxYT1k4XllaJWlaXTheXV4laV53OF53eC1geCNPOF4jTyNQOV4jUCNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XkJlOGVdJXI3WyVnLFhPWTheWVolaVpdOF5dXiVpXnc4Xnd4LWB4I084XiNPI1A5XiNQI284XiNvI3A5ciNwI3E4XiNxI3I5ciNyfjheQmU5Y1QlcjdbTyNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XixYOXdWJWcsWE9ZOXJaXTlyXnc5cnd4LnB4I085ciNPI1A6XiNQfjlyLFg6YVBPfjlyO2g6b1IlcjdbJXghYiV6I3QlaVNPI28laSNwI3ElaSNyfiVpQ3s7VF0lcjdbJXghYiVpUyVnLFhPWTheWVolaVpdOF5dXiVpXnc4Xnd4LWB4I084XiNPI1A5XiNQI284XiNvI3A5ciNwI3E4XiNxI3I5ciNyfjheRnE8VlolcjdbJXojdCVnLFhPcjpkcnM8eHN3OmR3eD1beCNPOmQjTyNQPXAjUCNvOmQjbyNwPl8jcCNxOmQjcSNyPlUjcn46ZDhyPVJSJXI3WyV4IWIlaVNPI28laSNwI3ElaSNyfiVpRnE9Z1IlaiFmJXI3WyV6I3QlaCxYTyNvJWkjcCNxJWkjcn4laTtoPXVUJXI3W08jbzpkI28jcD5VI3AjcTpkI3Ejcj5VI3J+OmQlWz5fTyV4IWIleiN0JWlTJVs+ZFAlaVMjbyNwPmclVz5uTyV4IWIleiN0RnE+c1QlcjdbTyNvN1cjbyNwP1MjcCNxN1cjcSNyP1Mjcn43VzBlP19WJXghYiV6I3QlaVMlZyxYT1k5clpdOXJedzlyd3gucHgjTzlyI08jUDpeI1B+OXIwZT97WCVpUyVnLFhPWTlyWl05cl53OXJ3eC5weCNPOXIjTyNQOl4jUCNvOXIjbyNwQGgjcH45cjBhQHFWJXghYiV6I3QlZyxYT1k5clpdOXJedzlyd3gucHgjTzlyI08jUDpeI1B+OXJHe0FrUmYsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWk8dUJYUiFQUiVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlHe0J1VlQsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV096JWl6e0NbeyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUJlQ2NUX1IlcjdbTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7RFZUJHwsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHe0R5UngsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlNZ0VnVSR9LFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgIWFFeSFhI28laSNwI3ElaSNyfiVpPHZGUVImVSZqJXI3W08jbyVpI3AjcSVpI3J+JWlHe0ZuViFlUSVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hTyVpIU8hUEdUIVAhUSVpIVEhW0d5IVsjbyVpI3AjcSVpI3J+JWlCZUdZVCVyN1tPIU8laSFPIVBHaSFQI28laSNwI3ElaSNyfiVpQmVHcFIhbixYJXI3W08jbyVpI3AjcSVpI3J+JWlCY0hRXyFnLFYlcjdbTyFRJWkhUSFbR3khWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTR3kjUyNYJWkjWCNZSVAjWSNeJWkjXiNfS1AjXyNvJWkjcCNxJWkjcn4laUJjSVVYJXI3W097JWl7fElxfH0laX0hT0lxIU8hUSVpIVEhW0pWIVsjbyVpI3AjcSVpI3J+JWlCY0l2VCVyN1tPIVElaSFRIVtKViFbI28laSNwI3ElaSNyfiVpQmNKXlohZyxWJXI3W08hUSVpIVEhW0pWIVshbCVpIWwhbUtQIW0jUiVpI1IjU0pWI1MjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCY0tXUiFnLFYlcjdbTyNvJWkjcCNxJWkjcn4laUd7S3RWJU9SJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFQJWkhUCFRTFohUSFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUJkTGJUJVFRJXI3W08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHeU1VbSFnLFYlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIU8laSFPIVAhIFAhUCFRJWkhUSFbISFrIVshZCVpIWQhZSEjdyFlIWclaSFnIWhJUCFoIWwlaSFsIW1LUCFtIXElaSFxIXIhJVYhciF6JWkheiF7ISZfIXsjUiVpI1IjUyEhayNTI1UlaSNVI1YhI3cjViNYJWkjWCNZSVAjWSNeJWkjXiNfS1AjXyNjJWkjYyNkISVWI2QjbCVpI2wjbSEmXyNtI28laSNwI3ElaSNyfiVpQmMhIFVUJXI3W08hUSVpIVEhWyEgZSFbI28laSNwI3ElaSNyfiVpQmMhIGxfIWcsViVyN1tPIVElaSFRIVshIGUhWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTISBlI1MjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCYyEhcmEhZyxWJXI3W08hTyVpIU8hUCEgUCFQIVElaSFRIVshIWshWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTISFrI1MjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCYyEjfFclcjdbTyFRJWkhUSFSISRmIVIhUyEkZiFTI1IlaSNSI1MhJGYjUyNvJWkjcCNxJWkjcn4laUJjISRtVyFnLFYlcjdbTyFRJWkhUSFSISRmIVIhUyEkZiFTI1IlaSNSI1MhJGYjUyNvJWkjcCNxJWkjcn4laUJjISVbViVyN1tPIVElaSFRIVkhJXEhWSNSJWkjUiNTISVxI1MjbyVpI3AjcSVpI3J+JWlCYyEleFYhZyxWJXI3W08hUSVpIVEhWSElcSFZI1IlaSNSI1MhJXEjUyNvJWkjcCNxJWkjcn4laUJjISZkWiVyN1tPIVElaSFRIVshJ1YhWyFjJWkhYyFpISdWIWkjUiVpI1IjUyEnViNTI1QlaSNUI1ohJ1YjWiNvJWkjcCNxJWkjcn4laUJjISdeWiFnLFYlcjdbTyFRJWkhUSFbISdWIVshYyVpIWMhaSEnViFpI1IlaSNSI1MhJ1YjUyNUJWkjVCNaISdWI1ojbyVpI3AjcSVpI3J+JWlHeSEoZGEhZyxWJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFPJWkhTyFQISBQIVAhUSVpIVEhWyEhayFbIWclaSFnIWhJUCFoIWwlaSFsIW1LUCFtI1IlaSNSI1MhIWsjUyNYJWkjWCNZSVAjWSNeJWkjXiNfS1AjXyNvJWkjcCNxJWkjcn4laU1nISl8VHkxcyVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYCEqXSFgI28laSNwI3ElaSNyfiVpN18hKmRSJVlSJXI3W08jbyVpI3AjcSVpI3J+JWlHeyErUVIjXyxYJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laUd7IStuVmpSJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFeJWkhXiFfISxUIV8hYClkIWAhYSlkIWEjbyVpI3AjcSVpI3J+JWlCZCEsW1QkelElcjdbTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7IS1PVCVYLFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWApZCFgI28laSNwI3ElaSNyfiVpR3shLXJValIlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWApZCFgIWEhLlUhYSNvJWkjcCNxJWkjcn4laUJkIS5dVCR7USVyN1tPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpR3shL1JUXVEjdVAlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpTWchL3daJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXJWYmaiVTLFhPIVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpIUCEwc1olcjdbJWYmaiVTLFhPIVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpNZyExe2Mlb2AldXAlcjdbJXghYiV6I3QlaVMlbFclZiZqJVMsWE9yJWlycyEzV3N3JWl3eCE1T3ghUSVpIVEhWyEwaiFbIWMlaSFjIXQhMGohdCF1ITZ2IXUhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNmITBqI2YjZyE2diNnI28hMGojcCNxJWkjciRnJWkkZ34hMGpCZSEzX10lcjdbJWcsWE9ZLGBZWiVpWl0sYF1eJWlecixgcnMhNFdzI08sYCNPI1AtcCNQI28sYCNvI3AuVSNwI3EsYCNxI3IuVSNyfixgQmUhNF9UJXI3WyVnLFhPciVpcnMhNG5zI28laSNwI3ElaSNyfiVpQmUhNHVSJXI3WyVrLFhPI28laSNwI3ElaSNyfiVpQmUhNVZdJXI3WyVnLFhPWTheWVolaVpdOF5dXiVpXnc4Xnd4ITZPeCNPOF4jTyNQOV4jUCNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XkJlITZWVCVyN1slZyxYT3claXd4ITZmeCNvJWkjcCNxJWkjcn4laUJlITZtUiVyN1slaCxYTyNvJWkjcCNxJWkjcn4laUhQITdQXyVyN1slZiZqJVMsWE9yJWlycyEzV3N3JWl3eCE1T3ghUSVpIVEhWyEwaiFbIWMlaSFjIX0hMGohfSNSJWkjUiNTITBqI1MjVCVpI1QjbyEwaiNwI3ElaSNyJGclaSRnfiEwak1nIThlYyVvYCV1cCVyN1sleCFiJXojdCVpUyVsVyVmJmolUyxYT3IlaXJzITlwc3claXd4ITp8eCFRJWkhUSFbITBqIVshYyVpIWMhdCEwaiF0IXUhPFkhdSF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI2YhMGojZiNnITxZI2cjbyEwaiNwI3ElaSNyJGclaSRnfiEwakJlITl3VCVyN1sldCxYT3IlaXJzITpXcyNvJWkjcCNxJWkjcn4laUJlITpdVCVyN1tPciVpcnMhOmxzI28laSNwI3ElaSNyfiVpQmUhOnNSJXI3WyV5LFhPI28laSNwI3ElaSNyfiVpQmUhO1RUJXI3WyVuLFhPdyVpd3ghO2R4I28laSNwI3ElaSNyfiVpQmUhO2lUJXI3W093JWl3eCE7eHgjbyVpI3AjcSVpI3J+JWlCZSE8UFIlcjdbJXcsWE8jbyVpI3AjcSVpI3J+JWlIUCE8Y18lcjdbJWYmaiVTLFhPciVpcnMhOXBzdyVpd3ghOnx4IVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpNZyE9d2clb2AldXAlcjdbJXghYiV6I3QlaVMlbFclZiZqJVMsWE9yJWlycyEzV3N3JWl3eCE1T3ghUSVpIVEhWyEwaiFbIWMlaSFjIWghMGohaCFpITxZIWkhdCEwaiF0IXUhNnYhdSF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI1UhMGojVSNWITZ2I1YjWSEwaiNZI1ohPFkjWiNvITBqI3AjcSVpI3IkZyVpJGd+ITBqTWchP3VfJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXJWYmaiVTLFhPciVpcnMhM1dzdyVpd3ghNU94IVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpHeyFBWFIhVyxYJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laU1nIUFnWCVyN1tPWSR9WVold1pdJH1dXiV3XiNvJH0jbyNwIUJTI3AjcSR9I3EjciFCUyNyfiR9JmYhQmNPJW9gJXVwJXghYiV6I3QlaVMlbFc8dSFCdlIhWFIlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpR3ohQ2RUJHhRJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd5IUN8UCFbR20laVMlbFcjbyNwIURQJlkhRFtPJW9gJXVwJXghYiV6I3RHeiFEb1Qkd1Elb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpPHUhRWFPIV03XyVvYCV1cCV4IWIleiN0JWlTJWxXR3khRXRSJVIsViVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlcIixcbiAgdG9rZW5pemVyczogW2xlZ2FjeVByaW50LCAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgbmV3bGluZXMsIGJvZHlDb250aW51ZV0sXG4gIHRvcFJ1bGVzOiB7XCJTY3JpcHRcIjpbMCwzXX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDE4OCwgZ2V0OiB2YWx1ZSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogNjA2N1xufSk7XG5cbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZS5cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gRWFjaCBbbm9kZSB0eXBlXSgjdHJlZS5Ob2RlVHlwZSkgY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoXG4vLy8gaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxuY2xhc3MgTm9kZVByb3Age1xuICAgIC8vLyBDcmVhdGUgYSBuZXcgbm9kZSBwcm9wIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFcbiAgICAvLy8gYGRlc2VyaWFsaXplYCBmdW5jdGlvbi5cbiAgICBjb25zdHJ1Y3Rvcih7IGRlc2VyaWFsaXplIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmlkID0gbmV4dFByb3BJRCsrO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemUgfHwgKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgZGVmaW5lIGEgZGVzZXJpYWxpemUgZnVuY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgc3RyaW5nLXZhbHVlZCBub2RlIHByb3Agd2hvc2UgZGVzZXJpYWxpemUgZnVuY3Rpb24gaXNcbiAgICAvLy8gdGhlIGlkZW50aXR5IGZ1bmN0aW9uLlxuICAgIHN0YXRpYyBzdHJpbmcoKSB7IHJldHVybiBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ciB9KTsgfVxuICAgIC8vLyBDcmVhdGUgYSBudW1iZXItdmFsdWVkIG5vZGUgcHJvcCB3aG9zZSBkZXNlcmlhbGl6ZSBmdW5jdGlvbiBpc1xuICAgIC8vLyBqdXN0IGBOdW1iZXJgLlxuICAgIHN0YXRpYyBudW1iZXIoKSB7IHJldHVybiBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogTnVtYmVyIH0pOyB9XG4gICAgLy8vIENyZWF0ZXMgYSBib29sZWFuLXZhbHVlZCBub2RlIHByb3Agd2hvc2UgZGVzZXJpYWxpemUgZnVuY3Rpb25cbiAgICAvLy8gcmV0dXJucyB0cnVlIGZvciBhbnkgaW5wdXQuXG4gICAgc3RhdGljIGZsYWcoKSB7IHJldHVybiBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogKCkgPT4gdHJ1ZSB9KTsgfVxuICAgIC8vLyBTdG9yZSBhIHZhbHVlIGZvciB0aGlzIHByb3AgaW4gdGhlIGdpdmVuIG9iamVjdC4gVGhpcyBjYW4gYmVcbiAgICAvLy8gdXNlZnVsIHdoZW4gYnVpbGRpbmcgdXAgYSBwcm9wIG9iamVjdCB0byBwYXNzIHRvIHRoZVxuICAgIC8vLyBbYE5vZGVUeXBlYF0oI3RyZWUuTm9kZVR5cGUpIGNvbnN0cnVjdG9yLiBSZXR1cm5zIGl0cyBmaXJzdFxuICAgIC8vLyBhcmd1bWVudC5cbiAgICBzZXQocHJvcE9iaiwgdmFsdWUpIHtcbiAgICAgICAgcHJvcE9ialt0aGlzLmlkXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gcHJvcE9iajtcbiAgICB9XG4gICAgLy8vIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVNldC5leHRlbmRgXSgjdHJlZS5Ob2RlU2V0LmV4dGVuZCkgb3JcbiAgICAvLy8gW2BQYXJzZXIud2l0aFByb3BzYF0oI2xlemVyLlBhcnNlci53aXRoUHJvcHMpIHRvIGNvbXB1dGUgcHJvcFxuICAgIC8vLyB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgLy8vIG9iamVjdF0oI3RyZWUuTm9kZVR5cGVebWF0Y2gpIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1bmRlZmluZWRcbiAgICAvLy8gaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgLy8vIGl0IGRvZXMuXG4gICAgYWRkKG1hdGNoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbWF0Y2ggPSBOb2RlVHlwZS5tYXRjaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFt0aGlzLCByZXN1bHRdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBQcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuLy8vIGRlbGltaXRlcnMsIHRoaXMgaG9sZHMgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lcyAod3JpdHRlbiBhcyBhXG4vLy8gc3BhY2Utc2VwYXJhdGVkIHN0cmluZyB3aGVuIGRlY2xhcmluZyB0aGlzIHByb3AgaW4gYSBncmFtbWFyKVxuLy8vIGZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbk5vZGVQcm9wLmNsb3NlZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFRoZSBpbnZlcnNlIG9mIFtgb3BlbmVkQnlgXSgjdHJlZS5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcbi8vLyBhdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xuLy8vIG9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFVzZWQgdG8gYXNzaWduIG5vZGUgdHlwZXMgdG8gZ3JvdXBzIChmb3IgZXhhbXBsZSwgYWxsIG5vZGVcbi8vLyB0eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG4vLy8gYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLy8vIEVhY2ggbm9kZSBpbiBhIHN5bnRheCB0cmVlIGhhcyBhIG5vZGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggaXQuXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbmFtZSBvZiB0aGUgbm9kZSB0eXBlLiBOb3QgbmVjZXNzYXJpbHkgdW5pcXVlLCBidXQgaWYgdGhlXG4gICAgLy8vIGdyYW1tYXIgd2FzIHdyaXR0ZW4gcHJvcGVybHksIGRpZmZlcmVudCBub2RlIHR5cGVzIHdpdGggdGhlXG4gICAgLy8vIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIC8vLyByb2xlLlxuICAgIG5hbWUsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwcm9wcywgXG4gICAgLy8vIFRoZSBpZCBvZiB0aGlzIG5vZGUgaW4gaXRzIHNldC4gQ29ycmVzcG9uZHMgdG8gdGhlIHRlcm0gaWRzXG4gICAgLy8vIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICBpZCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIFRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBFcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBBbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpXG4gICAgICAgICAgICAgICAgICAgIHNyY1swXS5zZXQocHJvcHMsIHNyY1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICAvLy8gUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgLy8vIHRoZSBwcm9wIGlzbid0IHByZXNlbnQgb24gdGhpcyBub2RlLlxuICAgIHByb3AocHJvcCkgeyByZXR1cm4gdGhpcy5wcm9wc1twcm9wLmlkXTsgfVxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgIGdldCBpc1RvcCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBUb3AgKi8pID4gMDsgfVxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIHByb2R1Y2VkIGJ5IGEgc2tpcCBydWxlLlxuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLy8vIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYW4gZXJyb3Igbm9kZS5cbiAgICBnZXQgaXNFcnJvcigpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgNCAvKiBFcnJvciAqLykgPiAwOyB9XG4gICAgLy8vIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIC8vLyBuYW1lZCBub2RlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGlzIHVzZWQgdG8gY2FjaGUgcmVwZXRpdGlvbi5cbiAgICBnZXQgaXNBbm9ueW1vdXMoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDggLyogQW5vbnltb3VzICovKSA+IDA7IH1cbiAgICAvLy8gUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgLy8vIFtncm91cHNdKCN0cmVlLk5vZGVQcm9wXmdyb3VwKSBtYXRjaGVzIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcbiAgICAvLy8gc3BlY2lmeWluZyBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydHkgbmFtZXMgYXJlIG5vZGUgb3JcbiAgICAvLy8gW2dyb3VwXSgjdHJlZS5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI3RyZWUuTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICAvLy8gbmFtZXMsIHNlcGFyYXRlZCBieSBzcGFjZXMsIGluIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUgdG8gbWFwXG4gICAgLy8vIG11bHRpcGxlIG5vZGUgbmFtZXMgdG8gYSBzaW5nbGUgdmFsdWUuXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBBbiBlbXB0eSBkdW1teSBub2RlIHR5cGUgdG8gdXNlIHdoZW4gbm8gYWN0dWFsIHR5cGUgaXMgYXZhaWxhYmxlLlxuTm9kZVR5cGUubm9uZSA9IG5ldyBOb2RlVHlwZShcIlwiLCBPYmplY3QuY3JlYXRlKG51bGwpLCAwLCA4IC8qIEFub255bW91cyAqLyk7XG4vLy8gQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuLy8vIGNvbXBhY3RseSByZXByZXNlbnQgdHJlZXMgYnkgc3RvcmluZyB0aGVpciB0eXBlIGlkcywgcmF0aGVyIHRoYW4gYVxuLy8vIGZ1bGwgcG9pbnRlciB0byB0aGUgdHlwZSBvYmplY3QsIGluIGEgbnVtYmVyIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsZXplci5QYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG4vLy8gYnVmZmVyc10oI3RyZWUuVHJlZUJ1ZmZlcikgY2FuIG9ubHkgc3RvcmUgY29sbGVjdGlvbnMgb2Ygbm9kZXNcbi8vLyBmcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNilcbi8vLyBub2RlIHR5cGVzIGluIGl0LCBzbyB0aGF0IHRoZSBpZHMgZml0IGludG8gMTYtYml0IHR5cGVkIGFycmF5XG4vLy8gc2xvdHMuXG5jbGFzcyBOb2RlU2V0IHtcbiAgICAvLy8gQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgLy8vIHR5cGUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICB0eXBlcykge1xuICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uaWQgIT0gaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBpZHMgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYXJyYXkgcG9zaXRpb25zIHdoZW4gY3JlYXRpbmcgYSBub2RlIHNldFwiKTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBzZXQgd2l0aCBzb21lIG5vZGUgcHJvcGVydGllcyBhZGRlZC4gVGhlXG4gICAgLy8vIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY3JlYXRlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI3RyZWUuTm9kZVByb3AuYWRkKS5cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkWzBdLnNldChuZXdQcm9wcywgYWRkWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgYFRyZWVDdXJzb3JgIGludGVyZmFjZSBpbnN0ZWFkLCB3aGljaCBwcm92aWRlcyBhIHZpZXcgb25cbi8vLyBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvIG1vdmUgYXJvdW5kXG4vLy8gdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlIHtcbiAgICAvLy8gQ29uc3RydWN0IGEgbmV3IHRyZWUuIFlvdSB1c3VhbGx5IHdhbnQgdG8gZ28gdGhyb3VnaFxuICAgIC8vLyBbYFRyZWUuYnVpbGRgXSgjdHJlZS5UcmVlXmJ1aWxkKSBpbnN0ZWFkLlxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIFxuICAgIC8vLyBUaGUgdHJlZSdzIGNoaWxkIG5vZGVzLiBDaGlsZHJlbiBzbWFsbCBlbm91Z2ggdG8gZml0IGluIGFcbiAgICAvLy8gYFRyZWVCdWZmZXIgd2lsbCBiZSByZXByZXNlbnRlZCBhcyBzdWNoLCBvdGhlciBjaGlsZHJlbiBjYW4gYmVcbiAgICAvLy8gZnVydGhlciBgVHJlZWAgaW5zdGFuY2VzIHdpdGggdGhlaXIgb3duIGludGVybmFsIHN0cnVjdHVyZS5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ubWFwKGMgPT4gYy50b1N0cmluZygpKS5qb2luKCk7XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCN0cmVlLlRyZWVDdXJzb3IpIHJvb3RlZCBhdCB0aGlzIHRyZWUuIFdoZW5cbiAgICAvLy8gYHBvc2AgaXMgZ2l2ZW4sIHRoZSBjdXJzb3IgaXMgW21vdmVkXSgjdHJlZS5UcmVlQ3Vyc29yLm1vdmVUbylcbiAgICAvLy8gdG8gdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlLlxuICAgIGN1cnNvcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IChwb3MgIT0gbnVsbCAmJiBDYWNoZWROb2RlLmdldCh0aGlzKSkgfHwgdGhpcy50b3BOb2RlO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3Ioc2NvcGUpO1xuICAgICAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIGN1cnNvci5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLy8vIEdldCBhIFt0cmVlIGN1cnNvcl0oI3RyZWUuVHJlZUN1cnNvcikgdGhhdCwgdW5saWtlIHJlZ3VsYXJcbiAgICAvLy8gY3Vyc29ycywgZG9lc24ndCBza2lwIFthbm9ueW1vdXNdKCN0cmVlLk5vZGVUeXBlLmlzQW5vbnltb3VzKVxuICAgIC8vLyBub2Rlcy5cbiAgICBmdWxsQ3Vyc29yKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcy50b3BOb2RlLCB0cnVlKTtcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI3RyZWUuU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIC8vLyB0cmVlLlxuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbc3ludGF4IG5vZGVdKCN0cmVlLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAvLy8gSWYgYHNpZGVgIGlzIC0xLCB0aGlzIHdpbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgZW5kIGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgICAvLy8gZnJvbSBib3RoIHNpZGVzLlxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IocG9zLCBzaWRlKS5ub2RlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgLy8vIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICAvLy8gcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vLyB3aWxsIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgaXRlcmF0ZShzcGVjKSB7XG4gICAgICAgIGxldCB7IGVudGVyLCBsZWF2ZSwgZnJvbSA9IDAsIHRvID0gdGhpcy5sZW5ndGggfSA9IHNwZWM7XG4gICAgICAgIGZvciAobGV0IGMgPSB0aGlzLmN1cnNvcigpOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjLmZyb20gPD0gdG8gJiYgYy50byA+PSBmcm9tICYmIChjLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIoYy50eXBlLCBjLmZyb20sIGMudG8pICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICghYy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGMudHlwZSwgYy5mcm9tLCBjLnRvKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSBjLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKGMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZS5cbiAgICBiYWxhbmNlKG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IEJhbGFuY2VCcmFuY2hGYWN0b3IgPyB0aGlzXG4gICAgICAgICAgICA6IGJhbGFuY2VSYW5nZSh0aGlzLnR5cGUsIE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgbWF4QnVmZmVyTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vLyBCdWlsZCBhIHRyZWUgZnJvbSBhIHBvc3RmaXgtb3JkZXJlZCBidWZmZXIgb2Ygbm9kZSBpbmZvcm1hdGlvbixcbiAgICAvLy8gb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8vLyBUaGUgZW1wdHkgdHJlZVxuVHJlZS5lbXB0eSA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgMCk7XG4vLy8gVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxuLy8vIG5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXG4vLy8gYmVmb3JlIGNoaWxkcmVuLCB3aXRoIHRoZSBlbmRJbmRleCBvZiB0aGUgcGFyZW50IGluZGljYXRpbmcgd2hpY2hcbi8vLyBjaGlsZHJlbiBiZWxvbmcgdG8gaXQpXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdHJlZSBidWZmZXIgQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJ1ZmZlciwgXG4gICAgLy8gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZ3JvdXAgb2Ygbm9kZXMgaW4gdGhlIGJ1ZmZlci5cbiAgICBsZW5ndGgsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzZXQsIHR5cGUgPSBOb2RlVHlwZS5ub25lKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjaGlsZFN0cmluZyhpbmRleCkge1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmJ1ZmZlcltpbmRleF0sIGVuZEluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnNldC50eXBlc1tpZF0sIHJlc3VsdCA9IHR5cGUubmFtZTtcbiAgICAgICAgaWYgKC9cXFcvLnRlc3QocmVzdWx0KSAmJiAhdHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgaWYgKGVuZEluZGV4ID09IGluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgXCIoXCIgKyBjaGlsZHJlbi5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZmluZENoaWxkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBkaXIsIGFmdGVyKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChhZnRlciAhPSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBidWZmZXJbaSArIDFdLCBlbmQgPSBidWZmZXJbaSArIDJdO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPj0gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2s7XG4gICAgfVxufVxuY2xhc3MgVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGZyb20sIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLm5vZGUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGUubmFtZTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMubm9kZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBhZnRlciwgZnVsbCA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXM7Oykge1xuICAgICAgICAgICAgZm9yIChsZXQgeyBjaGlsZHJlbiwgcG9zaXRpb25zIH0gPSBwYXJlbnQubm9kZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyICE9IC0xMDAwMDAwMDAgLyogTm9uZSAqLyAmJiAoZGlyIDwgMCA/IHN0YXJ0ID49IGFmdGVyIDogc3RhcnQgKyBuZXh0Lmxlbmd0aCA8PSBhZnRlcikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgYWZ0ZXIgPT0gLTEwMDAwMDAwMCAvKiBOb25lICovID8gLTEwMDAwMDAwMCAvKiBOb25lICovIDogYWZ0ZXIgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZ1bGwgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGwgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lciA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBhZnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bGwgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaSA9IHBhcmVudC5pbmRleCArIGRpcjtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MpOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIHBvcyk7IH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCArIDEsIDEsIC0xKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAtMSkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpLm5vZGU7XG4gICAgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5ub2RlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IsIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjaGlsZChkaXIsIGFmdGVyKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBhZnRlciA9PSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gPyAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gOiBhZnRlciAtIHRoaXMuY29udGV4dC5zdGFydCk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MpOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCBwb3MpOyB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIC0xKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKSk7XG4gICAgfVxuICAgIGdldCBjdXJzb3IoKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzKTsgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IubW92ZVRvKHBvcywgc2lkZSkubm9kZTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG59XG4vLy8gQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG4vLy8gYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGZ1bGwgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZ1bGwgPSBmdWxsO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBub2RlLl9wYXJlbnQ7IG47IG4gPSBuLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlcihkaXIsIGFmdGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIGFmdGVyLCB0aGlzLmZ1bGwpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgYWZ0ZXIgPT0gLTEwMDAwMDAwMCAvKiBOb25lICovID8gLTEwMDAwMDAwMCAvKiBOb25lICovIDogYWZ0ZXIgLSB0aGlzLmJ1ZmZlci5zdGFydCk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIC8vLyBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXIoMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgbGFzdCBjaGlsZC5cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyKC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgZmlyc3QgY2hpbGQgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXIoMSwgcG9zKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgZW5kcyBhdCBvciBiZWZvcmUgYHBvc2AuXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmVudGVyKC0xLCBwb3MpOyB9XG4gICAgLy8vIE1vdmUgdGhlIG5vZGUncyBwYXJlbnQgbm9kZSwgaWYgdGhpcyBpc24ndCB0aGUgdG9wIG5vZGUuXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHRoaXMuZnVsbCA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmZ1bGwgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgLTEwMDAwMDAwMCAvKiBOb25lICovLCB0aGlzLmZ1bGwpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRTdGFydCA9IGQgPCAwID8gMCA6IHRoaXMuc3RhY2tbZF0gKyA0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggIT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPCAoZCA8IDAgPyBidWZmZXIuYnVmZmVyLmxlbmd0aCA6IGJ1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXSArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihhZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQgPCAwID8gdGhpcy55aWVsZCh0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dENoaWxkKHRoaXMuYnVmZmVyLmluZGV4ICsgZGlyLCBkaXIsIC0xMDAwMDAwMDAgLyogTm9uZSAqLywgdGhpcy5mdWxsKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5ub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1bGwgfHwgIWNoaWxkLnR5cGUuaXNBbm9ueW1vdXMgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IGhhc0NoaWxkKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpcikge1xuICAgICAgICBpZiAodGhpcy5lbnRlcihkaXIsIC0xMDAwMDAwMDAgLyogTm9uZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGFcbiAgICAvLy8gW3ByZS1vcmRlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV90cmF2ZXJzYWwjUHJlLW9yZGVyXyhOTFIpKVxuICAgIC8vLyB0cmF2ZXJzYWwsIGdvaW5nIGZyb20gYSBub2RlIHRvIGl0cyBmaXJzdCBjaGlsZCBvciwgaWYgdGhlXG4gICAgLy8vIGN1cnJlbnQgbm9kZSBpcyBlbXB0eSwgaXRzIG5leHQgc2libGluZyBvciB0aGUgbmV4dCBzaWJsaW5nIG9mXG4gICAgLy8vIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dCgpIHsgcmV0dXJuIHRoaXMubW92ZSgxKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYSBsYXN0LXRvLWZpcnN0IHByZS1vcmRlciB0cmF2ZXJhbC4gQVxuICAgIC8vLyBub2RlIGlzIGZvbGxvd2VkIGJ5IGlzdCBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXG4gICAgLy8vIHByZXZpb3VzIHNpYmxpbmcgb3IgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudFxuICAgIC8vLyBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICBwcmV2KCkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIC8vLyBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgLy8vIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBzdGFydCBhdCBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/ICF0aGlzLmNoaWxkQmVmb3JlKHBvcykgOiAhdGhpcy5jaGlsZEFmdGVyKHBvcykpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI3RyZWUuU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjdHJlZS5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICAvLy8gYW55LiBXaWxsIHJldHVybiBudWxsIHdoZW4gdGhlIG5vZGUgaXMgaW4gYSBbdHJlZVxuICAgIC8vLyBidWZmZXJdKCN0cmVlLlRyZWVCdWZmZXIpLlxuICAgIGdldCB0cmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyBudWxsIDogdGhpcy5fdHJlZS5ub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NoaWxkKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5zb21lKGNoID0+ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGNoIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBoYXNDaGlsZChjaCkpO1xufVxuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbmNvbnN0IEJhbGFuY2VCcmFuY2hGYWN0b3IgPSA4O1xuZnVuY3Rpb24gYnVpbGRUcmVlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgYnVmZmVyLCBub2RlU2V0LCB0b3BJRCA9IDAsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBmdW5jdGlvbiB0YWtlTm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpblJlcGVhdCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICB3aGlsZSAoaWQgPT0gaW5SZXBlYXQpIHtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAoeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRQb3MgPSBzdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICBpZiAoc2l6ZSA8IDApIHsgLy8gUmV1c2VkIG5vZGVcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gocmV1c2VkW2lkXSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4LCBpblJlcGVhdCk7XG4gICAgICAgICAgICBub2RlID0gbmV3IFRyZWVCdWZmZXIoZGF0YSwgZW5kIC0gYnVmZmVyLnN0YXJ0LCBub2RlU2V0LCBpblJlcGVhdCA8IDAgPyBOb2RlVHlwZS5ub25lIDogdHlwZXNbaW5SZXBlYXRdKTtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gYnVmZmVyLnN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1ha2UgaXQgYSBub2RlXG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIHNpemU7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBsb2NhbEluUmVwZWF0ID0gaWQgPj0gbWluUmVwZWF0VHlwZSA/IGlkIDogLTE7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCk7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID4gLTEgJiYgbG9jYWxDaGlsZHJlbi5sZW5ndGggPiBCYWxhbmNlQnJhbmNoRmFjdG9yKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBiYWxhbmNlUmFuZ2UodHlwZSwgdHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIDAsIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoLCAwLCBtYXhCdWZmZXJMZW5ndGgsIGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IFRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBmb3JrLnNpemUsIHN0YXJ0UG9zID0gZm9yay5wb3MgLSBub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChub2RlU2l6ZSA8IDAgfHwgc3RhcnRQb3MgPCBtaW5Qb3MgfHwgZm9yay5zdGFydCA8IG1pblN0YXJ0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGxvY2FsU2tpcHBlZCA9IGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSA/IDQgOiAwO1xuICAgICAgICAgICAgbGV0IG5vZGVTdGFydCA9IGZvcmsuc3RhcnQ7XG4gICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChmb3JrLnBvcyA+IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4LCBpblJlcGVhdCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoaWQgPT0gaW5SZXBlYXQpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgsIGluUmVwZWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQgPCBtaW5SZXBlYXRUeXBlKSB7IC8vIERvbid0IGNvcHkgcmVwZWF0IG5vZGVzIGludG8gYnVmZmVyc1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCAwLCBjaGlsZHJlbiwgcG9zaXRpb25zLCAtMSk7XG4gICAgbGV0IGxlbmd0aCA9IChfYSA9IGRhdGEubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY2hpbGRyZW4ubGVuZ3RoID8gcG9zaXRpb25zWzBdICsgY2hpbGRyZW5bMF0ubGVuZ3RoIDogMCk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW3RvcElEXSwgY2hpbGRyZW4ucmV2ZXJzZSgpLCBwb3NpdGlvbnMucmV2ZXJzZSgpLCBsZW5ndGgpO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKG91dGVyVHlwZSwgaW5uZXJUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgc3RhcnQsIG1heEJ1ZmZlckxlbmd0aCwgbGVuZ3RoKSB7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBpZiAobGVuZ3RoIDw9IG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uc1tpXSAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IG1heENoaWxkID0gTWF0aC5tYXgobWF4QnVmZmVyTGVuZ3RoLCBNYXRoLmNlaWwobGVuZ3RoICogMS41IC8gQmFsYW5jZUJyYW5jaEZhY3RvcikpO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dEVuZCA9IHBvc2l0aW9uc1tpXSArIGNoaWxkcmVuW2ldLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEVuZCAtIGdyb3VwU3RhcnQgPiBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9ubHkgPSBjaGlsZHJlbltncm91cEZyb21dO1xuICAgICAgICAgICAgICAgIGlmIChvbmx5IGluc3RhbmNlb2YgVHJlZSAmJiBvbmx5LnR5cGUgPT0gaW5uZXJUeXBlICYmIG9ubHkubGVuZ3RoID4gbWF4Q2hpbGQgPDwgMSkgeyAvLyBUb28gYmlnLCBjb2xsYXBzZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9ubHkuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChvbmx5LmNoaWxkcmVuW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gob25seS5wb3NpdGlvbnNbal0gKyBncm91cFN0YXJ0IC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2gob25seSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IGdyb3VwRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBiYWxhbmNlUmFuZ2UoaW5uZXJUeXBlLCBpbm5lclR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbWF4QnVmZmVyTGVuZ3RoLCBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lclR5cGUgIT0gTm9kZVR5cGUubm9uZSAmJiAhY29udGFpbnNUeXBlKGlubmVyLmNoaWxkcmVuLCBpbm5lclR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBpbm5lciA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGlubmVyLmNoaWxkcmVuLCBpbm5lci5wb3NpdGlvbnMsIGlubmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGlubmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyZWUob3V0ZXJUeXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zVHlwZShub2RlcywgdHlwZSkge1xuICAgIGZvciAobGV0IGVsdCBvZiBub2RlcylcbiAgICAgICAgaWYgKGVsdC50eXBlID09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLy8gVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxuLy8vIHBhcnNpbmddKCNsZXplci5QYXJzZU9wdGlvbnMuZnJhZ21lbnRzKSB0byB0cmFjayBwYXJ0cyBvZiBvbGRcbi8vLyB0cmVlcyB0aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpc1xuLy8vIHVzZWQgdG8gdHJhY2sgcmVnaW9ucyBvZiBhbiBvbGQgdHJlZSB3aG9zZSBub2RlcyBtaWdodCBiZSByZXVzZWRcbi8vLyBpbiBuZXcgcGFyc2VzLiBVc2UgdGhlIHN0YXRpY1xuLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI3RyZWUuVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgbWV0aG9kIHRvIHVwZGF0ZVxuLy8vIGZyYWdtZW50cyBmb3IgZG9jdW1lbnQgY2hhbmdlcy5cbmNsYXNzIFRyZWVGcmFnbWVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBzdGFydCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlIHBvaW50ZWQgdG8gYnkgdGhpcyBmcmFnbWVudC5cbiAgICAvLy8gVGhpcyByZWZlcnMgdG8gYW4gb2Zmc2V0IGluIHRoZSBfdXBkYXRlZF8gZG9jdW1lbnQgKGFzIG9wcG9zZWRcbiAgICAvLy8gdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgIGZyb20sIFxuICAgIC8vLyBUaGUgZW5kIG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UuXG4gICAgdG8sIFxuICAgIC8vLyBUaGUgdHJlZSB0aGF0IHRoaXMgZnJhZ21lbnQgaXMgYmFzZWQgb24uXG4gICAgdHJlZSwgXG4gICAgLy8vIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIC8vLyB0aGlzIGZyYWdtZW50IGNhbiBiZSB1c2VkIGFnYWluc3QuIEFkZCB0aGlzIHdoZW4gZ29pbmcgZnJvbVxuICAgIC8vLyBkb2N1bWVudCB0byB0cmVlIHBvc2l0aW9ucywgc3VidHJhY3QgaXQgdG8gZ28gZnJvbSB0cmVlIHRvXG4gICAgLy8vIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICBvZmZzZXQsIG9wZW4pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgZ2V0IG9wZW5TdGFydCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAxIC8qIFN0YXJ0ICovKSA+IDA7IH1cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIEVuZCAqLykgPiAwOyB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBsZXQgY0kgPSAwLCBwb3MgPSAwLCBvZmYgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSSsrXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRyZWVGcmFnbWVudChmRnJvbSwgZlRvLCBjdXQudHJlZSwgY3V0Lm9mZnNldCArIG9mZiwgKGNJID4gMCA/IDEgLyogU3RhcnQgKi8gOiAwKSB8IChuZXh0QyA/IDIgLyogRW5kICovIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBzZXQgb2YgZnJhZ21lbnRzIGZyb20gYSBmcmVzaGx5IHBhcnNlZCB0cmVlLCBvciB1cGRhdGVcbiAgICAvLy8gYW4gZXhpc3Rpbmcgc2V0IG9mIGZyYWdtZW50cyBieSByZXBsYWNpbmcgdGhlIG9uZXMgdGhhdCBvdmVybGFwXG4gICAgLy8vIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICAvLy8gdHJ1ZSwgdGhlIHBhcnNlIGlzIHRyZWF0ZWQgYXMgaW5jb21wbGV0ZSwgYW5kIHRoZSB0b2tlbiBhdCBpdHNcbiAgICAvLy8gZW5kIGlzIG5vdCBpbmNsdWRlZCBpbiBbYHNhZmVUb2BdKCN0cmVlLlRyZWVGcmFnbWVudC5zYWZlVG8pLlxuICAgIHN0YXRpYyBhZGRUcmVlKHRyZWUsIGZyYWdtZW50cyA9IFtdLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtuZXcgVHJlZUZyYWdtZW50KDAsIHRyZWUubGVuZ3RoLCB0cmVlLCAwLCBwYXJ0aWFsID8gMiAvKiBFbmQgKi8gOiAwKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyBDcmVhdGVzIGFuIGBJbnB1dGAgdGhhdCBpcyBiYWNrZWQgYnkgYSBzaW5nbGUsIGZsYXQgc3RyaW5nLlxuZnVuY3Rpb24gc3RyaW5nSW5wdXQoaW5wdXQpIHsgcmV0dXJuIG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7IH1cbmNsYXNzIFN0cmluZ0lucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPCAwIHx8IHBvcyA+PSB0aGlzLmxlbmd0aCA/IC0xIDogdGhpcy5zdHJpbmcuY2hhckNvZGVBdChwb3MpO1xuICAgIH1cbiAgICBsaW5lQWZ0ZXIocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLnN0cmluZy5pbmRleE9mKFwiXFxuXCIsIHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShwb3MsIGVuZCA8IDAgPyB0aGlzLmxlbmd0aCA6IE1hdGgubWluKGVuZCwgdGhpcy5sZW5ndGgpKTtcbiAgICB9XG4gICAgcmVhZChmcm9tLCB0bykgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSk7IH1cbiAgICBjbGlwKGF0KSB7IHJldHVybiBuZXcgU3RyaW5nSW5wdXQodGhpcy5zdHJpbmcsIGF0KTsgfVxufVxuXG5leHBvcnRzLkRlZmF1bHRCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoO1xuZXhwb3J0cy5Ob2RlUHJvcCA9IE5vZGVQcm9wO1xuZXhwb3J0cy5Ob2RlU2V0ID0gTm9kZVNldDtcbmV4cG9ydHMuTm9kZVR5cGUgPSBOb2RlVHlwZTtcbmV4cG9ydHMuVHJlZSA9IFRyZWU7XG5leHBvcnRzLlRyZWVCdWZmZXIgPSBUcmVlQnVmZmVyO1xuZXhwb3J0cy5UcmVlQ3Vyc29yID0gVHJlZUN1cnNvcjtcbmV4cG9ydHMuVHJlZUZyYWdtZW50ID0gVHJlZUZyYWdtZW50O1xuZXhwb3J0cy5zdHJpbmdJbnB1dCA9IHN0cmluZ0lucHV0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJlZS5janMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBsZXplclRyZWUgPSByZXF1aXJlKCdsZXplci10cmVlJyk7XG5cbi8vLyBBIHBhcnNlIHN0YWNrLiBUaGVzZSBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwYXJzZXIgdG8gdHJhY2tcbi8vLyBwYXJzaW5nIHByb2dyZXNzLiBUaGV5IGFsc28gcHJvdmlkZSBzb21lIHByb3BlcnRpZXMgYW5kIG1ldGhvZHNcbi8vLyB0aGF0IGV4dGVybmFsIGNvZGUgc3VjaCBhcyBhIHRva2VuaXplciBjYW4gdXNlIHRvIGdldCBpbmZvcm1hdGlvblxuLy8vIGFib3V0IHRoZSBwYXJzZSBzdGF0ZS5cbmNsYXNzIFN0YWNrIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEEgZ3JvdXAgb2YgdmFsdWVzIHRoYXQgdGhlIHN0YWNrIHdpbGwgc2hhcmUgd2l0aCBhbGxcbiAgICAvLy8gc3BsaXQgaW5zdGFuY2VzXG4gICAgLy8vQGludGVybmFsXG4gICAgY3gsIFxuICAgIC8vLyBIb2xkcyBzdGF0ZSwgcG9zLCB2YWx1ZSBzdGFjayBwb3MgKDE1IGJpdHMgYXJyYXkgaW5kZXgsIDE1IGJpdHNcbiAgICAvLy8gYnVmZmVyIGluZGV4KSB0cmlwbGV0cyBmb3IgYWxsIGJ1dCB0aGUgdG9wIHN0YXRlXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YWNrLCBcbiAgICAvLy8gVGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUgQGludGVybmFsXG4gICAgc3RhdGUsIFxuICAgIC8vIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgbmV4dCByZWR1Y2Ugc2hvdWxkIHRha2UgcGxhY2UuIFRoaXNcbiAgICAvLyBjYW4gYmUgbGVzcyB0aGFuIGB0aGlzLnBvc2Agd2hlbiBza2lwcGVkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIGFkZGVkIHRvIHRoZSBzdGFjayAod2hpY2ggc2hvdWxkIGJlIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5leHRcbiAgICAvLyByZWR1Y3Rpb24pXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZVBvcywgXG4gICAgLy8vIFRoZSBpbnB1dCBwb3NpdGlvbiB1cCB0byB3aGljaCB0aGlzIHN0YWNrIGhhcyBwYXJzZWQuXG4gICAgcG9zLCBcbiAgICAvLy8gVGhlIGR5bmFtaWMgc2NvcmUgb2YgdGhlIHN0YWNrLCBpbmNsdWRpbmcgZHluYW1pYyBwcmVjZWRlbmNlXG4gICAgLy8vIGFuZCBlcnJvci1yZWNvdmVyeSBwZW5hbHRpZXNcbiAgICAvLy8gQGludGVybmFsXG4gICAgc2NvcmUsIFxuICAgIC8vIFRoZSBvdXRwdXQgYnVmZmVyLiBIb2xkcyAodHlwZSwgc3RhcnQsIGVuZCwgc2l6ZSkgcXVhZHNcbiAgICAvLyByZXByZXNlbnRpbmcgbm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyLCB3aGVyZSBgc2l6ZWAgaXNcbiAgICAvLyBhbW91bnQgb2YgYnVmZmVyIGFycmF5IGVudHJpZXMgY292ZXJlZCBieSB0aGlzIG5vZGUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJ1ZmZlciwgXG4gICAgLy8gVGhlIGJhc2Ugb2Zmc2V0IG9mIHRoZSBidWZmZXIuIFdoZW4gc3RhY2tzIGFyZSBzcGxpdCwgdGhlIHNwbGl0XG4gICAgLy8gaW5zdGFuY2Ugc2hhcmVkIHRoZSBidWZmZXIgaGlzdG9yeSB3aXRoIGl0cyBwYXJlbnQgdXAgdG9cbiAgICAvLyBgYnVmZmVyQmFzZWAsIHdoaWNoIGlzIHRoZSBhYnNvbHV0ZSBvZmZzZXQgKGluY2x1ZGluZyB0aGVcbiAgICAvLyBvZmZzZXQgb2YgcHJldmlvdXMgc3BsaXRzKSBpbnRvIHRoZSBidWZmZXIgYXQgd2hpY2ggdGhpcyBzdGFja1xuICAgIC8vIHN0YXJ0cyB3cml0aW5nLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXJCYXNlLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcmVudCkge1xuICAgICAgICB0aGlzLmN4ID0gY3g7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHJlZHVjZVBvcztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuYnVmZmVyQmFzZSA9IGJ1ZmZlckJhc2U7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5zdGFjay5maWx0ZXIoKF8sIGkpID0+IGkgJSAzID09IDApLmNvbmNhdCh0aGlzLnN0YXRlKX1dQCR7dGhpcy5wb3N9JHt0aGlzLnNjb3JlID8gXCIhXCIgKyB0aGlzLnNjb3JlIDogXCJcIn1gO1xuICAgIH1cbiAgICAvLyBTdGFydCBhbiBlbXB0eSBzdGFja1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0aWMgc3RhcnQoY3gsIHN0YXRlLCBwb3MgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2soY3gsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8gUHVzaCBhIHN0YXRlIG9udG8gdGhlIHN0YWNrLCB0cmFja2luZyBpdHMgc3RhcnQgcG9zaXRpb24gYXMgd2VsbFxuICAgIC8vIGFzIHRoZSBidWZmZXIgYmFzZSBhdCB0aGF0IHBvaW50LlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwdXNoU3RhdGUoc3RhdGUsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCBzdGFydCwgdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvLyBBcHBseSBhIHJlZHVjZSBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLywgdHlwZSA9IGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLmN4O1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAvLyBaZXJvLWRlcHRoIHJlZHVjdGlvbnMgYXJlIGEgc3BlY2lhbCBjYXNl4oCUdGhleSBhZGQgc3R1ZmYgdG9cbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IHBvcHBpbmcgYW55dGhpbmcgb2ZmLlxuICAgICAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUocGFyc2VyLmdldEdvdG8odGhpcy5zdGF0ZSwgdHlwZSwgdHJ1ZSksIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBiYXNlIGluZGV4IGludG8gYHRoaXMuc3RhY2tgLCBjb250ZW50IGFmdGVyIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgZHJvcHBlZC4gTm90ZSB0aGF0IHdpdGggYFN0YXlGbGFnYCByZWR1Y3Rpb25zIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY29uc3VtZSB0d28gZXh0cmEgZnJhbWVzICh0aGUgZHVtbXkgcGFyZW50IG5vZGUgZm9yIHRoZSBza2lwcGVkXG4gICAgICAgIC8vIGV4cHJlc3Npb24gYW5kIHRoZSBzdGF0ZSB0aGF0IHdlJ2xsIGJlIHN0YXlpbmcgaW4sIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBiZSBtb3ZlZCB0byBgdGhpcy5zdGF0ZWApLlxuICAgICAgICBsZXQgYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoIC0gKChkZXB0aCAtIDEpICogMykgLSAoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovID8gNiA6IDApO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAyXTtcbiAgICAgICAgbGV0IGJ1ZmZlckJhc2UgPSB0aGlzLnN0YWNrW2Jhc2UgLSAxXSwgY291bnQgPSB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGggLSBidWZmZXJCYXNlO1xuICAgICAgICAvLyBTdG9yZSBub3JtYWwgdGVybXMgb3IgYFIgLT4gUiBSYCByZXBlYXQgcmVkdWN0aW9uc1xuICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtIHx8IChhY3Rpb24gJiAxMzEwNzIgLyogUmVwZWF0RmxhZyAqLykpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDEgLyogU2tpcHBlZCAqLykgPyB0aGlzLnBvcyA6IHRoaXMucmVkdWNlUG9zO1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgc3RhcnQsIHBvcywgY291bnQgKyA0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiYXNlU3RhdGVJRCA9IHRoaXMuc3RhY2tbYmFzZSAtIDNdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHBhcnNlci5nZXRHb3RvKGJhc2VTdGF0ZUlELCB0eXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBiYXNlKVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICB9XG4gICAgLy8gU2hpZnQgYSB2YWx1ZSBpbnRvIHRoZSBidWZmZXJcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBpc1JlZHVjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogRXJyICovKSB7IC8vIFRyeSB0byBvbWl0L21lcmdlIGFkamFjZW50IGVycm9yIG5vZGVzXG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcywgdG9wID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvcCA9PSAwICYmIGN1ci5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBjdXIuYnVmZmVyQmFzZSAtIGN1ci5wYXJlbnQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCA+IDAgJiYgY3VyLmJ1ZmZlclt0b3AgLSA0XSA9PSAwIC8qIEVyciAqLyAmJiBjdXIuYnVmZmVyW3RvcCAtIDFdID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5idWZmZXJbdG9wIC0gMl0gPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLmJ1ZmZlclt0b3AgLSAyXSA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVkdWNlIHx8IHRoaXMucG9zID09IGVuZCkgeyAvLyBTaW1wbGUgY2FzZSwganVzdCBhcHBlbmRcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGVybSwgc3RhcnQsIGVuZCwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFRoZXJlIG1heSBiZSBza2lwcGVkIG5vZGVzIHRoYXQgaGF2ZSB0byBiZSBtb3ZlZCBmb3J3YXJkXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gNF0gIT0gMCAvKiBFcnIgKi8pXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhpcyByZWNvcmQgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gdGhpcy5idWZmZXJbaW5kZXggLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGVybTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhIHNoaWZ0IGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDEzMTA3MiAvKiBHb3RvRmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykgPT0gMCkgeyAvLyBSZWd1bGFyIHNoaWZ0XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcywgbmV4dFN0YXRlID0gYWN0aW9uLCB7IHBhcnNlciB9ID0gdGhpcy5jeDtcbiAgICAgICAgICAgIGlmIChuZXh0RW5kID4gdGhpcy5wb3MgfHwgbmV4dCA8PSBwYXJzZXIubWF4Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci5zdGF0ZUZsYWcobmV4dFN0YXRlLCAxIC8qIFNraXBwZWQgKi8pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0U3RhdGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChuZXh0IDw9IHBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobmV4dCwgc3RhcnQsIG5leHRFbmQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBTaGlmdC1hbmQtc3RheSwgd2hpY2ggbWVhbnMgdGhpcyBpcyBhIHNraXBwZWQgdG9rZW5cbiAgICAgICAgICAgIGlmIChuZXh0IDw9IHRoaXMuY3gucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCB0aGlzLnBvcywgbmV4dEVuZCwgNCk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLylcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgbm9kZSBpbnRvIHRoZSBidWZmZXIuIFRoaXMgbWF5IGJlIGEgcmV1c2VkIG5vZGUgb3JcbiAgICAvLyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgYSBuZXN0ZWQgcGFyc2VyLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB1c2VOb2RlKHZhbHVlLCBuZXh0KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuY3gucmV1c2VkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5jeC5yZXVzZWRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmN4LnJldXNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3MgPSBzdGFydCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dCwgc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGluZGV4LCBzdGFydCwgdGhpcy5yZWR1Y2VQb3MsIC0xIC8qIHNpemUgPCAwIG1lYW5zIHRoaXMgaXMgYSByZXVzZWQgdmFsdWUgKi8pO1xuICAgIH1cbiAgICAvLyBTcGxpdCB0aGUgc3RhY2suIER1ZSB0byB0aGUgYnVmZmVyIHNoYXJpbmcgYW5kIHRoZSBmYWN0XG4gICAgLy8gdGhhdCBgdGhpcy5zdGFja2AgdGVuZHMgdG8gc3RheSBxdWl0ZSBzaGFsbG93LCB0aGlzIGlzbid0IHZlcnlcbiAgICAvLyBleHBlbnNpdmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgbGV0IG9mZiA9IHBhcmVudC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSB0b3Agb2YgdGhlIGJ1ZmZlciAoYWZ0ZXIgdGhpcy5wb3MpIG1heSBiZSBtdXRhdGVkXG4gICAgICAgIC8vIHRvIHJlb3JkZXIgcmVkdWN0aW9ucyBhbmQgc2tpcHBlZCB0b2tlbnMsIGFuZCBzaGFyZWQgYnVmZmVyc1xuICAgICAgICAvLyBzaG91bGQgYmUgaW1tdXRhYmxlLCB0aGlzIGNvcGllcyBhbnkgb3V0c3RhbmRpbmcgc2tpcHBlZCB0b2tlbnNcbiAgICAgICAgLy8gdG8gdGhlIG5ldyBidWZmZXIsIGFuZCBwdXRzIHRoZSBiYXNlIHBvaW50ZXIgYmVmb3JlIHRoZW0uXG4gICAgICAgIHdoaWxlIChvZmYgPiAwICYmIHBhcmVudC5idWZmZXJbb2ZmIC0gMl0gPiBwYXJlbnQucmVkdWNlUG9zKVxuICAgICAgICAgICAgb2ZmIC09IDQ7XG4gICAgICAgIGxldCBidWZmZXIgPSBwYXJlbnQuYnVmZmVyLnNsaWNlKG9mZiksIGJhc2UgPSBwYXJlbnQuYnVmZmVyQmFzZSArIG9mZjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHBhcmVudCBwb2ludHMgdG8gYW4gYWN0dWFsIHBhcmVudCB3aXRoIGNvbnRlbnQsIGlmIHRoZXJlIGlzIHN1Y2ggYSBwYXJlbnQuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgYmFzZSA9PSBwYXJlbnQuYnVmZmVyQmFzZSlcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2sodGhpcy5jeCwgdGhpcy5zdGFjay5zbGljZSgpLCB0aGlzLnN0YXRlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5wb3MsIHRoaXMuc2NvcmUsIGJ1ZmZlciwgYmFzZSwgcGFyZW50KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHJlY292ZXIgZnJvbSBhbiBlcnJvciBieSAnZGVsZXRpbmcnIChpZ25vcmluZykgb25lIHRva2VuLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlEZWxldGUobmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBsZXQgaXNOb2RlID0gbmV4dCA8PSB0aGlzLmN4LnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMjAwIC8qIFRva2VuICovO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhlIGdpdmVuIHRlcm0gd291bGQgYmUgYWJsZSB0byBiZSBzaGlmdGVkIChvcHRpb25hbGx5XG4gICAgLy8vIGFmdGVyIHNvbWUgcmVkdWN0aW9ucykgb24gdGhpcyBzdGFjay4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxuICAgIC8vLyBleHRlcm5hbCB0b2tlbml6ZXJzIHRoYXQgd2FudCB0byBtYWtlIHN1cmUgdGhleSBvbmx5IHByb3ZpZGUgYVxuICAgIC8vLyBnaXZlbiB0b2tlbiB3aGVuIGl0IGFwcGxpZXMuXG4gICAgY2FuU2hpZnQodGVybSkge1xuICAgICAgICBmb3IgKGxldCBzaW0gPSBuZXcgU2ltdWxhdGVkU3RhY2sodGhpcyk7Oykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMuY3gucGFyc2VyLnN0YXRlU2xvdChzaW0udG9wLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pIHx8IHRoaXMuY3gucGFyc2VyLmhhc0FjdGlvbihzaW0udG9wLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEZpbmQgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBydWxlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHBhcnNlZC5cbiAgICBnZXQgcnVsZVN0YXJ0KCkge1xuICAgICAgICBmb3IgKGxldCBzdGF0ZSA9IHRoaXMuc3RhdGUsIGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDs7KSB7XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmN4LnBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIDUgLyogRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgICAgIGlmICghKGZvcmNlICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBiYXNlIC09IDMgKiAoZm9yY2UgPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLyk7XG4gICAgICAgICAgICBpZiAoKGZvcmNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovKSA8IHRoaXMuY3gucGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbYmFzZSArIDFdO1xuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YWNrW2Jhc2VdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBGaW5kIHRoZSBzdGFydCBwb3NpdGlvbiBvZiBhbiBpbnN0YW5jZSBvZiBhbnkgb2YgdGhlIGdpdmVuIHRlcm1cbiAgICAvLy8gdHlwZXMsIG9yIHJldHVybiBgbnVsbGAgd2hlbiBub25lIG9mIHRoZW0gYXJlIGZvdW5kLlxuICAgIC8vL1xuICAgIC8vLyAqKk5vdGU6KiogdGhpcyBpcyBvbmx5IHJlbGlhYmxlIHdoZW4gdGhlcmUgaXMgYXQgbGVhc3Qgc29tZVxuICAgIC8vLyBzdGF0ZSB0aGF0IHVuYW1iaWd1b3VzbHkgbWF0Y2hlcyB0aGUgZ2l2ZW4gcnVsZSBvbiB0aGUgc3RhY2suXG4gICAgLy8vIEkuZS4gaWYgeW91IGhhdmUgYSBncmFtbWFyIGxpa2UgdGhpcywgd2hlcmUgdGhlIGRpZmZlcmVuY2VcbiAgICAvLy8gYmV0d2VlbiBgYWAgYW5kIGBiYCBpcyBvbmx5IGFwcGFyZW50IGF0IHRoZSB0aGlyZCB0b2tlbjpcbiAgICAvLy9cbiAgICAvLy8gICAgIGEgeyBiIHwgYyB9XG4gICAgLy8vICAgICBiIHsgXCJ4XCIgXCJ5XCIgXCJ4XCIgfVxuICAgIC8vLyAgICAgYyB7IFwieFwiIFwieVwiIFwielwiIH1cbiAgICAvLy9cbiAgICAvLy8gVGhlbiBhIHBhcnNlIHN0YXRlIGFmdGVyIGBcInhcImAgd2lsbCBub3QgcmVsaWFibHkgdGVsbCB5b3UgdGhhdFxuICAgIC8vLyBgYmAgaXMgb24gdGhlIHN0YWNrLiBZb3UgX2Nhbl8gcGFzcyBgW2IsIGNdYCB0byByZWxpYWJseSBjaGVja1xuICAgIC8vLyBmb3IgZWl0aGVyIG9mIHRob3NlIHR3byBydWxlcyAoYXNzdW1pbmcgdGhhdCBgYWAgaXNuJ3QgcGFydCBvZlxuICAgIC8vLyBzb21lIHJ1bGUgdGhhdCBpbmNsdWRlcyBvdGhlciB0aGluZ3Mgc3RhcnRpbmcgd2l0aCBgXCJ4XCJgKS5cbiAgICAvLy9cbiAgICAvLy8gV2hlbiBgYmVmb3JlYCBpcyBnaXZlbiwgdGhpcyBrZWVwcyBzY2FubmluZyB1cCB0aGUgc3RhY2sgdW50aWxcbiAgICAvLy8gaXQgZmluZHMgYSBtYXRjaCB0aGF0IHN0YXJ0cyBiZWZvcmUgdGhhdCBwb3NpdGlvbi5cbiAgICBzdGFydE9mKHR5cGVzLCBiZWZvcmUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZSwgZnJhbWUgPSB0aGlzLnN0YWNrLmxlbmd0aCwgeyBwYXJzZXIgfSA9IHRoaXMuY3g7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIDUgLyogRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IGZvcmNlID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHRlcm0gPSBmb3JjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmRleE9mKHRlcm0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IGZyYW1lIC0gKDMgKiAoZm9yY2UgPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLykpLCBwb3MgPSB0aGlzLnN0YWNrW2Jhc2UgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlID09IG51bGwgfHwgYmVmb3JlID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyYW1lID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGZyYW1lIC09IDM7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YWNrW2ZyYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYW1lIC09IDMgKiAoZGVwdGggLSAxKTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbZnJhbWUgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIE1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5jeC5wYXJzZXIubmV4dFN0YXRlcyh0aGlzLnN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRTdGF0ZXMubGVuZ3RoID4gNCAvKiBNYXhOZXh0ICovIHx8IHRoaXMuc3RhY2subGVuZ3RoID49IDEyMCAvKiBEYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKSB7XG4gICAgICAgICAgICBsZXQgYmVzdCA9IG5leHRTdGF0ZXMuZmlsdGVyKHMgPT4gcyAhPSB0aGlzLnN0YXRlICYmIHRoaXMuY3gucGFyc2VyLmhhc0FjdGlvbihzLCBuZXh0KSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi8gJiYgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0LmluZGV4T2YobmV4dFN0YXRlc1tpXSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0pO1xuICAgICAgICAgICAgbmV4dFN0YXRlcyA9IGJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi87IGkrKykge1xuICAgICAgICAgICAgaWYgKG5leHRTdGF0ZXNbaV0gPT0gdGhpcy5zdGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIHN0YWNrLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgc3RhY2sucG9zLCBzdGFjay5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgc3RhY2sucHVzaFN0YXRlKG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnNjb3JlIC09IDIwMCAvKiBUb2tlbiAqLztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGb3JjZSBhIHJlZHVjZSwgaWYgcG9zc2libGUuIFJldHVybiBmYWxzZSBpZiB0aGF0IGNhbid0XG4gICAgLy8gYmUgZG9uZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VSZWR1Y2UoKSB7XG4gICAgICAgIGxldCByZWR1Y2UgPSB0aGlzLmN4LnBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNSAvKiBGb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5jeC5wYXJzZXIudmFsaWRBY3Rpb24odGhpcy5zdGF0ZSwgcmVkdWNlKSkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjb3JlIC09IDEwMCAvKiBSZWR1Y2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWR1Y2UocmVkdWNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmb3JjZUFsbCgpIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmN4LnBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pICYmIHRoaXMuZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICAvLy8gdG9wIHN0YXRlLCBzaW5jZSBhbnkgb3RoZXIgc3RhdGVzIG11c3QgYmUgYWJsZSB0byBjb250aW51ZVxuICAgIC8vLyBzb21laG93KS4gQGludGVybmFsXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMuY3g7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogQWN0aW9ucyAqLyldID09IDY1NTM1IC8qIEVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKTtcbiAgICB9XG4gICAgLy8vIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICAvLy8gd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgLy8vIHN0YXRlKS4gQGludGVybmFsXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNhbWVTdGF0ZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBvdGhlci5zdGF0ZSB8fCB0aGlzLnN0YWNrLmxlbmd0aCAhPSBvdGhlci5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrW2ldICE9IG90aGVyLnN0YWNrW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMuY3gucGFyc2VyOyB9XG4gICAgLy8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgICAvLy8gdGhlIHRlcm1zIGZpbGUpIGlzIGVuYWJsZWQuXG4gICAgZGlhbGVjdEVuYWJsZWQoZGlhbGVjdElEKSB7IHJldHVybiB0aGlzLmN4LnBhcnNlci5kaWFsZWN0LmZsYWdzW2RpYWxlY3RJRF07IH1cbn1cbnZhciBSZWNvdmVyO1xuKGZ1bmN0aW9uIChSZWNvdmVyKSB7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiVG9rZW5cIl0gPSAyMDBdID0gXCJUb2tlblwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIlJlZHVjZVwiXSA9IDEwMF0gPSBcIlJlZHVjZVwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIk1heE5leHRcIl0gPSA0XSA9IFwiTWF4TmV4dFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIk1heEluc2VydFN0YWNrRGVwdGhcIl0gPSAzMDBdID0gXCJNYXhJbnNlcnRTdGFja0RlcHRoXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aFwiXSA9IDEyMF0gPSBcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIjtcbn0pKFJlY292ZXIgfHwgKFJlY292ZXIgPSB7fSkpO1xuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaykge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMudG9wID0gc3RhY2suc3RhdGU7XG4gICAgICAgIHRoaXMucmVzdCA9IHN0YWNrLnN0YWNrO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMucmVzdC5sZW5ndGg7XG4gICAgfVxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi87XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0ID09IHRoaXMuc3RhY2suc3RhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0ID0gdGhpcy5yZXN0LnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3QucHVzaCh0aGlzLnRvcCwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFjay5jeC5wYXJzZXIuZ2V0R290byh0aGlzLnJlc3RbdGhpcy5vZmZzZXQgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMudG9wID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaykge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCwgc3RhY2suYnVmZmVyLmxlbmd0aCk7XG4gICAgfVxuICAgIG1heWJlTmV4dCgpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLnN0YWNrLnBhcmVudDtcbiAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2suYnVmZmVyQmFzZSAtIG5leHQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBuZXh0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXh0LmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLmluZGV4IC09IDQ7XG4gICAgICAgIHRoaXMucG9zIC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBmb3JrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHRoaXMuc3RhY2ssIHRoaXMucG9zLCB0aGlzLmluZGV4KTtcbiAgICB9XG59XG5cbi8vLyBUb2tlbml6ZXJzIHdyaXRlIHRoZSB0b2tlbnMgdGhleSByZWFkIGludG8gaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuXG5jbGFzcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHRva2VuLiBUaGlzIGlzIHNldCBieSB0aGUgcGFyc2VyLCBhbmQgc2hvdWxkIG5vdFxuICAgICAgICAvLy8gYmUgbXV0YXRlZCBieSB0aGUgdG9rZW5pemVyLlxuICAgICAgICB0aGlzLnN0YXJ0ID0gLTE7XG4gICAgICAgIC8vLyBUaGlzIHN0YXJ0cyBhdCAtMSwgYW5kIHNob3VsZCBiZSB1cGRhdGVkIHRvIGEgdGVybSBpZCB3aGVuIGFcbiAgICAgICAgLy8vIG1hdGNoaW5nIHRva2VuIGlzIGZvdW5kLlxuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIC8vLyBXaGVuIHNldHRpbmcgYC52YWx1ZWAsIHlvdSBzaG91bGQgYWxzbyBzZXQgYC5lbmRgIHRvIHRoZSBlbmRcbiAgICAgICAgLy8vIHBvc2l0aW9uIG9mIHRoZSB0b2tlbi4gKFlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gdXNlIHRoZSBgYWNjZXB0YFxuICAgICAgICAvLy8gbWV0aG9kLilcbiAgICAgICAgdGhpcy5lbmQgPSAtMTtcbiAgICB9XG4gICAgLy8vIEFjY2VwdCBhIHRva2VuLCBzZXR0aW5nIGB2YWx1ZWAgYW5kIGBlbmRgIHRvIHRoZSBnaXZlbiB2YWx1ZXMuXG4gICAgYWNjZXB0KHZhbHVlLCBlbmQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG59XG4vLy8gQGludGVybmFsXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCB0b2tlbiwgc3RhY2spIHsgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHRva2VuLCBzdGFjaywgdGhpcy5pZCk7IH1cbn1cblRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLy8vIEV4cG9ydHMgdGhhdCBhcmUgdXNlZCBmb3IgYEBleHRlcm5hbCB0b2tlbnNgIGluIHRoZSBncmFtbWFyIHNob3VsZFxuLy8vIGV4cG9ydCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuY2xhc3MgRXh0ZXJuYWxUb2tlbml6ZXIge1xuICAgIC8vLyBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICAvLy8gZ2l2ZW4gYW4gaW5wdXQgc3RyZWFtIGFuZCBhIHRva2VuIG9iamVjdCxcbiAgICAvLy8gW2ZpbGxzXSgjbGV6ZXIuVG9rZW4uYWNjZXB0KSB0aGUgdG9rZW4gb2JqZWN0IGlmIGl0IHJlY29nbml6ZXMgYVxuICAgIC8vLyB0b2tlbi4gYHRva2VuLnN0YXJ0YCBzaG91bGQgYmUgdXNlZCBhcyB0aGUgc3RhcnQgcG9zaXRpb24gdG9cbiAgICAvLy8gc2NhbiBmcm9tLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b2tlbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5jb250ZXh0dWFsID0gISFvcHRpb25zLmNvbnRleHR1YWw7XG4gICAgICAgIHRoaXMuZmFsbGJhY2sgPSAhIW9wdGlvbnMuZmFsbGJhY2s7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gISFvcHRpb25zLmV4dGVuZDtcbiAgICB9XG59XG4vLyBUb2tlbml6ZXIgZGF0YSBpcyBzdG9yZWQgYSBiaWcgdWludDE2IGFycmF5IGNvbnRhaW5pbmcsIGZvciBlYWNoXG4vLyBzdGF0ZTpcbi8vXG4vLyAgLSBBIGdyb3VwIGJpdG1hc2ssIGluZGljYXRpbmcgd2hhdCB0b2tlbiBncm91cHMgYXJlIHJlYWNoYWJsZSBmcm9tXG4vLyAgICB0aGlzIHN0YXRlLCBzbyB0aGF0IHBhdGhzIHRoYXQgY2FuIG9ubHkgbGVhZCB0byB0b2tlbnMgbm90IGluXG4vLyAgICBhbnkgb2YgdGhlIGN1cnJlbnQgZ3JvdXBzIGNhbiBiZSBjdXQgb2ZmIGVhcmx5LlxuLy9cbi8vICAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoZSBzdGF0ZSdzIHNlcXVlbmNlIG9mIGFjY2VwdGluZ1xuLy8gICAgdG9rZW5zXG4vL1xuLy8gIC0gVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyBmb3IgdGhlIHN0YXRlXG4vL1xuLy8gIC0gVGhlIGFjY2VwdGluZyB0b2tlbnMsIGFzICh0b2tlbiBpZCwgZ3JvdXAgbWFzaykgcGFpcnNcbi8vXG4vLyAgLSBUaGUgb3V0Z29pbmcgZWRnZXMsIGFzIChzdGFydCBjaGFyYWN0ZXIsIGVuZCBjaGFyYWN0ZXIsIHN0YXRlXG4vLyAgICBpbmRleCkgdHJpcGxlcywgd2l0aCBlbmQgY2hhcmFjdGVyIGJlaW5nIGV4Y2x1c2l2ZVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaW50ZXJwcmV0cyB0aGF0IGRhdGEsIHJ1bm5pbmcgdGhyb3VnaCBhIHN0cmVhbSBhc1xuLy8gbG9uZyBhcyBuZXcgc3RhdGVzIHdpdGggdGhlIGEgbWF0Y2hpbmcgZ3JvdXAgbWFzayBjYW4gYmUgcmVhY2hlZCxcbi8vIGFuZCB1cGRhdGluZyBgdG9rZW5gIHdoZW4gaXQgbWF0Y2hlcyBhIHRva2VuLlxuZnVuY3Rpb24gcmVhZFRva2VuKGRhdGEsIGlucHV0LCB0b2tlbiwgc3RhY2ssIGdyb3VwKSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgZGlhbGVjdCA9IHN0YWNrLmN4LnBhcnNlci5kaWFsZWN0O1xuICAgIHNjYW46IGZvciAobGV0IHBvcyA9IHRva2VuLnN0YXJ0OzspIHtcbiAgICAgICAgaWYgKChncm91cE1hc2sgJiBkYXRhW3N0YXRlXSkgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgYWNjRW5kID0gZGF0YVtzdGF0ZSArIDFdO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgY2FuIGxlYWQgdG8gYSB0b2tlbiBpbiB0aGUgY3VycmVudCBncm91cFxuICAgICAgICAvLyBBY2NlcHQgdG9rZW5zIGluIHRoaXMgc3RhdGUsIHBvc3NpYmx5IG92ZXJ3cml0aW5nXG4gICAgICAgIC8vIGxvd2VyLXByZWNlZGVuY2UgLyBzaG9ydGVyIHRva2Vuc1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhdGUgKyAzOyBpIDwgYWNjRW5kOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAoKGRhdGFbaSArIDFdICYgZ3JvdXBNYXNrKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpYWxlY3QuYWxsb3dzKHRlcm0pICYmXG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi52YWx1ZSA9PSAtMSB8fCB0b2tlbi52YWx1ZSA9PSB0ZXJtIHx8IHN0YWNrLmN4LnBhcnNlci5vdmVycmlkZXModGVybSwgdG9rZW4udmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5hY2NlcHQodGVybSwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmdldChwb3MrKyk7XG4gICAgICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgc3RhdGUncyBlZGdlc1xuICAgICAgICBmb3IgKGxldCBsb3cgPSAwLCBoaWdoID0gZGF0YVtzdGF0ZSArIDJdOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogQmlnVmFsQ29kZSAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gNjU1MzUgLyogQmlnVmFsICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPj0gOTIgLyogR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBHYXAxICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGxldCBkaWdpdCA9IG5leHQgLSAzMiAvKiBTdGFydCAqLztcbiAgICAgICAgICAgIGlmIChkaWdpdCA+PSA0NiAvKiBCYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlICs9IGRpZ2l0O1xuICAgICAgICAgICAgaWYgKHN0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YWx1ZSAqPSA0NiAvKiBCYXNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheSlcbiAgICAgICAgICAgIGFycmF5W291dCsrXSA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG4vLyBGSVhNRSBmaW5kIHNvbWUgd2F5IHRvIHJlZHVjZSByZWNvdmVyeSB3b3JrIGRvbmUgd2hlbiB0aGUgaW5wdXRcbi8vIGRvZXNuJ3QgbWF0Y2ggdGhlIGdyYW1tYXIgYXQgYWxsLlxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5jdXJzb3IocG9zKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghKHNpZGUgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHBvcykgOiBjdXJzb3IuY2hpbGRBZnRlcihwb3MpKSlcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPCAwID8gY3Vyc29yLnRvIDw9IHBvcyA6IGN1cnNvci5mcm9tID49IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IGN1cnNvci50byAtIDEgOiBjdXJzb3IuZnJvbSArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IDAgOiB0cmVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYWZlRnJvbSA9IC0xO1xuICAgICAgICB0aGlzLnNhZmVUbyA9IC0xO1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBuZXh0RnJhZ21lbnQoKSB7XG4gICAgICAgIGxldCBmciA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICAgICAgaWYgKGZyKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVGcm9tID0gZnIub3BlblN0YXJ0ID8gY3V0QXQoZnIudHJlZSwgZnIuZnJvbSArIGZyLm9mZnNldCwgMSkgLSBmci5vZmZzZXQgOiBmci5mcm9tO1xuICAgICAgICAgICAgdGhpcy5zYWZlVG8gPSBmci5vcGVuRW5kID8gY3V0QXQoZnIudHJlZSwgZnIudG8gKyBmci5vZmZzZXQsIC0xKSAtIGZyLm9mZnNldCA6IGZyLnRvO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHJlZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2goZnIudHJlZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goLWZyLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHRoaXMuc2FmZUZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IDFlOTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBgcG9zYCBtdXN0IGJlID49IGFueSBwcmV2aW91c2x5IGdpdmVuIGBwb3NgIGZvciB0aGlzIGN1cnNvclxuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2FmZVRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJlZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgeyAvLyBFbmQgb2YgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50cmVlc1tsYXN0XSwgaW5kZXggPSB0aGlzLmluZGV4W2xhc3RdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRvcC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnRbbGFzdF0gKyB0b3AucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydCA9PSBwb3MgJiYgc3RhcnQgKyBuZXh0Lmxlbmd0aCA8PSB0aGlzLnNhZmVUbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydCA9PSBwb3MgJiYgc3RhcnQgPj0gdGhpcy5zYWZlRnJvbSA/IG5leHQgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBsZXplclRyZWUuVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgbmV4dC5sZW5ndGggPj0gcG9zKSB7IC8vIEVudGVyIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYWNoZWRUb2tlbiBleHRlbmRzIFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgIH1cbiAgICBjbGVhcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmV4dGVuZGVkID0gLTE7XG4gICAgfVxufVxuY29uc3QgZHVtbXlUb2tlbiA9IG5ldyBUb2tlbjtcbmNsYXNzIFRva2VuQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IGR1bW15VG9rZW47XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnRva2VucyA9IHBhcnNlci50b2tlbml6ZXJzLm1hcChfID0+IG5ldyBDYWNoZWRUb2tlbik7XG4gICAgfVxuICAgIGdldEFjdGlvbnMoc3RhY2ssIGlucHV0KSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5jeCwgeyB0b2tlbml6ZXJzIH0gPSBwYXJzZXI7XG4gICAgICAgIGxldCBtYXNrID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgMyAvKiBUb2tlbml6ZXJNYXNrICovKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKCgxIDw8IGkpICYgbWFzaykgPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0b2tlbml6ZXIgPSB0b2tlbml6ZXJzW2ldLCB0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKG1haW4gJiYgIXRva2VuaXplci5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuY29udGV4dHVhbCB8fCB0b2tlbi5zdGFydCAhPSBzdGFjay5wb3MgfHwgdG9rZW4ubWFzayAhPSBtYXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaywgaW5wdXQpO1xuICAgICAgICAgICAgICAgIHRva2VuLm1hc2sgPSBtYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlICE9IDAgLyogRXJyICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXh0ZW5kZWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLmV4dGVuZGVkLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4udmFsdWUsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5pemVyLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25JbmRleCA+IHN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYWN0aW9ucy5sZW5ndGggPiBhY3Rpb25JbmRleClcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcbiAgICAgICAgaWYgKCFtYWluKSB7XG4gICAgICAgICAgICBtYWluID0gZHVtbXlUb2tlbjtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBzdGFjay5wb3M7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID09IGlucHV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBtYWluLmFjY2VwdChzdGFjay5jeC5wYXJzZXIuZW9mVGVybSwgc3RhY2sucG9zKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYWluLmFjY2VwdCgwIC8qIEVyciAqLywgc3RhY2sucG9zICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBtYWluO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zO1xuICAgIH1cbiAgICB1cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaywgaW5wdXQpIHtcbiAgICAgICAgdG9rZW4uY2xlYXIoc3RhY2sucG9zKTtcbiAgICAgICAgdG9rZW5pemVyLnRva2VuKGlucHV0LCB0b2tlbiwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5jeDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VyLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuc3BlY2lhbGl6ZWRbaV0gPT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlci5zcGVjaWFsaXplcnNbaV0oaW5wdXQucmVhZCh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKSwgc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID49IDAgJiYgc3RhY2suY3gucGFyc2VyLmRpYWxlY3QuYWxsb3dzKHJlc3VsdCA+PiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgJiAxKSA9PSAwIC8qIFNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhY2sucG9zID09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdG9rZW4uYWNjZXB0KHN0YWNrLmN4LnBhcnNlci5lb2ZUZXJtLCBzdGFjay5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4uYWNjZXB0KDAgLyogRXJyICovLCBzdGFjay5wb3MgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXRBY3Rpb24oYWN0aW9uLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpXSA9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IHRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBlbmQ7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHN0YWNrLCB7IHBhcnNlciB9ID0gc3RhY2suY3gsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBPdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDEpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSB0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAxKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG52YXIgUmVjO1xuKGZ1bmN0aW9uIChSZWMpIHtcbiAgICBSZWNbUmVjW1wiRGlzdGFuY2VcIl0gPSA1XSA9IFwiRGlzdGFuY2VcIjtcbiAgICBSZWNbUmVjW1wiTWF4UmVtYWluaW5nUGVyU3RlcFwiXSA9IDNdID0gXCJNYXhSZW1haW5pbmdQZXJTdGVwXCI7XG4gICAgUmVjW1JlY1tcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCJdID0gMjAwXSA9IFwiTWluQnVmZmVyTGVuZ3RoUHJ1bmVcIjtcbiAgICBSZWNbUmVjW1wiRm9yY2VSZWR1Y2VMaW1pdFwiXSA9IDEwXSA9IFwiRm9yY2VSZWR1Y2VMaW1pdFwiO1xufSkoUmVjIHx8IChSZWMgPSB7fSkpO1xuLy8vIEEgcGFyc2UgY29udGV4dCBjYW4gYmUgdXNlZCBmb3Igc3RlcC1ieS1zdGVwIHBhcnNpbmcuIEFmdGVyXG4vLy8gY3JlYXRpbmcgaXQsIHlvdSByZXBlYXRlZGx5IGNhbGwgYC5hZHZhbmNlKClgIHVudGlsIGl0IHJldHVybnMgYVxuLy8vIHRyZWUgdG8gaW5kaWNhdGUgaXQgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFyc2UuXG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBpbnB1dCwgc3RhcnRQb3MsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5zdGFydFBvcyA9IHN0YXJ0UG9zO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAvLyBUaGUgcG9zaXRpb24gdG8gd2hpY2ggdGhlIHBhcnNlIGhhcyBhZHZhbmNlZC5cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0O1xuICAgICAgICB0aGlzLm5lc3RlZCA9IG51bGw7XG4gICAgICAgIHRoaXMubmVzdEVuZCA9IDA7XG4gICAgICAgIHRoaXMubmVzdFdyYXAgPSBudWxsO1xuICAgICAgICB0aGlzLnJldXNlZCA9IFtdO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlcik7XG4gICAgICAgIHRoaXMudG9wVGVybSA9IHBhcnNlci50b3BbMV07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIHRoaXMuc3RhcnRQb3MpXTtcbiAgICAgICAgbGV0IGZyYWdtZW50cyA9IGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5mcmFnbWVudHM7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzICYmIGZyYWdtZW50cy5sZW5ndGggPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzKSA6IG51bGw7XG4gICAgfVxuICAgIC8vIE1vdmUgdGhlIHBhcnNlciBmb3J3YXJkLiBUaGlzIHdpbGwgcHJvY2VzcyBhbGwgcGFyc2Ugc3RhY2tzIGF0XG4gICAgLy8gYHRoaXMucG9zYCBhbmQgdHJ5IHRvIGFkdmFuY2UgdGhlbSB0byBhIGZ1cnRoZXIgcG9zaXRpb24uIElmIG5vXG4gICAgLy8gc3RhY2sgZm9yIHN1Y2ggYSBwb3NpdGlvbiBpcyBmb3VuZCwgaXQnbGwgc3RhcnQgZXJyb3ItcmVjb3ZlcnkuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBwYXJzZSBpcyBmaW5pc2hlZCwgdGhpcyB3aWxsIHJldHVybiBhIHN5bnRheCB0cmVlLiBXaGVuXG4gICAgLy8gbm90LCBpdCByZXR1cm5zIGBudWxsYC5cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5uZXN0ZWQpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm5lc3RlZC5hZHZhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubmVzdGVkLnBvcztcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaE5lc3RlZCh0aGlzLnN0YWNrc1swXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdGFja3MsIHBvcyA9IHRoaXMucG9zO1xuICAgICAgICAvLyBUaGlzIHdpbGwgaG9sZCBzdGFja3MgYmV5b25kIGBwb3NgLlxuICAgICAgICBsZXQgbmV3U3RhY2tzID0gdGhpcy5zdGFja3MgPSBbXTtcbiAgICAgICAgbGV0IHN0b3BwZWQsIHN0b3BwZWRUb2tlbnM7XG4gICAgICAgIGxldCBtYXliZU5lc3Q7XG4gICAgICAgIC8vIEtlZXAgYWR2YW5jaW5nIGFueSBzdGFja3MgYXQgYHBvc2AgdW50aWwgdGhleSBlaXRoZXIgbW92ZVxuICAgICAgICAvLyBmb3J3YXJkIG9yIGNhbid0IGJlIGFkdmFuY2VkLiBHYXRoZXIgc3RhY2tzIHRoYXQgY2FuJ3QgYmVcbiAgICAgICAgLy8gYWR2YW5jZWQgZnVydGhlciBpbiBgc3RvcHBlZGAuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIG5lc3Q7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5lc3QgPSB0aGlzLmNoZWNrTmVzdChzdGFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXliZU5lc3QgfHwgbWF5YmVOZXN0LnN0YWNrLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5lc3QgPSBuZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLm1haW5Ub2tlbjtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2Vucy5wdXNoKHRvay52YWx1ZSwgdG9rLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZU5lc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXN0ZWQobWF5YmVOZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmV3U3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gc3RvcHBlZCAmJiBmaW5kRmluaXNoZWQoc3RvcHBlZCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlICYmIHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3R1Y2sgd2l0aCB0b2tlbiBcIiArIHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBEaXN0YW5jZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nICYmIHN0b3BwZWQpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHRoaXMucnVuUmVjb3Zlcnkoc3RvcHBlZCwgc3RvcHBlZFRva2VucywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBNYXhSZW1haW5pbmdQZXJTdGVwICovO1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLnNvbWUocyA9PiBzLnJlZHVjZVBvcyA+IHBvcykpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFBydW5lIHN0YWNrcyB0aGF0IGFyZSBpbiB0aGUgc2FtZSBzdGF0ZSwgb3IgdGhhdCBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIHJ1bm5pbmcgd2l0aG91dCBzcGxpdHRpbmcgZm9yIGEgd2hpbGUsIHRvIGF2b2lkIGdldHRpbmcgc3R1Y2tcbiAgICAgICAgICAgIC8vIHdpdGggbXVsdGlwbGUgc3VjY2Vzc2Z1bCBzdGFja3MgcnVubmluZyBlbmRsZXNzbHkgb24uXG4gICAgICAgICAgICBvdXRlcjogZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG5ld1N0YWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5zYW1lU3RhdGUob3RoZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5idWZmZXIubGVuZ3RoID4gMjAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovICYmIG90aGVyLmJ1ZmZlci5sZW5ndGggPiAyMDAgLyogTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IG5ld1N0YWNrc1swXS5wb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5wb3MgPCB0aGlzLnBvcylcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gc3RhY2ssIG9yIG51bGwgaWYgdGhlXG4gICAgLy8gc3RhY2sgY2FuJ3QgYWR2YW5jZSBub3JtYWxseS4gV2hlbiBgc3BsaXRgIGFuZCBgc3RhY2tzYCBhcmVcbiAgICAvLyBnaXZlbiwgc3RhY2tzIHNwbGl0IG9mZiBieSBhbWJpZ3VvdXMgb3BlcmF0aW9ucyB3aWxsIGJlIHB1c2hlZCB0b1xuICAgIC8vIGBzcGxpdGAsIG9yIGFkZGVkIHRvIGBzdGFja3NgIGlmIHRoZXkgbW92ZSBgcG9zYCBmb3J3YXJkLlxuICAgIGFkdmFuY2VTdGFjayhzdGFjaywgc3RhY2tzLCBzcGxpdCkge1xuICAgICAgICBsZXQgc3RhcnQgPSBzdGFjay5wb3MsIHsgaW5wdXQsIHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjYWNoZWQgPSB0aGlzLmZyYWdtZW50cy5ub2RlQXQoc3RhcnQpOyBjYWNoZWQ7KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1tjYWNoZWQudHlwZS5pZF0gPT0gY2FjaGVkLnR5cGUgPyBwYXJzZXIuZ2V0R290byhzdGFjay5zdGF0ZSwgY2FjaGVkLnR5cGUuaWQpIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID4gLTEgJiYgY2FjaGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay51c2VOb2RlKGNhY2hlZCwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJldXNlIG9mICR7cGFyc2VyLmdldE5hbWUoY2FjaGVkLnR5cGUuaWQpfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGNhY2hlZCBpbnN0YW5jZW9mIGxlemVyVHJlZS5UcmVlKSB8fCBjYWNoZWQuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgY2FjaGVkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNhY2hlZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIgaW5zdGFuY2VvZiBsZXplclRyZWUuVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGlmIChkZWZhdWx0UmVkdWNlID4gMCkge1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlKGRlZmF1bHRSZWR1Y2UpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgYWx3YXlzLXJlZHVjZSAke3BhcnNlci5nZXROYW1lKGRlZmF1bHRSZWR1Y2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY3Rpb25zID0gdGhpcy50b2tlbnMuZ2V0QWN0aW9ucyhzdGFjaywgaW5wdXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNbaSsrXSwgdGVybSA9IGFjdGlvbnNbaSsrXSwgZW5kID0gYWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGFjdGlvbnMubGVuZ3RoIHx8ICFzcGxpdDtcbiAgICAgICAgICAgIGxldCBsb2NhbFN0YWNrID0gbGFzdCA/IHN0YWNrIDogc3RhY2suc3BsaXQoKTtcbiAgICAgICAgICAgIGxvY2FsU3RhY2suYXBwbHkoYWN0aW9uLCB0ZXJtLCBlbmQpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChsb2NhbFN0YWNrKSArIGAgKHZpYSAkeyhhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwID8gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgIDogYHJlZHVjZSBvZiAke3BhcnNlci5nZXROYW1lKGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLyl9YH0gZm9yICR7cGFyc2VyLmdldE5hbWUodGVybSl9IEAgJHtzdGFydH0ke2xvY2FsU3RhY2sgPT0gc3RhY2sgPyBcIlwiIDogXCIsIHNwbGl0XCJ9KWApO1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbFN0YWNrLnBvcyA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNwbGl0LnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIGEgZ2l2ZW4gc3RhY2sgZm9yd2FyZCBhcyBmYXIgYXMgaXQgd2lsbCBnby4gUmV0dXJucyB0aGVcbiAgICAvLyAocG9zc2libHkgdXBkYXRlZCkgc3RhY2sgaWYgaXQgZ290IHN0dWNrLCBvciBudWxsIGlmIGl0IG1vdmVkXG4gICAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gICAgYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YWNrLnBvcztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5lc3QgPSB0aGlzLmNoZWNrTmVzdChzdGFjayk7XG4gICAgICAgICAgICBpZiAobmVzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVzdDtcbiAgICAgICAgICAgIGlmICghdGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG51bGwsIG51bGwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5SZWNvdmVyeShzdGFja3MsIHRva2VucywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBmaW5pc2hlZCA9IG51bGwsIHJlc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgbWF5YmVOZXN0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCB0b2tlbiA9IHRva2Vuc1tpIDw8IDFdLCB0b2tlbkVuZCA9IHRva2Vuc1soaSA8PCAxKSArIDFdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChzdGFjay5kZWFkRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmVzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFjay5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgKHJlc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlTmVzdCA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHN0YWNrLnNwbGl0KCksIGZvcmNlQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgZm9yY2UuZm9yY2VSZWR1Y2UoKSAmJiBqIDwgMTAgLyogRm9yY2VSZWR1Y2VMaW1pdCAqLzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcmNlQmFzZSArIHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAodmlhIGZvcmNlLXJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShmb3JjZSwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlTmVzdCA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VCYXNlID0gdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiIC0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaW5zZXJ0IG9mIHN0YWNrLnJlY292ZXJCeUluc2VydCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChpbnNlcnQpICsgXCIgKHZpYSByZWNvdmVyLWluc2VydClcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlRnVsbHkoaW5zZXJ0LCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQubGVuZ3RoID4gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRW5kID09IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IDAgLyogRXJyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFjay5yZWNvdmVyQnlEZWxldGUodG9rZW4sIHRva2VuRW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmVjb3Zlci1kZWxldGUgJHt0aGlzLnBhcnNlci5nZXROYW1lKHRva2VuKX0pYCk7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluaXNoZWQgfHwgZmluaXNoZWQuc2NvcmUgPCBzdGFjay5zY29yZSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuICAgICAgICBpZiAobWF5YmVOZXN0KVxuICAgICAgICAgICAgZm9yIChsZXQgcyBvZiB0aGlzLnN0YWNrcylcbiAgICAgICAgICAgICAgICBpZiAocy5zY29yZSA+IG1heWJlTmVzdC5zdGFjay5zY29yZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZU5lc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlTmVzdClcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXN0ZWQobWF5YmVOZXN0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvcmNlRmluaXNoKCkge1xuICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnN0YWNrc1swXS5zcGxpdCgpO1xuICAgICAgICBpZiAodGhpcy5uZXN0ZWQpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaE5lc3RlZChzdGFjaywgdGhpcy5uZXN0ZWQuZm9yY2VGaW5pc2goKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKHN0YWNrLmZvcmNlQWxsKCkpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBzdGFjaydzIGJ1ZmZlciB0byBhIHN5bnRheCB0cmVlLlxuICAgIHN0YWNrVG9UcmVlKHN0YWNrLCBwb3MgPSBzdGFjay5wb3MpIHtcbiAgICAgICAgcmV0dXJuIGxlemVyVHJlZS5UcmVlLmJ1aWxkKHsgYnVmZmVyOiBTdGFja0J1ZmZlckN1cnNvci5jcmVhdGUoc3RhY2spLFxuICAgICAgICAgICAgbm9kZVNldDogdGhpcy5wYXJzZXIubm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiB0aGlzLnRvcFRlcm0sXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IHRoaXMucGFyc2VyLmJ1ZmZlckxlbmd0aCxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5yZXVzZWQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5zdGFydFBvcyxcbiAgICAgICAgICAgIGxlbmd0aDogcG9zIC0gdGhpcy5zdGFydFBvcyxcbiAgICAgICAgICAgIG1pblJlcGVhdFR5cGU6IHRoaXMucGFyc2VyLm1pblJlcGVhdFRlcm0gfSk7XG4gICAgfVxuICAgIGNoZWNrTmVzdChzdGFjaykge1xuICAgICAgICBsZXQgaW5mbyA9IHRoaXMucGFyc2VyLmZpbmROZXN0ZWQoc3RhY2suc3RhdGUpO1xuICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHNwZWMgPSBpbmZvLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgc3BlYyA9IHNwZWModGhpcy5pbnB1dCwgc3RhY2spO1xuICAgICAgICByZXR1cm4gc3BlYyA/IHsgc3RhY2ssIGluZm8sIHNwZWMgfSA6IG51bGw7XG4gICAgfVxuICAgIHN0YXJ0TmVzdGVkKG5lc3QpIHtcbiAgICAgICAgbGV0IHsgc3RhY2ssIGluZm8sIHNwZWMgfSA9IG5lc3Q7XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW3N0YWNrXTtcbiAgICAgICAgdGhpcy5uZXN0RW5kID0gdGhpcy5zY2FuRm9yTmVzdEVuZChzdGFjaywgaW5mby5lbmQsIHNwZWMuZmlsdGVyRW5kKTtcbiAgICAgICAgdGhpcy5uZXN0V3JhcCA9IHR5cGVvZiBzcGVjLndyYXBUeXBlID09IFwibnVtYmVyXCIgPyB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW3NwZWMud3JhcFR5cGVdIDogc3BlYy53cmFwVHlwZSB8fCBudWxsO1xuICAgICAgICBpZiAoc3BlYy5zdGFydFBhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLm5lc3RlZCA9IHNwZWMuc3RhcnRQYXJzZSh0aGlzLmlucHV0LmNsaXAodGhpcy5uZXN0RW5kKSwgc3RhY2sucG9zLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hOZXN0ZWQoc3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW5Gb3JOZXN0RW5kKHN0YWNrLCBlbmRUb2tlbiwgZmlsdGVyKSB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN0YWNrLnBvczsgcG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgICAgICBkdW1teVRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgZHVtbXlUb2tlbi52YWx1ZSA9IC0xO1xuICAgICAgICAgICAgZW5kVG9rZW4udG9rZW4odGhpcy5pbnB1dCwgZHVtbXlUb2tlbiwgc3RhY2spO1xuICAgICAgICAgICAgaWYgKGR1bW15VG9rZW4udmFsdWUgPiAtMSAmJiAoIWZpbHRlciB8fCBmaWx0ZXIodGhpcy5pbnB1dC5yZWFkKHBvcywgZHVtbXlUb2tlbi5lbmQpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgfVxuICAgIGZpbmlzaE5lc3RlZChzdGFjaywgdHJlZSkge1xuICAgICAgICBpZiAodGhpcy5uZXN0V3JhcClcbiAgICAgICAgICAgIHRyZWUgPSBuZXcgbGV6ZXJUcmVlLlRyZWUodGhpcy5uZXN0V3JhcCwgdHJlZSA/IFt0cmVlXSA6IFtdLCB0cmVlID8gWzBdIDogW10sIHRoaXMubmVzdEVuZCAtIHN0YWNrLnBvcyk7XG4gICAgICAgIGVsc2UgaWYgKCF0cmVlKVxuICAgICAgICAgICAgdHJlZSA9IG5ldyBsZXplclRyZWUuVHJlZShsZXplclRyZWUuTm9kZVR5cGUubm9uZSwgW10sIFtdLCB0aGlzLm5lc3RFbmQgLSBzdGFjay5wb3MpO1xuICAgICAgICBsZXQgaW5mbyA9IHRoaXMucGFyc2VyLmZpbmROZXN0ZWQoc3RhY2suc3RhdGUpO1xuICAgICAgICBzdGFjay51c2VOb2RlKHRyZWUsIHRoaXMucGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGluZm8ucGxhY2Vob2xkZXIsIHRydWUpKTtcbiAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHVubmVzdClgKTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG4vLy8gQSBwYXJzZXIgaG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWRcbi8vLyBieSBgbGV6ZXItZ2VuZXJhdG9yYC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IGxlemVyVHJlZS5EZWZhdWx0QnVmZmVyTGVuZ3RoO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMuc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV4dFN0YXRlQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5jYWNoZWREaWFsZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxMyAvKiBWZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezEzIC8qIFZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgdG9rZW5BcnJheSA9IGRlY29kZUFycmF5KHNwZWMudG9rZW5EYXRhKTtcbiAgICAgICAgbGV0IG5vZGVOYW1lcyA9IHNwZWMubm9kZU5hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdGhpcy5taW5SZXBlYXRUZXJtID0gbm9kZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnJlcGVhdE5vZGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgbm9kZU5hbWVzLnB1c2goXCJcIik7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGVjaWFsaXplZCA9IG5ldyBVaW50MTZBcnJheShzcGVjLnNwZWNpYWxpemVkID8gc3BlYy5zcGVjaWFsaXplZC5sZW5ndGggOiAwKTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMuc3BlY2lhbGl6ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVkW2ldID0gc3BlYy5zcGVjaWFsaXplZFtpXS50ZXJtO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzW2ldID0gc3BlYy5zcGVjaWFsaXplZFtpXS5nZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVzID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZXMsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZURhdGEpO1xuICAgICAgICB0aGlzLmdvdG8gPSBkZWNvZGVBcnJheShzcGVjLmdvdG8pO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IGxlemVyVHJlZS5Ob2RlU2V0KG5vZGVOYW1lcy5tYXAoKG5hbWUsIGkpID0+IGxlemVyVHJlZS5Ob2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICAgICAgbmFtZTogaSA+PSB0aGlzLm1pblJlcGVhdFRlcm0gPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICBwcm9wczogbm9kZVByb3BzW2ldLFxuICAgICAgICAgICAgdG9wOiB0b3BUZXJtcy5pbmRleE9mKGkpID4gLTEsXG4gICAgICAgICAgICBlcnJvcjogaSA9PSAwLFxuICAgICAgICAgICAgc2tpcHBlZDogc3BlYy5za2lwcGVkTm9kZXMgJiYgc3BlYy5za2lwcGVkTm9kZXMuaW5kZXhPZihpKSA+IC0xXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHRoaXMubWF4VGVybSA9IHNwZWMubWF4VGVybTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXJzID0gc3BlYy50b2tlbml6ZXJzLm1hcCh2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IG5ldyBUb2tlbkdyb3VwKHRva2VuQXJyYXksIHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgdGhpcy50b3BSdWxlcyA9IHNwZWMudG9wUnVsZXM7XG4gICAgICAgIHRoaXMubmVzdGVkID0gKHNwZWMubmVzdGVkIHx8IFtdKS5tYXAoKFtuYW1lLCB2YWx1ZSwgZW5kVG9rZW4sIHBsYWNlaG9sZGVyXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWUsIGVuZDogbmV3IFRva2VuR3JvdXAoZGVjb2RlQXJyYXkoZW5kVG9rZW4pLCAwKSwgcGxhY2Vob2xkZXIgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSBzcGVjLmRpYWxlY3RzIHx8IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcyA9IHNwZWMuZHluYW1pY1ByZWNlZGVuY2VzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5QcmVjVGFibGUgPSBzcGVjLnRva2VuUHJlYztcbiAgICAgICAgdGhpcy50ZXJtTmFtZXMgPSBzcGVjLnRlcm1OYW1lcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm1heE5vZGUgPSB0aGlzLm5vZGVTZXQudHlwZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLnN0YXRlcy5sZW5ndGggLyA2IC8qIFNpemUgKi87IGkgPCBsOyBpKyspXG4gICAgICAgICAgICB0aGlzLm5leHRTdGF0ZUNhY2hlW2ldID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcFJ1bGVzW09iamVjdC5rZXlzKHRoaXMudG9wUnVsZXMpWzBdXTtcbiAgICB9XG4gICAgLy8vIFBhcnNlIGEgZ2l2ZW4gc3RyaW5nIG9yIHN0cmVhbS5cbiAgICBwYXJzZShpbnB1dCwgc3RhcnRQb3MgPSAwLCBjb250ZXh0ID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBsZXplclRyZWUuc3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICBsZXQgY3ggPSBuZXcgUGFyc2UodGhpcywgaW5wdXQsIHN0YXJ0UG9zLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBjeC5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gU3RhcnQgYW4gaW5jcmVtZW50YWwgcGFyc2UuXG4gICAgc3RhcnRQYXJzZShpbnB1dCwgc3RhcnRQb3MgPSAwLCBjb250ZXh0ID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBsZXplclRyZWUuc3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBzdGFydFBvcywgY29udGV4dCk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBnb3RvIHRhYmxlIGVudHJ5IEBpbnRlcm5hbFxuICAgIGdldEdvdG8oc3RhdGUsIHRlcm0sIGxvb3NlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5nb3RvO1xuICAgICAgICBpZiAodGVybSA+PSB0YWJsZVswXSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGFibGVbdGVybSArIDFdOzspIHtcbiAgICAgICAgICAgIGxldCBncm91cFRhZyA9IHRhYmxlW3BvcysrXSwgbGFzdCA9IGdyb3VwVGFnICYgMTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0YWJsZVtwb3MrK107XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsb29zZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgZW5kID0gcG9zICsgKGdyb3VwVGFnID4+IDEpOyBwb3MgPCBlbmQ7IHBvcysrKVxuICAgICAgICAgICAgICAgIGlmICh0YWJsZVtwb3NdID09IHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBDaGVjayBpZiB0aGlzIHN0YXRlIGhhcyBhbiBhY3Rpb24gZm9yIGEgZ2l2ZW4gdGVybWluYWwgQGludGVybmFsXG4gICAgaGFzQWN0aW9uKHN0YXRlLCB0ZXJtaW5hbCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBTa2lwICovIDogMSAvKiBBY3Rpb25zICovKSwgbmV4dDs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmICgobmV4dCA9IGRhdGFbaV0pID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGRhdGFbaSA9IHBhaXIoZGF0YSwgaSArIDIpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVtpICsgMV0gPT0gMiAvKiBPdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IHRlcm1pbmFsIHx8IG5leHQgPT0gMCAvKiBFcnIgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlU2xvdChzdGF0ZSwgc2xvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbKHN0YXRlICogNiAvKiBTaXplICovKSArIHNsb3RdO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGVGbGFnKHN0YXRlLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogRmxhZ3MgKi8pICYgZmxhZykgPiAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZmluZE5lc3RlZChzdGF0ZSkge1xuICAgICAgICBsZXQgZmxhZ3MgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMCAvKiBGbGFncyAqLyk7XG4gICAgICAgIHJldHVybiBmbGFncyAmIDQgLyogU3RhcnROZXN0ICovID8gdGhpcy5uZXN0ZWRbZmxhZ3MgPj4gMTAgLyogTmVzdFNoaWZ0ICovXSA6IG51bGw7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB2YWxpZEFjdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24gPT0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IHBhaXIodGhpcy5kYXRhLCBpICsgMSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgc3RhdGVzIHRoYXQgY2FuIGZvbGxvdyB0aGlzIG9uZSB0aHJvdWdoIHNoaWZ0IGFjdGlvbnMgb3JcbiAgICAvLy8gZ290byBqdW1wcy4gQGludGVybmFsXG4gICAgbmV4dFN0YXRlcyhzdGF0ZSkge1xuICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5uZXh0U3RhdGVDYWNoZVtzdGF0ZV07XG4gICAgICAgIGlmIChjYWNoZWQpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuZGF0YVtpICsgMl0gJiAoNjU1MzYgLyogUmVkdWNlRmxhZyAqLyA+PiAxNikpID09IDAgJiYgcmVzdWx0LmluZGV4T2YodGhpcy5kYXRhW2kgKyAxXSkgPCAwKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZGF0YVtpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bywgbWF4ID0gdGFibGVbMF07XG4gICAgICAgIGZvciAobGV0IHRlcm0gPSAwOyB0ZXJtIDwgbWF4OyB0ZXJtKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwVGFnID0gdGFibGVbcG9zKytdLCB0YXJnZXQgPSB0YWJsZVtwb3MrK107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZW5kID0gcG9zICsgKGdyb3VwVGFnID4+IDEpOyBwb3MgPCBlbmQ7IHBvcysrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSAmJiByZXN1bHQuaW5kZXhPZih0YXJnZXQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwVGFnICYgMSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFN0YXRlQ2FjaGVbc3RhdGVdID0gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgb3ZlcnJpZGVzKHRva2VuLCBwcmV2KSB7XG4gICAgICAgIGxldCBpUHJldiA9IGZpbmRPZmZzZXQodGhpcy5kYXRhLCB0aGlzLnRva2VuUHJlY1RhYmxlLCBwcmV2KTtcbiAgICAgICAgcmV0dXJuIGlQcmV2IDwgMCB8fCBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgdG9rZW4pIDwgaVByZXY7XG4gICAgfVxuICAgIC8vLyBDb25maWd1cmUgdGhlIHBhcnNlci4gUmV0dXJucyBhIG5ldyBwYXJzZXIgaW5zdGFuY2UgdGhhdCBoYXMgdGhlXG4gICAgLy8vIGdpdmVuIHNldHRpbmdzIG1vZGlmaWVkLiBTZXR0aW5ncyBub3QgcHJvdmlkZWQgaW4gYGNvbmZpZ2AgYXJlXG4gICAgLy8vIGtlcHQgZnJvbSB0aGUgb3JpZ2luYWwgcGFyc2VyLlxuICAgIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgLy8gSGlkZW91cyByZWZsZWN0aW9uLWJhc2VkIGtsdWRnZSB0byBtYWtlIGl0IGVhc3kgdG8gY3JlYXRlIGFcbiAgICAgICAgLy8gc2xpZ2h0bHkgbW9kaWZpZWQgY29weSBvZiBhIHBhcnNlci5cbiAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLm5lc3RlZClcbiAgICAgICAgICAgIGNvcHkubmVzdGVkID0gdGhpcy5uZXN0ZWQubWFwKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLm5lc3RlZCwgb2JqLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IG9iai5uYW1lLCB2YWx1ZTogY29uZmlnLm5lc3RlZFtvYmoubmFtZV0sIGVuZDogb2JqLmVuZCwgcGxhY2Vob2xkZXI6IG9iai5wbGFjZWhvbGRlciB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuc3RyaWN0ICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LnN0cmljdCA9IGNvbmZpZy5zdHJpY3Q7XG4gICAgICAgIGlmIChjb25maWcuYnVmZmVyTGVuZ3RoICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LmJ1ZmZlckxlbmd0aCA9IGNvbmZpZy5idWZmZXJMZW5ndGg7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZXJtLiBUaGlzIHdpbGwgb25seVxuICAgIC8vLyB3b3JrIGZvciBhbGwgdGVybXMgd2hlbiB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgd2l0aCB0aGVcbiAgICAvLy8gYC0tbmFtZXNgIG9wdGlvbi4gQnkgZGVmYXVsdCwgb25seSB0aGUgbmFtZXMgb2YgdGFnZ2VkIHRlcm1zIGFyZVxuICAgIC8vLyBzdG9yZWQuXG4gICAgZ2V0TmFtZSh0ZXJtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1OYW1lcyA/IHRoaXMudGVybU5hbWVzW3Rlcm1dIDogU3RyaW5nKHRlcm0gPD0gdGhpcy5tYXhOb2RlICYmIHRoaXMubm9kZVNldC50eXBlc1t0ZXJtXS5uYW1lIHx8IHRlcm0pO1xuICAgIH1cbiAgICAvLy8gVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgICAvLy8gdHlwZXMuIEBpbnRlcm5hbFxuICAgIGdldCBlb2ZUZXJtKCkgeyByZXR1cm4gdGhpcy5tYXhOb2RlICsgMTsgfVxuICAgIC8vLyBUZWxscyB5b3Ugd2hldGhlciB0aGlzIGdyYW1tYXIgaGFzIGFueSBuZXN0ZWQgZ3JhbW1hcnMuXG4gICAgZ2V0IGhhc05lc3RlZCgpIHsgcmV0dXJuIHRoaXMubmVzdGVkLmxlbmd0aCA+IDA7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZERpYWxlY3QgJiYgdGhpcy5jYWNoZWREaWFsZWN0LnNvdXJjZSA9PSBkaWFsZWN0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkRGlhbGVjdDtcbiAgICAgICAgbGV0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGlhbGVjdHMpLCBmbGFncyA9IHZhbHVlcy5tYXAoKCkgPT4gZmFsc2UpO1xuICAgICAgICBpZiAoZGlhbGVjdClcbiAgICAgICAgICAgIGZvciAobGV0IHBhcnQgb2YgZGlhbGVjdC5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB2YWx1ZXMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRpc2FibGVkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGlhbGVjdHNbdmFsdWVzW2ldXSwgaWQ7IChpZCA9IHRoaXMuZGF0YVtqKytdKSAhPSA2NTUzNSAvKiBFbmQgKi87KVxuICAgICAgICAgICAgICAgICAgICAoZGlzYWJsZWQgfHwgKGRpc2FibGVkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhUZXJtICsgMSkpKVtpZF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWREaWFsZWN0ID0gbmV3IERpYWxlY3QoZGlhbGVjdCwgZmxhZ3MsIGRpc2FibGVkKTtcbiAgICB9XG4gICAgLy8vICh1c2VkIGJ5IHRoZSBvdXRwdXQgb2YgdGhlIHBhcnNlciBnZW5lcmF0b3IpIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHNwZWMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhaXIoZGF0YSwgb2ZmKSB7IHJldHVybiBkYXRhW29mZl0gfCAoZGF0YVtvZmYgKyAxXSA8PCAxNik7IH1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogRW5kICovOyBpKyspXG4gICAgICAgIGlmIChuZXh0ID09IHRlcm0pXG4gICAgICAgICAgICByZXR1cm4gaSAtIHN0YXJ0O1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGZpbmRGaW5pc2hlZChzdGFja3MpIHtcbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGlmIChzdGFjay5wb3MgPT0gc3RhY2suY3guaW5wdXQubGVuZ3RoICYmXG4gICAgICAgICAgICBzdGFjay5jeC5wYXJzZXIuc3RhdGVGbGFnKHN0YWNrLnN0YXRlLCAyIC8qIEFjY2VwdGluZyAqLykgJiZcbiAgICAgICAgICAgICghYmVzdCB8fCBiZXN0LnNjb3JlIDwgc3RhY2suc2NvcmUpKVxuICAgICAgICAgICAgYmVzdCA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cblxuZXhwb3J0cy5Ob2RlUHJvcCA9IGxlemVyVHJlZS5Ob2RlUHJvcDtcbmV4cG9ydHMuTm9kZVNldCA9IGxlemVyVHJlZS5Ob2RlU2V0O1xuZXhwb3J0cy5Ob2RlVHlwZSA9IGxlemVyVHJlZS5Ob2RlVHlwZTtcbmV4cG9ydHMuVHJlZSA9IGxlemVyVHJlZS5UcmVlO1xuZXhwb3J0cy5UcmVlQ3Vyc29yID0gbGV6ZXJUcmVlLlRyZWVDdXJzb3I7XG5leHBvcnRzLkV4dGVybmFsVG9rZW5pemVyID0gRXh0ZXJuYWxUb2tlbml6ZXI7XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbmV4cG9ydHMuU3RhY2sgPSBTdGFjaztcbmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc3VuaU9wID0gZXhwb3J0cy5pc3NhbWVPcCA9IGV4cG9ydHMuaXNib29sT3AgPSBleHBvcnRzLmlzaW50T3AgPSBleHBvcnRzLmlzT3AgPSB2b2lkIDA7XG52YXIgaW50X29wcyA9IHsgXCIrXCI6IHRydWUsIFwiLVwiOiB0cnVlLCBcIipcIjogdHJ1ZSwgXCIvL1wiOiB0cnVlLCBcIiVcIjogdHJ1ZSxcbiAgICBcIj5cIjogdHJ1ZSwgXCI8XCI6IHRydWUsIFwiPj1cIjogdHJ1ZSwgXCI8PVwiOiB0cnVlIH07XG52YXIgc2FtZV9vcHMgPSB7IFwiPT1cIjogdHJ1ZSwgXCIhPVwiOiB0cnVlIH07XG52YXIgYm9vbF9vcHMgPSB7IFwiYW5kXCI6IHRydWUsIFwib3JcIjogdHJ1ZSB9O1xudmFyIHNwZWNfb3BzID0geyBcImlzXCI6IHRydWUgfTtcbnZhciB1bmlfb3BzID0geyBcIm5vdFwiOiB0cnVlLCBcIi1cIjogdHJ1ZSB9O1xuZnVuY3Rpb24gaXNPcChtYXliZU9wKSB7XG4gICAgcmV0dXJuIG1heWJlT3AgaW4gaW50X29wcyB8fCBtYXliZU9wIGluIGJvb2xfb3BzIHx8IG1heWJlT3AgaW4gc2FtZV9vcHMgfHwgbWF5YmVPcCBpbiBzcGVjX29wcztcbn1cbmV4cG9ydHMuaXNPcCA9IGlzT3A7XG5mdW5jdGlvbiBpc2ludE9wKG1heWJlT3ApIHtcbiAgICByZXR1cm4gbWF5YmVPcCBpbiBpbnRfb3BzO1xufVxuZXhwb3J0cy5pc2ludE9wID0gaXNpbnRPcDtcbmZ1bmN0aW9uIGlzYm9vbE9wKG1heWJlT3ApIHtcbiAgICByZXR1cm4gbWF5YmVPcCBpbiBib29sX29wcztcbn1cbmV4cG9ydHMuaXNib29sT3AgPSBpc2Jvb2xPcDtcbmZ1bmN0aW9uIGlzc2FtZU9wKG1heWJlT3ApIHtcbiAgICByZXR1cm4gbWF5YmVPcCBpbiBzYW1lX29wcztcbn1cbmV4cG9ydHMuaXNzYW1lT3AgPSBpc3NhbWVPcDtcbmZ1bmN0aW9uIGlzdW5pT3AobWF5YmVPcCkge1xuICAgIHJldHVybiBtYXliZU9wIGluIHVuaV9vcHM7XG59XG5leHBvcnRzLmlzdW5pT3AgPSBpc3VuaU9wO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcGlsZSA9IGV4cG9ydHMuY29kZUdlblN0bXQgPSBleHBvcnRzLmNvZGVHZW5DbGFzcyA9IGV4cG9ydHMuY29kZUdlbkZ1bkRlZiA9IGV4cG9ydHMuY29kZUdlbkV4cHIgPSBleHBvcnRzLm9wU3RtdHMgPSBleHBvcnRzLnJ1bndhdHNyYyA9IHZvaWQgMDtcbnZhciB3YWJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndhYnRcIikpO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xudmFyIHRjXzEgPSByZXF1aXJlKFwiLi90Y1wiKTtcbnZhciBsb29wX2NvdW50ZXIgPSAwO1xudmFyIG9ial9maWVsZF90eXBlX2lkeDtcbnZhciBjbGFzc2VzID0gbmV3IE1hcCgpO1xudmFyIG9ial9uYW1lX3JlZyA9IFwibm9uZVwiO1xudmFyIHRtcF92YXJzID0gW107XG52YXIgdW5hc3NpZ25lZF9jbHMgPSAwO1xudmFyIGRlY2xfb2ZfZnVuY3MgPSBbXTtcbmZ1bmN0aW9uIHZhcmlhYmxlTmFtZXMoc3RtdHMsIGNsYXNzX25hbWUpIHtcbiAgICBpZiAoY2xhc3NfbmFtZSA9PT0gdm9pZCAwKSB7IGNsYXNzX25hbWUgPSBcIlwiOyB9XG4gICAgdmFyIHZhcnMgPSBbXTtcbiAgICBzdG10cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICAgIGlmIChzdG10LnRhZyA9PT0gXCJhc3NpZ25cIiAmJiAhKHZhcnMuaW5jbHVkZXMoc3RtdC5uYW1lKSkpIHtcbiAgICAgICAgICAgIGlmIChjbGFzc19uYW1lICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB2YXJzLnB1c2goXCJcIi5jb25jYXQoY2xhc3NfbmFtZSwgXCIuXCIpLmNvbmNhdChzdG10Lm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhcnMucHVzaChzdG10Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhcnM7XG59XG5mdW5jdGlvbiBmdW5zKHN0bXRzKSB7XG4gICAgcmV0dXJuIHN0bXRzLmZpbHRlcihmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC50YWcgPT09IFwiZGVmaW5lXCI7IH0pO1xufVxuZnVuY3Rpb24gbm9uRnVucyhzdG10cykge1xuICAgIHJldHVybiBzdG10cy5maWx0ZXIoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudGFnICE9PSBcImRlZmluZVwiOyB9KTtcbn1cbmZ1bmN0aW9uIHZhcnNGdW5zU3RtdHMoc3RtdHMpIHtcbiAgICByZXR1cm4gW3ZhcmlhYmxlTmFtZXMoc3RtdHMpLCBmdW5zKHN0bXRzKSwgbm9uRnVucyhzdG10cyldO1xufVxuZnVuY3Rpb24gcnVud2F0c3JjKHdhdFNvdXJjZSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2FidEFwaSwgcGFyc2VkLCBiaW5hcnksIHdhc21Nb2R1bGU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCB3YWJ0XzEuZGVmYXVsdCkoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB3YWJ0QXBpID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSB3YWJ0QXBpLnBhcnNlV2F0KFwiZXhhbXBsZVwiLCB3YXRTb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBiaW5hcnkgPSBwYXJzZWQudG9CaW5hcnkoe30pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnkuYnVmZmVyLCBjb25maWcpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHdhc21Nb2R1bGUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB3YXNtTW9kdWxlLmluc3RhbmNlLmV4cG9ydHMuX3N0YXJ0KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucnVud2F0c3JjID0gcnVud2F0c3JjO1xuZnVuY3Rpb24gb3BTdG10cyhvcCkge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSBcIitcIjogcmV0dXJuIFtcImkzMi5hZGRcIl07XG4gICAgICAgIGNhc2UgXCItXCI6IHJldHVybiBbXCJpMzIuc3ViXCJdO1xuICAgICAgICBjYXNlIFwiKlwiOiByZXR1cm4gW1wiaTMyLm11bFwiXTtcbiAgICAgICAgY2FzZSBcIi8vXCI6IHJldHVybiBbXCJpMzIuZGl2X3NcIl07XG4gICAgICAgIGNhc2UgXCIlXCI6IHJldHVybiBbXCJpMzIucmVtX3NcIl07XG4gICAgICAgIGNhc2UgXCI+XCI6IHJldHVybiBbXCJpMzIuZ3Rfc1wiXTtcbiAgICAgICAgY2FzZSBcIjxcIjogcmV0dXJuIFtcImkzMi5sdF9zXCJdO1xuICAgICAgICBjYXNlIFwiPj1cIjogcmV0dXJuIFtcImkzMi5nZV9zXCJdO1xuICAgICAgICBjYXNlIFwiPD1cIjogcmV0dXJuIFtcImkzMi5sZV9zXCJdO1xuICAgICAgICBjYXNlIFwiPT1cIjogcmV0dXJuIFtcImkzMi5lcVwiXTtcbiAgICAgICAgY2FzZSBcIiE9XCI6IHJldHVybiBbXCJpMzIubmVcIl07XG4gICAgICAgIGNhc2UgXCJhbmRcIjogcmV0dXJuIFtcImkzMi5hbmRcIl07XG4gICAgICAgIGNhc2UgXCJvclwiOiByZXR1cm4gW1wiaTMyLm9yXCJdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0NvbXBpbGVyLnRzXVVuaGFuZGxlZCBvciB1bmtub3duIG9wOiBcIi5jb25jYXQob3ApKTtcbiAgICB9XG59XG5leHBvcnRzLm9wU3RtdHMgPSBvcFN0bXRzO1xuZnVuY3Rpb24gY29kZUdlbkV4cHIoZXhwciwgbG9jYWxzKSB7XG4gICAgdmFyIGVtcHR5RW52ID0gbmV3IE1hcCgpO1xuICAgIHN3aXRjaCAoZXhwci50YWcpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOiByZXR1cm4gW1wiKGkzMi5jb25zdCBcIi5jb25jYXQoZXhwci52YWx1ZSwgXCIpXCIpXTtcbiAgICAgICAgY2FzZSBcInRydWVcIjogcmV0dXJuIFtcIihpMzIuY29uc3QgMSlcIl07XG4gICAgICAgIGNhc2UgXCJmYWxzZVwiOiByZXR1cm4gW1wiKGkzMi5jb25zdCAwKVwiXTtcbiAgICAgICAgY2FzZSBcIm5vbmVcIjogcmV0dXJuIFtcIihpMzIuY29uc3QgMClcIl07XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgdHlwZS1jaGVja2VkIGZvciBtYWtpbmcgc3VyZSBhbGwgdmFyaWFibGUgZXhpc3QsIGhlcmUgd2VcbiAgICAgICAgICAgIC8vIGp1c3QgY2hlY2sgaWYgaXQncyBhIGxvY2FsIHZhcmlhYmxlIGFuZCBhc3N1bWUgaXQgaXMgZ2xvYmFsIGlmIG5vdFxuICAgICAgICAgICAgaWYgKGxvY2Fscy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCIobG9jYWwuZ2V0ICRcIi5jb25jYXQoZXhwci5uYW1lLCBcIilcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIihnbG9iYWwuZ2V0ICRcIi5jb25jYXQoZXhwci5uYW1lLCBcIilcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYmlub3BcIjoge1xuICAgICAgICAgICAgdmFyIGxoc0V4cHJzID0gY29kZUdlbkV4cHIoZXhwci5saHMsIGxvY2Fscyk7XG4gICAgICAgICAgICB2YXIgcmhzRXhwcnMgPSBjb2RlR2VuRXhwcihleHByLnJocywgbG9jYWxzKTtcbiAgICAgICAgICAgIGlmIChleHByLm9wID09ICdpcycpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbXBpbGVyIGxocy9yaHM6IFwiLCBleHByLmxocywgZXhwci5yaHMpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4cHIubGhzLmEgPT0gZXhwci5yaHMuYSwgZXhwci5saHMuYSA9PT0gZXhwci5yaHMuYSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIubGhzLmEgPT09IGV4cHIucmhzLmEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FtZSBsaWtlIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCIoaTMyLmNvbnN0IDEpXCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIihpMzIuY29uc3QgMClcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wc3RtdHMgPSBvcFN0bXRzKGV4cHIub3ApO1xuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBsaHNFeHBycywgdHJ1ZSksIHJoc0V4cHJzLCB0cnVlKSwgb3BzdG10cywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xhc3NlczpcIiwgY2xhc3Nlcyk7XG4gICAgICAgICAgICBpZiAoY2xhc3Nlcy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIEluc3RhbnRpYXRlIGEgbmV3IG9iaiBvZiBjbGFzcyAnZXhwci5uYW1lJ1xuICAgICAgICAgICAgICAgIHZhciBpbml0dmFscyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc2RhdGEgPSBjbGFzc2VzLmdldChleHByLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjbGFzc2RhdGEudGFnICE9IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGFzc2RhdGEgaGFzIGFuIG5vbi1jbGFzcyB0YWdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB3ZSBjb21waWxlIGl0cyBmaWVsZFxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqX25hbWVfcmVnID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGNsYXNzIHdpdGhvdXQgYW4gb2JqIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBfb2JqX25hbWUgPSBcIlJFU0VSVkVEX1wiLmNvbmNhdCh1bmFzc2lnbmVkX2Nscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHRtcCB2YXIgXCIuY29uY2F0KHRtcF9vYmpfbmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUTVBfVkFSUzogXCIuY29uY2F0KHRtcF92YXJzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBfdmFycy5wdXNoKHRtcF9vYmpfbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyX3B1c2hfdG1wX25hbWUgPSBcImdsb2JhbC5zZXQgJFwiLmNvbmNhdCh0bXBfb2JqX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZfb2JqX25hbWVfcmVnID0gb2JqX25hbWVfcmVnO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqX25hbWVfcmVnID0gdG1wX29ial9uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZGF0YS5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpbmRleCAqIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi50YWcgIT0gXCJhc3NpZ25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpZWxkIFwiLmNvbmNhdChmLCBcIiBkb2VzIG5vdCBoYXZlIGFuICdhc3NpZ24nIHRhZ1wiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsVG9CZSA9IGNvZGVHZW5FeHByKGYudmFsdWUsIGxvY2Fscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbFRvQmUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29tcGlsZWQgZmllbGRzIGlzIG5vdCBhIGxpdGVyYWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmpfZmllbGRfdHlwZV9pZHguZ2V0KGV4cHIubmFtZSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImRldGVjdCB1bmRlZmluZCBmb3IgT0ZJOiBcIi5jb25jYXQoZXhwci5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ial9maWVsZF90eXBlX2lkeC5zZXQoZXhwci5uYW1lLCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqX2ZpZWxkX3R5cGVfaWR4LmdldChvYmpfbmFtZV9yZWcpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqX2ZpZWxkX3R5cGVfaWR4LnNldChvYmpfbmFtZV9yZWcsIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWRkaW5nIHRoaXMgZW50cnk6XCIuY29uY2F0KGYubmFtZSwgXCIsXCIpLmNvbmNhdChpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ial9maWVsZF90eXBlX2lkeC5nZXQoZXhwci5uYW1lKS5zZXQoZi5uYW1lLCBbZi5hLCBpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ial9maWVsZF90eXBlX2lkeC5nZXQob2JqX25hbWVfcmVnKS5zZXQoZi5uYW1lLCBbZi5hLCBpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdHZhbHMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGluaXR2YWxzLCB0cnVlKSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKGdsb2JhbC5nZXQgJGhlYXApXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoaTMyLmFkZCAoaTMyLmNvbnN0IFwiLmNvbmNhdChvZmZzZXQsIFwiKSlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsVG9CZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImkzMi5zdG9yZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk9OUjpcIiwgb2JqX25hbWVfcmVnKTtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NkYXRhLm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAoZnVuYywgZl9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X25hbWUgPSBcIlwiLmNvbmNhdChmX25hbWUsIFwiJFwiKS5jb25jYXQob2JqX25hbWVfcmVnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdW5jX3N0cmluZyA9IGNvZGVHZW5GdW5EZWYoX19hc3NpZ24oX19hc3NpZ24oe30sIGZ1bmMpLCB7IG5hbWU6IG5ld19uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xfb2ZfZnVuY3MgPSBbZGVjbF9vZl9mdW5jcy5qb2luKCkgKyBmdW5jX3N0cmluZy5qb2luKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJET0Y6XCIsIGRlY2xfb2ZfZnVuY3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRfbWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NkYXRhLm1ldGhvZHMuaGFzKFwiX19pbml0X19cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRfbWV0aG9kID0gXCIoY2FsbCAkX19pbml0X18kXCIuY29uY2F0KG9ial9uYW1lX3JlZywgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY2xfb2ZfZnVuY3MgPSBkZWNsX29mX2Z1bmNzLmZsYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJET0YgYWZ0ZXIgZmxhdDpcIiwgZGVjbF9vZl9mdW5jcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X29ial9uYW1lX3JlZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpfbmFtZV9yZWcgPSBwcmV2X29ial9uYW1lX3JlZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuX3N0cjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuX3N0ciA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgaW5pdHZhbHMsIHRydWUpLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIihnbG9iYWwuZ2V0ICRoZWFwKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIoZ2xvYmFsLnNldCAkaGVhcCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkaGVhcCkgKGkzMi5jb25zdCBcIi5jb25jYXQoY2xhc3NkYXRhLmZpZWxkcy5sZW5ndGggKiA0LCBcIikpKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKGdsb2JhbC5zZXQgJFwiLmNvbmNhdChvYmpfbmFtZV9yZWcsIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICBdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU1RSIFRPIFBVU0hcIiwgc3RyX3B1c2hfdG1wX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyX3B1c2hfdG1wX25hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuX3N0ci5wdXNoKHN0cl9wdXNoX3RtcF9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdF9tZXRob2QgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5fc3RyLnB1c2goaW5pdF9tZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuX3N0ci5wdXNoKFwiKGxvY2FsLnNldCAkc2NyYXRjaClcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuX3N0ci5wdXNoKFwiKGdsb2JhbC5nZXQgJFwiLmNvbmNhdChvYmpfbmFtZV9yZWcsIFwiKVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5fc3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWxTdG10cyA9IGV4cHIuYXJncy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNvZGVHZW5FeHByKGUsIGxvY2Fscyk7IH0pLmZsYXQoKTtcbiAgICAgICAgICAgIHZhciB0b0NhbGwgPSBleHByLm5hbWU7XG4gICAgICAgICAgICBpZiAoZXhwci5uYW1lID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInBhcnNlIHByaW50LCBhID0gXCIgKyBleHByLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwci5hcmdzWzBdLmEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQ2FsbCA9IFwicHJpbnRfYm9vbFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQ2FsbCA9IFwicHJpbnRfbnVtXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQ2FsbCA9IFwicHJpbnRfbm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQUklOVCBFUlJPUjogYW5ub3RhdGlvbiA9IFwiLmNvbmNhdChleHByLmFyZ3NbMF0uYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsU3RtdHMucHVzaChcIihjYWxsICRcIi5jb25jYXQodG9DYWxsLCBcIilcIikpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codmFsU3RtdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbFN0bXRzO1xuICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICBpZiAoZXhwci50YWcgPT0gXCJtZXRob2RcIikge1xuICAgICAgICAgICAgICAgIC8vVHJpY2t5IGhlcmUsIHVzZSBlbXB0eSBlbnYgdG8gaW5pdFxuICAgICAgICAgICAgICAgIHZhciBhcmdJbnN0cnMgPSBleHByLmFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBjb2RlR2VuRXhwcihhLCBlbXB0eUVudik7IH0pLmZsYXQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub19vYmogPSBleHByLm9iai5hO1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2Rfc3VwcG9ydF90eXBlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAobWV0aG9kX3N1cHBvcnRfdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Rfc3VwcG9ydF90eXBlW21ldGhvZF9zdXBwb3J0X3R5cGVbXCJpZFwiXSA9IDBdID0gXCJpZFwiO1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Rfc3VwcG9ydF90eXBlW21ldGhvZF9zdXBwb3J0X3R5cGVbXCJtZXRob2RcIl0gPSAxXSA9IFwibWV0aG9kXCI7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZF9zdXBwb3J0X3R5cGVbbWV0aG9kX3N1cHBvcnRfdHlwZVtcImdldGZpZWxkXCJdID0gMl0gPSBcImdldGZpZWxkXCI7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZF9zdXBwb3J0X3R5cGVbbWV0aG9kX3N1cHBvcnRfdHlwZVtcImNhbGxcIl0gPSAzXSA9IFwiY2FsbFwiO1xuICAgICAgICAgICAgICAgIH0pKG1ldGhvZF9zdXBwb3J0X3R5cGUgfHwgKG1ldGhvZF9zdXBwb3J0X3R5cGUgPSB7fSkpO1xuICAgICAgICAgICAgICAgIGlmIChhbm5vX29iaiAhPSBcImludFwiICYmIGFubm9fb2JqICE9IFwibm9uZVwiICYmIGFubm9fb2JqICE9IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlb2JqID0gZXhwci5vYmo7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlb2JqX3N0bXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcF9uYW1lID0gb2JqX25hbWVfcmVnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW9iai50YWcgPT0gXCJpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHkgaXQgY2FuIGJlIGEgY2FsbFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZfbGVuZ3RoID0gdG1wX3ZhcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVvYmpfc3RtdCA9IGNvZGVHZW5FeHByKGVvYmosIGxvY2Fscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldl9sZW5ndGggIT0gdG1wX3ZhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wX25hbWUgPSB0bXBfdmFyc1t0bXBfdmFycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW9iai50YWcgPT0gJ3NlbGYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlb2JqID0geyB0YWc6ICdpZCcsIG5hbWU6IG9ial9uYW1lX3JlZywgYTogZW9iai5hIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVvYmoudGFnID09IFwiaWRcIiB8fCBlb2JqLnRhZyA9PSBcIm1ldGhvZFwiIHx8IGVvYmoudGFnID09IFwiZ2V0ZmllbGRcIiB8fCBlb2JqLnRhZyA9PSBcImNhbGxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZF9zdG10cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlb2JqX3N0bXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR290IHJlY3Vyc2l2ZSBleHByIGluIG9iajogdG1wX25hbWVcIiwgdG1wX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZF9zdG10cyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBlb2JqX3N0bXQsIHRydWUpLCBhcmdJbnN0cnMsIHRydWUpLCBbXCJjYWxsICRcIi5jb25jYXQoZXhwci5uYW1lLCBcIiRcIikuY29uY2F0KHRtcF9uYW1lKV0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZF9zdG10cyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYXJnSW5zdHJzLCB0cnVlKSwgW1wiY2FsbCAkXCIuY29uY2F0KGV4cHIubmFtZSwgXCIkXCIpLmNvbmNhdChlb2JqLm5hbWUpXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVyZSBvYmogdGFnIG11c3QgYmUgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJtZXRob2Rfc3RtdHM6XCIsIG1ldGhvZF9zdG10cyk7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kX3N0bXRzO1xuICAgICAgICBjYXNlIFwiZ2V0ZmllbGRcIjpcbiAgICAgICAgICAgIHZhciBhbm5vID0gZXhwci5vYmouYTtcbiAgICAgICAgICAgIGlmIChhbm5vICE9IFwiaW50XCIgJiYgYW5ubyAhPSBcIm5vbmVcIiAmJiBhbm5vICE9IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iamV4cHJzID0gY29kZUdlbkV4cHIoZXhwci5vYmosIGxvY2Fscyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGV4cHIub2JqLnRhZz09XCJzZWxmXCIpe1xuICAgICAgICAgICAgICAgIC8vICAgLy9kb25vdGhpbmdcbiAgICAgICAgICAgICAgICAvLyB9ZWxzZXtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIub2JqLnRhZyAhPSAnaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLm9iai50YWcgPT0gJ3NlbGYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByLmEgPSBvYmpfZmllbGRfdHlwZV9pZHguZ2V0KG9ial9uYW1lX3JlZykuZ2V0KGV4cHIubmFtZSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByLm9iaiA9IHsgdGFnOiAnaWQnLCBuYW1lOiBvYmpfbmFtZV9yZWcsIGE6IGV4cHIub2JqLmEgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iaiB0YWcgaXMgbm90ICdpZCcgb3IgJ3NlbGYnLCBpbnN0ZWFkIGl0J3MgXCIuY29uY2F0KGV4cHIub2JqLnRhZykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvYmpkYXRhID0gb2JqX2ZpZWxkX3R5cGVfaWR4LmdldChleHByLm9iai5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJVTlRJTUUgRVJST1I6IG9iamRhdGEgb2YgXCIuY29uY2F0KGV4cHIub2JqLm5hbWUsIFwiIGlzIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0ZmllbGQgXCIuY29uY2F0KGV4cHIubmFtZSwgXCIgb2YgXCIpLmNvbmNhdChleHByLm9iai5uYW1lLCBcIiwgb2JqZGF0YVwiKSk7XG4gICAgICAgICAgICAgICAgdmFyIGlvZiA9IG9iamRhdGEuZ2V0KGV4cHIubmFtZSlbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIihnbG9iYWwuZ2V0ICRcIi5jb25jYXQoZXhwci5vYmoubmFtZSwgXCIpXCIpLCBcIihpMzIuYWRkIChpMzIuY29uc3QgXCIuY29uY2F0KGlvZiAqIDQsIFwiKSlcIiksIFwiKGkzMi5sb2FkKVwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iaiBnZXQgYW4gYW5ub3RhdGlvbiBvZiBcIi5jb25jYXQoYW5ubykpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwic2VsZlwiOlxuICAgICAgICAgICAgaWYgKGxvY2Fscy5oYXMob2JqX25hbWVfcmVnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCIobG9jYWwuZ2V0ICRcIi5jb25jYXQob2JqX25hbWVfcmVnLCBcIilcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIihnbG9iYWwuZ2V0ICRcIi5jb25jYXQob2JqX25hbWVfcmVnLCBcIilcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwciBcIi5jb25jYXQoZXhwciwgXCIgbm90IGltcGxlbWVudGVkIVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5jb2RlR2VuRXhwciA9IGNvZGVHZW5FeHByO1xuZnVuY3Rpb24gY29kZUdlbkZ1bkRlZihtKSB7XG4gICAgdmFyIGVtcHR5RW52ID0gbmV3IE1hcCgpO1xuICAgIHZhciB3aXRoUGFyYW1zQW5kVmFyaWFibGVzID0gbmV3IE1hcChlbXB0eUVudi5lbnRyaWVzKCkpO1xuICAgIHZhciBpID0gbS5uYW1lLmluZGV4T2YoJyQnKTtcbiAgICBpZiAoaSAhPSAtMSkge1xuICAgICAgICB2YXIgcHJldl9vYmpfbmFtZV9yZWcgPSBvYmpfbmFtZV9yZWc7XG4gICAgICAgIG9ial9uYW1lX3JlZyA9IG0ubmFtZS5zbGljZShpICsgMSk7XG4gICAgfVxuICAgIC8vIENvbnN0cnVjdCB0aGUgZW52aXJvbm1lbnQgZm9yIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgdmFyIHZhcmlhYmxlcyA9IHZhcmlhYmxlTmFtZXMobS5ib2R5KTtcbiAgICB2YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gd2l0aFBhcmFtc0FuZFZhcmlhYmxlcy5zZXQodiwgdHJ1ZSk7IH0pO1xuICAgIG0ucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHdpdGhQYXJhbXNBbmRWYXJpYWJsZXMuc2V0KHAubmFtZSwgdHJ1ZSk7IH0pO1xuICAgIC8vIENvbnN0cnVjdCB0aGUgY29kZSBmb3IgcGFyYW1zIGFuZCB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgaW4gdGhlIGJvZHlcbiAgICB2YXIgcGFyYW1zID0gbS5wYXJhbXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIC8vSWdub3JlIHNlbGZcbiAgICAgICAgaWYgKHAubmFtZSAhPSBcInNlbGZcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiKHBhcmFtICRcIi5jb25jYXQocC5uYW1lLCBcIiBpMzIpXCIpO1xuICAgICAgICB9XG4gICAgfSkuam9pbihcIiBcIik7XG4gICAgdmFyIHZhckRlY2xzID0gdmFyaWFibGVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gXCIobG9jYWwgJFwiLmNvbmNhdCh2LCBcIiBpMzIpXCIpOyB9KS5qb2luKFwiXFxuXCIpO1xuICAgIC8vIFZlcnkgVHJpY2t5IGhlcmUsIHdlIGlnbm9yZSB0aGUgZ2xvYmFsIHZhcmlhYmxlXG4gICAgdmFyIHN0bXRzID0gbS5ib2R5Lm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gY29kZUdlblN0bXQocywgd2l0aFBhcmFtc0FuZFZhcmlhYmxlcywgZW1wdHlFbnYpOyB9KS5mbGF0KCk7XG4gICAgdmFyIHN0bXRzQm9keSA9IHN0bXRzLmpvaW4oXCJcXG5cIik7XG4gICAgaWYgKHByZXZfb2JqX25hbWVfcmVnICE9PSB1bmRlZmluZWQgJiYgcHJldl9vYmpfbmFtZV9yZWcgIT0gb2JqX25hbWVfcmVnKSB7XG4gICAgICAgIG9ial9uYW1lX3JlZyA9IHByZXZfb2JqX25hbWVfcmVnO1xuICAgIH1cbiAgICByZXR1cm4gW1wiKGZ1bmMgJFwiLmNvbmNhdChtLm5hbWUsIFwiIFwiKS5jb25jYXQocGFyYW1zLCBcIiAocmVzdWx0IGkzMilcXG4gICAgICAgIChsb2NhbCAkc2NyYXRjaCBpMzIpXFxuICAgICAgICBcIikuY29uY2F0KHZhckRlY2xzLCBcIlxcbiAgICAgICAgXCIpLmNvbmNhdChzdG10c0JvZHksIFwiXFxuICAgICAgICAoaTMyLmNvbnN0IDApKVwiKV07XG59XG5leHBvcnRzLmNvZGVHZW5GdW5EZWYgPSBjb2RlR2VuRnVuRGVmO1xuZnVuY3Rpb24gY29kZUdlbkNsYXNzKGMpIHtcbiAgICAvLyBDdXJyZW50bHkgZG8gbm90IHdhbnQgYWRkIGFueSBnbG9iYWxzIHdoZW4gZ2VuZXJhdGluZyBjbGFzc1xuICAgIHZhciBtZXRob2RzID0gW107XG4gICAgaWYgKGMudGFnICE9IFwiY2xhc3NcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDR0MgRVJST1I6IFN0YXRlbWVudCB0YWcgaXMgbm90ICdjbGFzcycsIHNob3VsZCBub3QgY2FsbCBDR0NcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjLm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobSwgaSkge1xuICAgICAgICAgICAgdmFyIHRoaXNfZnVuID0gY29kZUdlbkZ1bkRlZihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbSksIHsgbmFtZTogXCIkXCIuY29uY2F0KG0ubmFtZSwgXCIkXCIpLmNvbmNhdChjLm5hbWUpIH0pKTtcbiAgICAgICAgICAgIG1ldGhvZHMuY29uY2F0KHRoaXNfZnVuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGhvZHMgPSBtZXRob2RzLmZsYXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZHM7XG59XG5leHBvcnRzLmNvZGVHZW5DbGFzcyA9IGNvZGVHZW5DbGFzcztcbmZ1bmN0aW9uIGNvZGVHZW5TdG10KHN0bXQsIGxvY2FscywgZ2xvYmFsX3ZhcnMpIHtcbiAgICB2YXIgd2l0aFBhcmFtc0FuZFZhcmlhYmxlcyA9IG5ldyBNYXAobG9jYWxzLmVudHJpZXMoKSk7XG4gICAgdmFyIGVtcHR5RW52ID0gbmV3IE1hcCgpO1xuICAgIHN3aXRjaCAoc3RtdC50YWcpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAvLyBwdXNoIGNsYXNzX25hbWUgdG8gY2xhc3Nlc1xuICAgICAgICAgICAgY2xhc3Nlcy5zZXQoc3RtdC5uYW1lLCBzdG10KTtcbiAgICAgICAgICAgIC8vIHNldCBjbGFzcyBuYW1lIHJlZyB0byBlbmFibGUgc2VsZi1wYXJzaW5nXG4gICAgICAgICAgICAvLyBjbHNfbmFtZV9yZWcgPSBzdG10Lm5hbWU7XG4gICAgICAgICAgICAvLyAvLyBjb25zdHJ1Y3QgY2xhc3MgdmFyaWFibGVzXG4gICAgICAgICAgICAvLyBjb25zdCBjbHNfdmFycyA9IHZhcmlhYmxlTmFtZXMoc3RtdC5maWVsZHMsc3RtdC5uYW1lKTtcbiAgICAgICAgICAgIC8vIGNsc192YXJzLmZvckVhY2godiA9PiB3aXRoUGFyYW1zQW5kVmFyaWFibGVzLnNldCh2LCB0cnVlKSk7XG4gICAgICAgICAgICAvLyAvL0NvbnN0cnVjdCBtZXRob2RzIGZvciBlYWNoIGNsYXNzXG4gICAgICAgICAgICAvLyBjb25zdCB2YXJEZWNsQ2xzID0gY2xzX3ZhcnMubWFwKGN2ID0+IGBsb2NhbCAkJHtjdn0gaTMyYCkuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgIC8vIC8vIE5PVEU6IHZlcnkgdHJpY2t5IGhlcmUsIHdlIGp1c3QgZG9uJ3QgcGFzcyBnbG9iYWwgZW52IHRvIGNvZGUgZ2VuIHdoZW4gZ2VuIGNsYXNzIG1ldGhvZHNcbiAgICAgICAgICAgIC8vIC8vIE5PVEU6IDA0MjYsIGV2ZW4gbW9yZSB0cmlja3ksIGhhdmUgdG8gY29udmVydCBtYXAgaW50byBhIGxpc3RcbiAgICAgICAgICAgIC8vIGNvbnN0IGZ1bmNDbHMgPSBjb2RlR2VuQ2xhc3Moc3RtdClcbiAgICAgICAgICAgIC8vIGNvbnN0IGZ1bmNDbHNCb2R5ID0gZnVuY0Nscy5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgLy8gLy9SZXNldCBjbGFzcyBuYW1lIHJlZ1xuICAgICAgICAgICAgLy8gY2xzX25hbWVfcmVnID0gXCJub25lXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJkZWZpbmVcIjpcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgZW52aXJvbm1lbnQgZm9yIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICAgICAgICB2YXIgdmFyaWFibGVzID0gdmFyaWFibGVOYW1lcyhzdG10LmJvZHkpO1xuICAgICAgICAgICAgdmFyaWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHdpdGhQYXJhbXNBbmRWYXJpYWJsZXMuc2V0KHYsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIHN0bXQucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHdpdGhQYXJhbXNBbmRWYXJpYWJsZXMuc2V0KHAubmFtZSwgdHJ1ZSk7IH0pO1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBjb2RlIGZvciBwYXJhbXMgYW5kIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBpbiB0aGUgYm9keVxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHN0bXQucGFyYW1zLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gXCIocGFyYW0gJFwiLmNvbmNhdChwLm5hbWUsIFwiIGkzMilcIik7IH0pLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgdmFyIHZhckRlY2xzID0gdmFyaWFibGVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gXCIobG9jYWwgJFwiLmNvbmNhdCh2LCBcIiBpMzIpXCIpOyB9KS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgdmFyIHN0bXRzID0gc3RtdC5ib2R5Lm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gY29kZUdlblN0bXQocywgd2l0aFBhcmFtc0FuZFZhcmlhYmxlcywgZ2xvYmFsX3ZhcnMpOyB9KS5mbGF0KCk7XG4gICAgICAgICAgICB2YXIgc3RtdHNCb2R5ID0gc3RtdHMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgIHJldHVybiBbXCIoZnVuYyAkXCIuY29uY2F0KHN0bXQubmFtZSwgXCIgXCIpLmNvbmNhdChwYXJhbXMsIFwiIChyZXN1bHQgaTMyKVxcbiAgICAgICAgKGxvY2FsICRzY3JhdGNoIGkzMilcXG4gICAgICAgIFwiKS5jb25jYXQodmFyRGVjbHMsIFwiXFxuICAgICAgICBcIikuY29uY2F0KHN0bXRzQm9keSwgXCJcXG4gICAgICAgIChpMzIuY29uc3QgMCkpXCIpXTtcbiAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgICAgdmFyIHZhbFN0bXRzID0gY29kZUdlbkV4cHIoc3RtdC52YWx1ZSwgbG9jYWxzKTtcbiAgICAgICAgICAgIHZhbFN0bXRzLnB1c2goXCJyZXR1cm5cIik7XG4gICAgICAgICAgICByZXR1cm4gdmFsU3RtdHM7XG4gICAgICAgIGNhc2UgXCJhc3NpZ25cIjpcbiAgICAgICAgICAgIHZhciBvZmkgPSBvYmpfZmllbGRfdHlwZV9pZHg7XG4gICAgICAgICAgICBpZiAoc3RtdC52YWx1ZS50YWcgPT0gJ2NhbGwnICYmIGNsYXNzZXMuaGFzKHN0bXQudmFsdWUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY3JlYXRpbmcgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGluZyBvYmplY3QgXCIuY29uY2F0KHN0bXQubmFtZSwgXCIgZnJvbSBcIikuY29uY2F0KHN0bXQudmFsdWUubmFtZSkpO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2X29ial9uYW1lX3JlZyA9IG9ial9uYW1lX3JlZztcbiAgICAgICAgICAgICAgICBvYmpfbmFtZV9yZWcgPSBzdG10Lm5hbWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwcmV2X29ialwiLCBwcmV2X29ial9uYW1lX3JlZywgXCJvYmpcIiwgb2JqX25hbWVfcmVnKTtcbiAgICAgICAgICAgICAgICB2YXIgc3ZuID0gc3RtdC52YWx1ZS5uYW1lO1xuICAgICAgICAgICAgICAgIG9maS5zZXQoc3RtdC5uYW1lLCBvZmkuZ2V0KHN2bikpO1xuICAgICAgICAgICAgICAgIG9maS5kZWxldGUoc3ZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LnZhbHVlLmhhc093blByb3BlcnR5KCdhJykgJiYgKDAsIHRjXzEuaXNPYmplY3QpKHN0bXQudmFsdWUuYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hhbGxvdyBjb3B5IG9iamVjdCB0byBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQudmFsdWUudGFnID09ICdpZCcgJiYgb2ZpLmhhcyhzdG10LnZhbHVlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ZuID0gc3RtdC52YWx1ZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2ZpLnNldChzdG10Lm5hbWUsIG9maS5nZXQoc3ZuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgdG8gY29weSBvYmplY3QsYnV0IFwiLmNvbmNhdChzdG10LnZhbHVlLCBcIiBpcyBOT1QgYW4gb2JqZWN0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWxTdG10cyA9IGNvZGVHZW5FeHByKHN0bXQudmFsdWUsIGxvY2Fscyk7XG4gICAgICAgICAgICBpZiAoc3RtdC5uYW1lLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIERlYWwgd2l0aCBTZXRmaWVsZFxuICAgICAgICAgICAgICAgIHZhciBvYmpfbmFtZSA9IHN0bXQubmFtZS5zcGxpdCgnLicsIDIpWzBdO1xuICAgICAgICAgICAgICAgIGlmIChvYmpfbmFtZSA9PSAnc2VsZicpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqX25hbWUgPSBvYmpfbmFtZV9yZWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmbGRfbmFtZSA9IHN0bXQubmFtZS5zcGxpdCgnLicsIDIpWzFdO1xuICAgICAgICAgICAgICAgIHZhciBpb2YgPSBvYmpfZmllbGRfdHlwZV9pZHguZ2V0KG9ial9uYW1lKS5nZXQoZmxkX25hbWUpWzFdO1xuICAgICAgICAgICAgICAgIHZhciBsc3Rfb2Zfc3RtdHMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW1xuICAgICAgICAgICAgICAgICAgICBcIihnbG9iYWwuZ2V0ICRcIi5jb25jYXQob2JqX25hbWUsIFwiKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgXCIoaTMyLmFkZCAoaTMyLmNvbnN0IFwiLmNvbmNhdChpb2YgKiA0LCBcIikpXCIpXG4gICAgICAgICAgICAgICAgXSwgdmFsU3RtdHMsIHRydWUpLCBbXG4gICAgICAgICAgICAgICAgICAgIFwiaTMyLnN0b3JlXCJcbiAgICAgICAgICAgICAgICBdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdmFsU3RtdHMgPSBsc3Rfb2Zfc3RtdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxzLmhhcyhzdG10Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFN0bXRzLnB1c2goXCIobG9jYWwuc2V0ICRcIi5jb25jYXQoc3RtdC5uYW1lLCBcIilcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVhbGluZyB3aXRoIGdsb2JhbHNcbiAgICAgICAgICAgICAgICAgICAgdmFsU3RtdHMucHVzaChcIihnbG9iYWwuc2V0ICRcIi5jb25jYXQoc3RtdC5uYW1lLCBcIilcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2X29ial9uYW1lX3JlZyAhPT0gdW5kZWZpbmVkICYmIHByZXZfb2JqX25hbWVfcmVnICE9IG9ial9uYW1lX3JlZykge1xuICAgICAgICAgICAgICAgIG9ial9uYW1lX3JlZyA9IHByZXZfb2JqX25hbWVfcmVnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBRlRFUjogcHJldl9vYmpcIiwgcHJldl9vYmpfbmFtZV9yZWcsIFwib2JqXCIsIG9ial9uYW1lX3JlZyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsU3RtdHM7XG4gICAgICAgIGNhc2UgXCJleHByXCI6XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29kZUdlbkV4cHIoc3RtdC5leHByLCBsb2NhbHMpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCIobG9jYWwuc2V0ICRzY3JhdGNoKVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNhc2UgXCJwYXNzXCI6XG4gICAgICAgICAgICB2YXIgZG9ub3RoaW5nID0gW107XG4gICAgICAgICAgICByZXR1cm4gZG9ub3RoaW5nO1xuICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgIC8vICB7IGE/OiBBLCB0YWc6IFwiaWZcIiwgY29uZDogRXhwcjxBPiwgYm9keTogU3RtdDxBPltdLCBlbHNlX2JvZHk6IFN0bXQ8QT5bXX1cbiAgICAgICAgICAgIHZhciBjb25kRXhwciA9IGNvZGVHZW5FeHByKHN0bXQuY29uZCwgbG9jYWxzKTsgLy9nZW5lcmF0ZSBjb25kaXRpb25cbiAgICAgICAgICAgIHZhciBvdXQgPSBjb25kRXhwci5jb25jYXQoW1wiKGlmXCJdKS5jb25jYXQoW1wiKHRoZW5cIl0pO1xuICAgICAgICAgICAgdmFyIGJvZHlfc3RtdHMgPSBzdG10LmJvZHkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiAoY29kZUdlblN0bXQocywgbG9jYWxzLCBnbG9iYWxfdmFycykpLmZsYXQoKS5qb2luKFwiXFxuXCIpOyB9KTsgLy9nZW5lcmF0ZSB0aGVuIGJvZHlcbiAgICAgICAgICAgIG91dCA9IG91dC5jb25jYXQoYm9keV9zdG10cykuY29uY2F0KFtcIilcIl0pO1xuICAgICAgICAgICAgaWYgKHN0bXQuZWxzZV9ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KFwiKGVsc2VcIik7XG4gICAgICAgICAgICAgICAgdmFyIGVsc2Vfc3RtdHMgPSBzdG10LmVsc2VfYm9keS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChjb2RlR2VuU3RtdChzLCBsb2NhbHMsIGdsb2JhbF92YXJzKSkuZmxhdCgpLmpvaW4oXCJcXG5cIik7IH0pOyAvL2dlbmVyYXRlIHRoZSBlbHNlIGJvZHlcbiAgICAgICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KGVsc2Vfc3RtdHMpLmNvbmNhdChcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2VuZCB0aGUgaWYgc3RhdGVtZW50XG4gICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KFtcIilcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgY2FzZSBcIndoaWxlXCI6XG4gICAgICAgICAgICAvLyB7IGE/OiBBLCB0YWc6IFwid2hpbGVcIixjb25kOiBFeHByIDxBPiwgYm9keTogU3RtdDxBPltdfVxuICAgICAgICAgICAgdmFyIGNvbmR3aGlsZSA9IGNvZGVHZW5FeHByKHN0bXQuY29uZCwgbG9jYWxzKTtcbiAgICAgICAgICAgIHZhciB3aGlsZW91dCA9IGNvbmR3aGlsZS5jb25jYXQoW1wiKGlmXCJdKS5jb25jYXQoW1wiKHRoZW5cIl0pO1xuICAgICAgICAgICAgLy8gTmVlZCB0byBjaGVjayB0aGUgY29uZCBiZWZvcmUgZW50ZXIgdGhpcyBsb29wXG4gICAgICAgICAgICB3aGlsZW91dCA9IHdoaWxlb3V0LmNvbmNhdChbXCIobG9vcCAkbXlMb29wXCIuY29uY2F0KGxvb3BfY291bnRlcildKTtcbiAgICAgICAgICAgIHZhciBib2R5X3N0bXRzID0gc3RtdC5ib2R5Lm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gKGNvZGVHZW5TdG10KHMsIGxvY2FscywgZ2xvYmFsX3ZhcnMpKS5mbGF0KCkuam9pbihcIlxcblwiKTsgfSk7XG4gICAgICAgICAgICB3aGlsZW91dCA9IHdoaWxlb3V0LmNvbmNhdChib2R5X3N0bXRzKTtcbiAgICAgICAgICAgIHdoaWxlb3V0ID0gd2hpbGVvdXQuY29uY2F0KGNvbmR3aGlsZSkuY29uY2F0KFtcImJyX2lmICRteUxvb3BcIi5jb25jYXQobG9vcF9jb3VudGVyKV0pO1xuICAgICAgICAgICAgLy9FbmRsb29wXG4gICAgICAgICAgICB3aGlsZW91dCA9IHdoaWxlb3V0LmNvbmNhdChbXCIpXCJdKTtcbiAgICAgICAgICAgIC8vRW5kd2hpbGUoXG4gICAgICAgICAgICB3aGlsZW91dCA9IHdoaWxlb3V0LmNvbmNhdChbXCIpXCJdKS5jb25jYXQoW1wiKVwiXSk7XG4gICAgICAgICAgICBsb29wX2NvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiB3aGlsZW91dDtcbiAgICB9XG59XG5leHBvcnRzLmNvZGVHZW5TdG10ID0gY29kZUdlblN0bXQ7XG5mdW5jdGlvbiBjb21waWxlKHNvdXJjZSkge1xuICAgIHZhciBhc3QgPSAoMCwgcGFyc2VyXzEucGFyc2VQcm9ncmFtKShzb3VyY2UpO1xuICAgIG9ial9maWVsZF90eXBlX2lkeCA9IG5ldyBNYXAoKTtcbiAgICBjb25zb2xlLmxvZyhcInBhcnNlZCBwcm9ncmFtLCBhc3Q6XCIsIGFzdCk7XG4gICAgYXN0ID0gKDAsIHRjXzEudGNQcm9ncmFtKShhc3QpO1xuICAgIGNvbnNvbGUubG9nKFwiYWZ0ZXIgdGMsIGFzdDpcIiwgYXN0KTtcbiAgICBkZWNsX29mX2Z1bmNzID0gW107XG4gICAgdmFyIGVtcHR5RW52ID0gbmV3IE1hcCgpO1xuICAgIHRtcF92YXJzID0gW107XG4gICAgdmFyIF9hID0gdmFyc0Z1bnNTdG10cyhhc3QpLCB2YXJzID0gX2FbMF0sIGZ1bnMgPSBfYVsxXSwgc3RtdHMgPSBfYVsyXTtcbiAgICB2YXIgZnVuc0NvZGUgPSBmdW5zLm1hcChmdW5jdGlvbiAoZikgeyByZXR1cm4gY29kZUdlblN0bXQoZiwgZW1wdHlFbnYsIGVtcHR5RW52KTsgfSkubWFwKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLmpvaW4oXCJcXG5cIik7IH0pO1xuICAgIHZhciBhbGxGdW5zID0gZnVuc0NvZGUuam9pbihcIlxcblxcblwiKTtcbiAgICB2YXIgdmFyRGVjbHMgPSB2YXJzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gXCIoZ2xvYmFsICRcIi5jb25jYXQodiwgXCIgKG11dCBpMzIpIChpMzIuY29uc3QgMCkpXCIpOyB9KS5qb2luKFwiXFxuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiY29tcGlsZS1zdG10czpcIiwgc3RtdHMpO1xuICAgIHZhciBhbGxTdG10cyA9IHN0bXRzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gY29kZUdlblN0bXQocywgZW1wdHlFbnYsIGVtcHR5RW52KTsgfSkuZmxhdCgpO1xuICAgIHZhciBtYWluID0gX19zcHJlYWRBcnJheShbXCIobG9jYWwgJHNjcmF0Y2ggaTMyKVwiXSwgYWxsU3RtdHMsIHRydWUpLmpvaW4oXCJcXG5cIik7XG4gICAgdmFyIGxhc3RTdG10ID0gYXN0W2FzdC5sZW5ndGggLSAxXTtcbiAgICB2YXIgaXNFeHByID0gbGFzdFN0bXQudGFnID09PSBcImV4cHJcIjtcbiAgICB2YXIgcmV0VHlwZSA9IFwiXCI7XG4gICAgdmFyIHJldFZhbCA9IFwiXCI7XG4gICAgaWYgKGlzRXhwcikge1xuICAgICAgICByZXRUeXBlID0gXCIocmVzdWx0IGkzMilcIjtcbiAgICAgICAgcmV0VmFsID0gXCIobG9jYWwuZ2V0ICRzY3JhdGNoKVwiO1xuICAgIH1cbiAgICB2YXIgdG1wdmFyRGVjbHMgPSB0bXBfdmFycy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFwiKGdsb2JhbCAkXCIuY29uY2F0KHYsIFwiIChtdXQgaTMyKSAoaTMyLmNvbnN0IDApKVwiKTsgfSkuam9pbihcIlxcblwiKTtcbiAgICByZXR1cm4gXCJcXG4gICAgKG1vZHVsZVxcbiAgICAgIChmdW5jICRwcmludF9udW0gKGltcG9ydCBcXFwiaW1wb3J0c1xcXCIgXFxcInByaW50X251bVxcXCIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcXG4gICAgICAoZnVuYyAkcHJpbnRfYm9vbCAoaW1wb3J0IFxcXCJpbXBvcnRzXFxcIiBcXFwicHJpbnRfYm9vbFxcXCIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcXG4gICAgICAoZnVuYyAkcHJpbnRfbm9uZSAoaW1wb3J0IFxcXCJpbXBvcnRzXFxcIiBcXFwicHJpbnRfbm9uZVxcXCIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcXG4gICAgICAobWVtb3J5IChpbXBvcnQgXFxcImltcG9ydHNcXFwiIFxcXCJtZW1cXFwiKSAxKVxcbiAgICAgIChnbG9iYWwgJGhlYXAgKG11dCBpMzIpIChpMzIuY29uc3QgNCkpXFxuICAgICAgXCIuY29uY2F0KHZhckRlY2xzLCBcIlxcbiAgICAgIFwiKS5jb25jYXQodG1wdmFyRGVjbHMsIFwiXFxuICAgICAgXCIpLmNvbmNhdChkZWNsX29mX2Z1bmNzLCBcIlxcbiAgICAgIFwiKS5jb25jYXQoYWxsRnVucywgXCJcXG4gICAgICAoZnVuYyAoZXhwb3J0IFxcXCJfc3RhcnRcXFwiKSBcIikuY29uY2F0KHJldFR5cGUsIFwiXFxuICAgICAgICBcIikuY29uY2F0KG1haW4sIFwiXFxuICAgICAgICBcIikuY29uY2F0KHJldFZhbCwgXCJcXG4gICAgICApXFxuICAgICkgXFxuICBcIik7XG59XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlID0gZXhwb3J0cy50cmF2ZXJzZSA9IGV4cG9ydHMudHJhdmVyc2VBcmd1bWVudHMgPSBleHBvcnRzLnRyYXZlcnNlRXhwciA9IGV4cG9ydHMudHJhdmVyc2VQYXJhbWV0ZXJzID0gZXhwb3J0cy50cmF2ZXJzZVR5cGUgPSBleHBvcnRzLnRyYXZlcnNlU3RtdCA9IGV4cG9ydHMudHJhdmVyc2VTdG10cyA9IGV4cG9ydHMucGFyc2VQcm9ncmFtID0gdm9pZCAwO1xudmFyIGxlemVyX3B5dGhvbl8xID0gcmVxdWlyZShcImxlemVyLXB5dGhvblwiKTtcbnZhciBhc3RfMSA9IHJlcXVpcmUoXCIuL2FzdFwiKTtcbnZhciBzdXBwb3J0ZWRUeXBlcyA9IFtcImludFwiLCBcIm5vbmVcIiwgXCJib29sXCJdO1xudmFyIGNsc19uYW1lX3JlZyA9IFwibm9uZVwiO1xuZnVuY3Rpb24gcGFyc2VQcm9ncmFtKHNvdXJjZSkge1xuICAgIHZhciB0ID0gbGV6ZXJfcHl0aG9uXzEucGFyc2VyLnBhcnNlKHNvdXJjZSkuY3Vyc29yKCk7XG4gICAgcmV0dXJuIHRyYXZlcnNlU3RtdHMoc291cmNlLCB0KTtcbn1cbmV4cG9ydHMucGFyc2VQcm9ncmFtID0gcGFyc2VQcm9ncmFtO1xuZnVuY3Rpb24gdHJhdmVyc2VTdG10cyhzLCB0KSB7XG4gICAgLy8gVGhlIHRvcCBub2RlIGluIHRoZSBwcm9ncmFtIGlzIGEgU2NyaXB0IG5vZGUgd2l0aCBhIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICAvLyB0aGF0IGFyZSB2YXJpb3VzIHN0YXRlbWVudHNcbiAgICB0LmZpcnN0Q2hpbGQoKTtcbiAgICB2YXIgc3RtdHMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIHN0bXRzLnB1c2godHJhdmVyc2VTdG10KHMsIHQpKTtcbiAgICB9IHdoaWxlICh0Lm5leHRTaWJsaW5nKCkpOyAvLyB0Lm5leHRTaWJsaW5nKCkgcmV0dXJucyBmYWxzZSB3aGVuIGl0IHJlYWNoZXNcbiAgICAvLyAgdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgIHQucGFyZW50KCk7XG4gICAgcmV0dXJuIHN0bXRzO1xufVxuZXhwb3J0cy50cmF2ZXJzZVN0bXRzID0gdHJhdmVyc2VTdG10cztcbi8qXG4gIEludmFyaWFudCDigJMgdCBtdXN0IGZvY3VzIG9uIHRoZSBzYW1lIG5vZGUgYXQgdGhlIGVuZCBvZiB0aGUgdHJhdmVyc2FsXG4qL1xuZnVuY3Rpb24gdHJhdmVyc2VTdG10KHMsIHQpIHtcbiAgICBzd2l0Y2ggKHQudHlwZS5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJSZXR1cm5TdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyByZXR1cm4ga2V5d29yZFxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBleHByZXNzaW9uXG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICBpZiAocy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB7IHRhZzogXCJub25lXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJyZXR1cm5cIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIGNhc2UgXCJBc3NpZ25TdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBmb2N1c2VkIG9uIG5hbWUgKHRoZSBmaXJzdCBjaGlsZClcbiAgICAgICAgICAgIHZhciBuYW1lID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gZm9jdXNlZCBvbiA6dHlwZSBwYXJ0LCBleHBsYWluZWQgaW4gQ2hvY29weVxuICAgICAgICAgICAgdmFyIGFubm8gPSBzLnN1YnN0cmluZyh0LmZyb20gKyAxLCB0LnRvKS50cmltKCk7IC8vIFVzZSArMiB0byBza2lwIHRoZSA6XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIGZvY3VzZWQgb24gPSBzaWduLiBNYXkgbmVlZCB0aGlzIGZvciBjb21wbGV4IHRhc2tzLCBsaWtlICs9IVxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBmb2N1c2VkIG9uIHRoZSB2YWx1ZSBleHByZXNzaW9uXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBc3NpZ24tcmV0dXJuOlwiLCB7IGE6IGFubm8sIHRhZzogXCJhc3NpZ25cIiwgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgYTogYW5ubywgdGFnOiBcImFzc2lnblwiLCBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgY2FzZSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBUaGUgY2hpbGQgaXMgc29tZSBraW5kIG9mIGV4cHJlc3Npb24sIHRoZVxuICAgICAgICAgICAgLy8gRXhwcmVzc2lvblN0YXRlbWVudCBpcyBqdXN0IGEgd3JhcHBlciB3aXRoIG5vIGluZm9ybWF0aW9uXG4gICAgICAgICAgICB2YXIgZXhwciA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiZXhwclwiLCBleHByOiBleHByIH07XG4gICAgICAgIGNhc2UgXCJGdW5jdGlvbkRlZmluaXRpb25cIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyBvbiBkZWZcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gbmFtZSBvZiBmdW5jdGlvblxuICAgICAgICAgICAgdmFyIG5hbWUgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBQYXJhbUxpc3RcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB0cmF2ZXJzZVBhcmFtZXRlcnMocywgdCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIEJvZHkgb3IgVHlwZURlZlxuICAgICAgICAgICAgdmFyIHJldCA9IFwibm9uZVwiO1xuICAgICAgICAgICAgdmFyIG1heWJlVEQgPSB0O1xuICAgICAgICAgICAgaWYgKG1heWJlVEQudHlwZS5uYW1lID09PSBcIlR5cGVEZWZcIikge1xuICAgICAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgICAgIHJldCA9IHRyYXZlcnNlVHlwZShzLCB0KTtcbiAgICAgICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBzaW5nbGUgc3RhdGVtZW50IChmb3Igbm93KVxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9uIDpcbiAgICAgICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgICAgICB3aGlsZSAodC5uZXh0U2libGluZygpKSB7XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKHRyYXZlcnNlU3RtdChzLCB0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0LnBhcmVudCgpOyAvLyBQb3AgdG8gQm9keVxuICAgICAgICAgICAgdC5wYXJlbnQoKTsgLy8gUG9wIHRvIEZ1bmN0aW9uRGVmaW5pdGlvblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWc6IFwiZGVmaW5lXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHJldDogcmV0XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiQ2xhc3NEZWZpbml0aW9uXCI6XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb24gZGVmXG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIG5hbWUgb2YgZnVuY3Rpb25cbiAgICAgICAgICAgIHZhciBuYW1lID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgIHN1cHBvcnRlZFR5cGVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICBjbHNfbmFtZV9yZWcgPSBuYW1lO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBvYmplY3QsIHRoZSBvcmlnaW5hbCBwYXJhbSBsaXN0XG4gICAgICAgICAgICAvL25vIHBhcmFtcyBoZXJlLCBhcyBvbmx5IFwib2JqZWN0XCIgaXMgYWxsb3dlZFxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBCb2R5IG9yIFR5cGVEZWZcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gc2luZ2xlIHN0YXRlbWVudCAoZm9yIG5vdylcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyBvbiA6XG4gICAgICAgICAgICB2YXIgdmFySW5pdHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjbHNCb2R5ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgd2hpbGUgKHQubmV4dFNpYmxpbmcoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjbHNfc3RtdCA9IHRyYXZlcnNlU3RtdChzLCB0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzX3N0bXQudGFnID09IFwiZGVmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8geyBhPzogQSwgdGFnOiBcImNsYXNzXCIsIG5hbWU6c3RyaW5nLCBmaWVsZHM6IFN0bXQ8QT5bXSwgbWV0aG9kczogTWFwIDxzdHJpbmcsIEZ1bkRlZjxBPj59XG4gICAgICAgICAgICAgICAgICAgIGNsc0JvZHkuc2V0KGNsc19zdG10Lm5hbWUsIHsgbmFtZTogY2xzX3N0bXQubmFtZSwgcGFyYW1zOiBjbHNfc3RtdC5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQ6IGNsc19zdG10LnJldCwgaW5pdHM6IHZhckluaXRzLCBib2R5OiBjbHNfc3RtdC5ib2R5IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsc19zdG10LnRhZyA9PSBcImFzc2lnblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJJbml0cy5wdXNoKGNsc19zdG10KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBBUlNFUiBFUlJPUjogdW5zdXBwb3J0ZWQgc3RhdGVtZW50cyB0eXBlIGZvciBjbGFzcyBkZWZpbml0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC5wYXJlbnQoKTsgLy8gUG9wIHRvIEJvZHlcbiAgICAgICAgICAgIHQucGFyZW50KCk7IC8vIFBvcCB0byBGdW5jdGlvbkRlZmluaXRpb25cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xhc3NfbmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIGNsc19uYW1lX3JlZyA9IFwibm9uZVwiO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhOiBuYW1lLFxuICAgICAgICAgICAgICAgIHRhZzogXCJjbGFzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgZmllbGRzOiB2YXJJbml0cyxcbiAgICAgICAgICAgICAgICBtZXRob2RzOiBjbHNCb2R5XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiUGFzc1N0YXRlbWVudFwiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcInBhc3NcIiB9O1xuICAgICAgICBjYXNlIFwiSWZTdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgdmFyIGNvbmRfZXhwciA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy9mb2N1cyBvbiBib2R5XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy9mb2N1cyBvbiA6XG4gICAgICAgICAgICB2YXIgc3RtdF9iID0gW107XG4gICAgICAgICAgICB2YXIgZWxzZV9zdG10X2IgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICh0Lm5leHRTaWJsaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBzdG10X2IucHVzaCh0cmF2ZXJzZVN0bXQocywgdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICAgIGlmICh0Lm5vZGUudHlwZS5uYW1lID09PSBcImVsc2VcIikge1xuICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy9mb2N1cyBvbiBib2R5XG4gICAgICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vZm9jdXMgb24gOlxuICAgICAgICAgICAgICAgIHdoaWxlICh0Lm5leHRTaWJsaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxzZV9zdG10X2IucHVzaCh0cmF2ZXJzZVN0bXQocywgdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcImlmXCIsIGNvbmQ6IGNvbmRfZXhwciwgYm9keTogc3RtdF9iLCBlbHNlX2JvZHk6IGVsc2Vfc3RtdF9iIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJpZlwiLCBjb25kOiBjb25kX2V4cHIsIGJvZHk6IHN0bXRfYiwgZWxzZV9ib2R5OiBlbHNlX3N0bXRfYiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgdmFyIGNvbmRfd2hpbGUgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vZm9jdXMgb24gYm9keVxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vZm9jdXMgb24gOlxuICAgICAgICAgICAgdmFyIHN0bXRfdyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHQubmV4dFNpYmxpbmcoKSkge1xuICAgICAgICAgICAgICAgIHN0bXRfdy5wdXNoKHRyYXZlcnNlU3RtdChzLCB0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJ3aGlsZVwiLCBjb25kOiBjb25kX3doaWxlLCBib2R5OiBzdG10X3cgfTtcbiAgICB9XG59XG5leHBvcnRzLnRyYXZlcnNlU3RtdCA9IHRyYXZlcnNlU3RtdDtcbmZ1bmN0aW9uIHRyYXZlcnNlVHlwZShzLCB0KSB7XG4gICAgc3dpdGNoICh0LnR5cGUubmFtZSkge1xuICAgICAgICBjYXNlIFwiVmFyaWFibGVOYW1lXCI6XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgIC8vIC8vIGlmKG5hbWUgIT09IFwiaW50XCIgJiYgbmFtZSAhPT1cIm5vbmVcIiAmJiBuYW1lICE9PSBcImJvb2xcIikge1xuICAgICAgICAgICAgLy8gaWYgKCFzdXBwb3J0ZWRUeXBlcy5pbmNsdWRlcyhuYW1lKSl7XG4gICAgICAgICAgICAvLyAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gVmFyaWFibGVOYW1lIHR5cGU6IFwiICsgbmFtZSlcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHZhciByZXR1cm5fbmFtZSA9IG5hbWVfMTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5fbmFtZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9uLVZhcmlhYmxlTmFtZSB0eXBlOiBcIiArIHQudHlwZS5uYW1lKTtcbiAgICB9XG59XG5leHBvcnRzLnRyYXZlcnNlVHlwZSA9IHRyYXZlcnNlVHlwZTtcbmZ1bmN0aW9uIHRyYXZlcnNlUGFyYW1ldGVycyhzLCB0KSB7XG4gICAgdC5maXJzdENoaWxkKCk7IC8vIEZvY3VzZXMgb24gb3BlbiBwYXJlblxuICAgIHZhciBwYXJhbWV0ZXJzID0gW107XG4gICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1c2VzIG9uIGEgVmFyaWFibGVOYW1lXG4gICAgd2hpbGUgKHQudHlwZS5uYW1lICE9PSBcIilcIikge1xuICAgICAgICB2YXIgbmFtZV8yID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1c2VzIG9uIFwiVHlwZURlZlwiLCBob3BlZnVsbHksIG9yIFwiLFwiIGlmIG1pc3Rha2VcbiAgICAgICAgdmFyIG5leHRUYWdOYW1lID0gdC50eXBlLm5hbWU7IC8vIE5PVEUoam9lKTogYSBiaXQgb2YgYSBoYWNrIHNvIHRoZSBuZXh0IGxpbmUgZG9lc24ndCBpZi1zcGxpdFxuICAgICAgICBpZiAobmV4dFRhZ05hbWUgIT09IFwiVHlwZURlZlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzZWQgdHlwZSBhbm5vdGF0aW9uIGZvciBwYXJhbWV0ZXIgXCIgKyBuYW1lXzIpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIEVudGVyIFR5cGVEZWZcbiAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1c2VzIG9uIHR5cGUgaXRzZWxmXG4gICAgICAgIHZhciB0eXAgPSB0cmF2ZXJzZVR5cGUocywgdCk7XG4gICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gTW92ZSBvbiB0byBjb21tYSBvciBcIilcIlxuICAgICAgICBwYXJhbWV0ZXJzLnB1c2goeyBuYW1lOiBuYW1lXzIsIHR5cDogdHlwIH0pO1xuICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gYSBWYXJpYWJsZU5hbWVcbiAgICB9XG4gICAgdC5wYXJlbnQoKTsgLy8gUG9wIHRvIFBhcmFtTGlzdFxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuZXhwb3J0cy50cmF2ZXJzZVBhcmFtZXRlcnMgPSB0cmF2ZXJzZVBhcmFtZXRlcnM7XG5mdW5jdGlvbiB0cmF2ZXJzZUV4cHIocywgdCkge1xuICAgIHN3aXRjaCAodC50eXBlLm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIk5vbmVcIjpcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJub25lXCIgfTtcbiAgICAgICAgY2FzZSBcIkJvb2xlYW5cIjpcbiAgICAgICAgICAgIGlmIChzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pID09PSBcIlRydWVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJ0cnVlXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJmYWxzZVwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJOdW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IE51bWJlcihzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pKSB9O1xuICAgICAgICBjYXNlIFwiVmFyaWFibGVOYW1lXCI6XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiaWRcIiwgbmFtZTogcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKSB9O1xuICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyBuYW1lXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgICAgICBpZiAobmFtZS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9ial9wYXJzZWQgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBBcmdMaXN0XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb3BlbiBwYXJlblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSB0cmF2ZXJzZUFyZ3VtZW50cyh0LCBzKTtcbiAgICAgICAgICAgIHQucHJldlNpYmxpbmcoKTtcbiAgICAgICAgICAgIGlmIChuYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqX3BhcnNlZC50YWcgPT0gXCJnZXRmaWVsZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgdGFnOiBcIm1ldGhvZFwiLCBvYmo6IG9ial9wYXJzZWQub2JqLCBuYW1lOiBvYmpfcGFyc2VkLm5hbWUsIGFyZ3M6IGFyZ3MgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7IHRhZzogXCJjYWxsXCIsIG5hbWU6IG5hbWUsIGFyZ3M6IGFyZ3MgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIHZhciB1b3AgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgc3dpdGNoICh1b3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc192YXIgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzX3Zhci50YWcgPT0gXCJpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiAnYmlub3AnLCBvcDogJyonLCBsaHM6IHsgYTogXCJpbnRcIiwgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogLTEgfSwgcmhzOiB0aGlzX3ZhciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSBOdW1iZXIodW9wICsgcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQQVJTRSBFUlJPUjogdW5hcnkgb3BlcmF0aW9uIGZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiBudW0gfTtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc192YXIgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzX3Zhci50YWcgPT0gXCJpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiAnYmlub3AnLCBvcDogJyonLCBsaHM6IHsgYTogXCJpbnRcIiwgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMSB9LCByaHM6IHRoaXNfdmFyIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9IE51bWJlcih1b3AgKyBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBBUlNFIEVSUk9SOiB1bmFyeSBvcGVyYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IG51bSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgXCJub3RcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdF9yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykgPT09IFwiVHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RfcmVzdWx0ID0geyB0YWc6IFwiZmFsc2VcIiB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90X3Jlc3VsdCA9IHsgdGFnOiBcInRydWVcIiB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub3RfcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBBUlNFIEVSUk9SOiB1bmltcGxlbWVudGVkIHVuYXJ5IG9wXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIGdvIHRvIGxoc1xuICAgICAgICAgICAgdmFyIGxoc0V4cHIgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIGdvIHRvIG9wXG4gICAgICAgICAgICB2YXIgb3BTdHIgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgaWYgKCEoMCwgYXN0XzEuaXNPcCkob3BTdHIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvciB1bmhhbmRsZWQgb3A6IFwiLmNvbmNhdChvcFN0cikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBnbyB0byByaHNcbiAgICAgICAgICAgIHZhciByaHNFeHByID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGFnOiBcImJpbm9wXCIsXG4gICAgICAgICAgICAgICAgb3A6IG9wU3RyLFxuICAgICAgICAgICAgICAgIGxoczogbGhzRXhwcixcbiAgICAgICAgICAgICAgICByaHM6IHJoc0V4cHJcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIGZvY3VzIG9uIChcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICAgIHZhciBwYXJlbl9leHAgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIGZvY3VzIG9uIClcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW5fZXhwO1xuICAgICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vZm9jdXMgb24gdmFyaWFibGUgbmFtZSBsaWtlIFwiY1wiLFwic2VsZlwiXG4gICAgICAgICAgICB2YXIgY2xzX25hbWUgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgdmFyIGNsc19vYmogPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIGZvY3VzIG9uIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eV9uYW1lID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcGFyc2Ugc2VsZiB3aXRoIGEgcmVnaXN0ZXJcbiAgICAgICAgICAgIGlmIChjbHNfbmFtZSA9PSBcInNlbGZcIikge1xuICAgICAgICAgICAgICAgIGlmIChjbHNfbmFtZV9yZWcgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzZWxmIGhlcmVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbHNfbmFtZSA9IGNsc19uYW1lX3JlZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNZW1iZXIgRXhwcmVzc2lvbiwgb2JqOlwiLmNvbmNhdChjbHNfb2JqLCBcIiwgbmFtZTpcIikuY29uY2F0KHByb3BlcnR5X25hbWUpKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHsgdGFnOiBcImdldGZpZWxkXCIsIG9iajogY2xzX29iaiwgbmFtZTogcHJvcGVydHlfbmFtZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSBcInNlbGZcIjpcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJzZWxmXCIsIGE6IHsgdGFnOiBcIm9iamVjdFwiLCBjbGFzczogY2xzX25hbWVfcmVnIH0gfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cHJlc3Npb24gbm90IGluY2x1ZGVkIGluIHRyYXZlcnNlRXhwcjogXCIuY29uY2F0KHQudHlwZS5uYW1lLCBcIiwgXCIpLmNvbmNhdChzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pKSk7XG4gICAgfVxufVxuZXhwb3J0cy50cmF2ZXJzZUV4cHIgPSB0cmF2ZXJzZUV4cHI7XG5mdW5jdGlvbiB0cmF2ZXJzZUFyZ3VtZW50cyhjLCBzKSB7XG4gICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzZXMgb24gb3BlbiBwYXJlblxuICAgIHZhciBhcmdzID0gW107XG4gICAgYy5uZXh0U2libGluZygpO1xuICAgIHdoaWxlIChjLnR5cGUubmFtZSAhPT0gXCIpXCIpIHtcbiAgICAgICAgdmFyIGV4cHIgPSB0cmF2ZXJzZUV4cHIocywgYyk7XG4gICAgICAgIGFyZ3MucHVzaChleHByKTtcbiAgICAgICAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1c2VzIG9uIGVpdGhlciBcIixcIiBvciBcIilcIlxuICAgICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gYSBWYXJpYWJsZU5hbWVcbiAgICB9XG4gICAgYy5wYXJlbnQoKTsgLy8gUG9wIHRvIEFyZ0xpc3RcbiAgICByZXR1cm4gYXJncztcbn1cbmV4cG9ydHMudHJhdmVyc2VBcmd1bWVudHMgPSB0cmF2ZXJzZUFyZ3VtZW50cztcbmZ1bmN0aW9uIHRyYXZlcnNlKGMsIHMpIHtcbiAgICBzd2l0Y2ggKGMubm9kZS50eXBlLm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIlNjcmlwdFwiOlxuICAgICAgICAgICAgdmFyIHN0bXRzID0gW107XG4gICAgICAgICAgICBjLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBzdG10cy5wdXNoKHRyYXZlcnNlU3RtdChzLCBjKSk7XG4gICAgICAgICAgICB9IHdoaWxlIChjLm5leHRTaWJsaW5nKCkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0cmF2ZXJzZWQgXCIgKyBzdG10cy5sZW5ndGggKyBcIiBzdGF0ZW1lbnRzIFwiLCBzdG10cywgXCJzdG9wcGVkIGF0IFwiLCBjLm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHN0bXRzO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHByb2dyYW0gYXQgXCIgKyBjLm5vZGUuZnJvbSArIFwiIFwiICsgYy5ub2RlLnRvKTtcbiAgICB9XG59XG5leHBvcnRzLnRyYXZlcnNlID0gdHJhdmVyc2U7XG5mdW5jdGlvbiBwYXJzZShzb3VyY2UpIHtcbiAgICB2YXIgdCA9IGxlemVyX3B5dGhvbl8xLnBhcnNlci5wYXJzZShzb3VyY2UpO1xuICAgIHJldHVybiB0cmF2ZXJzZSh0LmN1cnNvcigpLCBzb3VyY2UpO1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DTEFTUyA9IGV4cG9ydHMuYXNzaWduYWJsZVRvID0gZXhwb3J0cy5pc09iamVjdCA9IGV4cG9ydHMudGNMaXRlcmFsID0gZXhwb3J0cy50Y1Byb2dyYW0gPSBleHBvcnRzLnRjU3RtdCA9IGV4cG9ydHMudGNFeHByID0gZXhwb3J0cy50Y1BhcmFtcyA9IGV4cG9ydHMudGNWYXJJbml0cyA9IHZvaWQgMDtcbnZhciBhc3RfMSA9IHJlcXVpcmUoXCIuL2FzdFwiKTtcbnZhciBhc3RfMiA9IHJlcXVpcmUoXCIuL2FzdFwiKTtcbnZhciBvYmpFbnY7XG52YXIgb2JqX25hbWVfcmVnID0gXCJub25lXCI7XG5mdW5jdGlvbiBkdXBsaWNhdGVFbnYoZW52KSB7XG4gICAgcmV0dXJuIHsgdmFyczogbmV3IE1hcChlbnYudmFycyksIGZ1bnM6IG5ldyBNYXAoZW52LmZ1bnMpLCByZXRUeXBlOiBlbnYucmV0VHlwZSB9O1xufVxuZnVuY3Rpb24gdGNWYXJJbml0cyhpbml0cywgZW52KSB7XG4gICAgdmFyIHR5cGVkSW5pdHMgPSBbXTtcbiAgICBpbml0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbml0KSB7XG4gICAgICAgIHZhciB0eXBlZEluaXQgPSB0Y0xpdGVyYWwoaW5pdC5pbml0KTtcbiAgICAgICAgaWYgKHR5cGVkSW5pdC5hICE9PSBpbml0LnR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBpbml0IHR5cGUgZG9lcyBub3QgbWF0Y2ggbGl0ZXJhbCB0eXBlXCIpO1xuICAgICAgICBlbnYudmFycy5zZXQoaW5pdC5uYW1lLCBpbml0LnR5cGUpO1xuICAgICAgICB0eXBlZEluaXRzLnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIGluaXQpLCB7IGE6IGluaXQudHlwZSwgaW5pdDogdHlwZWRJbml0IH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZWRJbml0cztcbn1cbmV4cG9ydHMudGNWYXJJbml0cyA9IHRjVmFySW5pdHM7XG5mdW5jdGlvbiB0Y1BhcmFtcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbSksIHsgYTogcGFyYW0udHlwZSB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMudGNQYXJhbXMgPSB0Y1BhcmFtcztcbi8vIGV4cG9ydCBmdW5jdGlvbiB0Y0Z1bkRlZihmdW46RnVuRGVmPGFueT4sIGNscyA6IENsYXNzRW52LCBlbnY6IFR5cGVFbnYpOiBGdW5EZWY8VHlwZT57XG4vLyAgIGNvbnN0IGxvY2FsRW52ID0gZHVwbGljYXRlRW52KGVudilcbi8vICAgLy9hZGQgcGFyYW1zIHRvIGVudlxuLy8gICBmdW4ucGFyYW1zLmZvckVhY2gocGFyYW09Pntcbi8vICAgICBsb2NhbEVudi52YXJzLnNldChwYXJhbS5uYW1lLHBhcmFtLnR5cGUpO1xuLy8gICB9KVxuLy8gICBjb25zdCB0eXBlZFBhcmFtcyA9IHRjUGFyYW1zKGZ1bi5wYXJhbXMpO1xuLy8gICAvL0FkZCBpbml0c1xuLy8gICBjb25zdCB0eXBlZEluaXRzID0gdGNWYXJJbml0cyhmdW4uaW5pdHMsIGVudik7XG4vLyAgIGZ1bi5pbml0cy5mb3JFYWNoKGluaXQ9Pntcbi8vICAgICBsb2NhbEVudi52YXJzLnNldChpbml0Lm5hbWUsaW5pdC50eXBlKTtcbi8vICAgfSlcbi8vICAgbG9jYWxFbnYuZnVucy5zZXQoZnVuLm5hbWUsW2Z1bi5wYXJhbXMubWFwKHBhcmFtPT5wYXJhbS50eXBlKSwgZnVuLnJldF0pO1xuLy8gICAvL0NoZWNrIGJvZHlcbi8vICAgY29uc3QgdHlwZWRTdG10cyA9IHRjU3RtdChmdW4uYm9keSxjbHMsbG9jYWxFbnYuZnVucyxsb2NhbEVudi52YXJzLGxvY2FsRW52LnJldFR5cGUpO1xuLy8gICByZXR1cm4gey4uLmZ1bixwYXJhbXM6IHR5cGVkUGFyYW1zLCBpbml0czp0eXBlZEluaXRzLCBib2R5OnR5cGVkU3RtdHN9O1xuLy8gfVxuZnVuY3Rpb24gdGNFeHByKGUsIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzKSB7XG4gICAgdmFyIGVtcHR5RW52ID0gbmV3IE1hcCgpO1xuICAgIHN3aXRjaCAoZS50YWcpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOiByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiaW50XCIgfSk7XG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6IHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJib29sXCIgfSk7XG4gICAgICAgIGNhc2UgXCJmYWxzZVwiOiByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiYm9vbFwiIH0pO1xuICAgICAgICBjYXNlIFwibm9uZVwiOiByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwibm9uZVwiIH0pO1xuICAgICAgICBjYXNlIFwiYmlub3BcIjoge1xuICAgICAgICAgICAgLy8gV2UgY3VycmVudGx5IGVuZm9yY2UgdGhlIGxocyBhbmQgcmhzIG11c3QgYmUgaW50XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRjRXhwcihlLmxocywgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGNFeHByKGUucmhzLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICBlLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICBlLnJocyA9IHJpZ2h0O1xuICAgICAgICAgICAgaWYgKGUub3AgPT0gJ2lzJykge1xuICAgICAgICAgICAgICAgIC8vIFwiaXNcIiBvcGVyYXRvciBsb2dpY1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaXMgb3AsIGxlZnQsIHJpZ2h0XCIsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5hID09IFwiaW50XCIgfHwgbGVmdC5hID09IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IExIUyBvZiAnaXMnIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuYSA9PSBcImludFwiIHx8IHJpZ2h0LmEgPT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogUkhTIG9mICdpcycgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJib29sXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIGFzdF8yLmlzaW50T3ApKGUub3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUubGhzLmEgIT0gXCJpbnRcIiB8fCBlLnJocy5hICE9IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUQyBWYXJpYWJsZXNcIiwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogTEhTLFJIUyBvZiBcIi5jb25jYXQoZS5vcCwgXCIgbXVzdCBiZSBib3RoIGludCwgaW5zdGVhZCwgd2UgaGF2ZSBcIikuY29uY2F0KGUubGhzLmEsIFwiLFwiKS5jb25jYXQoZS5yaHMuYSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuX2Jvb2xfb3BzID0gW1wiPlwiLCBcIjxcIiwgXCI+PVwiLCBcIjw9XCJdO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldHVybl9ib29sX29wcy5pbmNsdWRlcyhlLm9wKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybl9ib29sX29wcy5pbmNsdWRlcyhlLm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiYm9vbFwiIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiaW50XCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGFzdF8yLmlzYm9vbE9wKShlLm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5saHMuYSAhPSBcImJvb2xcIiB8fCBlLnJocy5hICE9IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBMSFMsUkhTIG9mIFwiLmNvbmNhdChlLm9wLCBcIiBtdXN0IGJlIGJvdGggYm9vbCwgaW5zdGVhZCwgd2UgaGF2ZSBcIikuY29uY2F0KGUubGhzLmEsIFwiLFwiKS5jb25jYXQoZS5yaHMuYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJib29sXCIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGFzdF8xLmlzc2FtZU9wKShlLm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubGhzLmEgPT0gZS5yaHMuYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJib29sXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBMSFMsUkhTIG9mIFwiLmNvbmNhdChlLm9wLCBcIiBtdXN0IGJlIG9mIHNhbWUgdHlwZSwgaW5zdGVhZCwgd2UgaGF2ZSBcIikuY29uY2F0KGUubGhzLmEsIFwiLFwiKS5jb25jYXQoZS5yaHMuYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogW3RjLnRzXVVuaGFuZGxlZCBiaW5hcnkgb3AgXCIuY29uY2F0KGUub3ApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaWRcIjogcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiB2YXJpYWJsZXMuZ2V0KGUubmFtZSkgfSk7XG4gICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogcHJpbnQgZXhwZWN0cyBhIHNpbmdsZSBhcmd1bWVudFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5ld0FyZ3NfMSA9IFt0Y0V4cHIoZS5hcmdzWzBdLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyldO1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJub25lXCIsIGFyZ3M6IG5ld0FyZ3NfMSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsYXNzZXMuaGFzKGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsaW5nIGNsYXNzKClcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3Nfc3RtdCA9IGNsYXNzZXMuZ2V0KGUubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzX3N0bXQudGFnICE9IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBWYXJpYWJsZSBcIi5jb25jYXQoZS5uYW1lLCBcIiBzaG91bGQgYmUgYSBjbGFzcywgaG93ZXZlciBpdHMgdGFnIGlzIG5vdFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc19zdG10LmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uICh2aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpLnRhZyAhPSBcImFzc2lnblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogZmllbGRzIHdpdGggbm9uLWFzc2lnbiB0YWdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqX25hbWVfcmVnID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQ29tZW9uIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzLnNldChcIlwiLmNvbmNhdChvYmpfbmFtZV9yZWcsIFwiLlwiKS5jb25jYXQodmkubmFtZSksIHZpLmEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFwcGVuZCB0aGlzIGVudHJ5OiBcIi5jb25jYXQob2JqX25hbWVfcmVnLCBcIi5cIikuY29uY2F0KHZpLm5hbWUsIFwiIHRvIHZhcmlhYmxlc1wiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiB7IHRhZzogXCJvYmplY3RcIiwgY2xhc3M6IGNsYXNzX3N0bXQubmFtZSB9IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZnVuY3Rpb25zLmhhcyhlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IGZ1bmN0aW9uIFwiLmNvbmNhdChlLm5hbWUsIFwiIG5vdCBmb3VuZFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBfYSA9IGZ1bmN0aW9ucy5nZXQoZS5uYW1lKSwgYXJncyA9IF9hWzBdLCByZXQgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IGUuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogVEMtY2FsbC1mdW5jdGlvbjpFeHBlY3RlZCBcIi5jb25jYXQoYXJncy5sZW5ndGgsIFwiIGFyZ3VtZW50cyBidXQgZ290IFwiKS5jb25jYXQoZS5hcmdzLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV3QXJnc18yID0gYXJncy5tYXAoZnVuY3Rpb24gKGEsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3R5cCA9IHRjRXhwcihlLmFyZ3NbaV0sIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgIT09IGFyZ3R5cC5hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBHb3QgXCIuY29uY2F0KGFyZ3R5cCwgXCIgYXMgYXJndW1lbnQgXCIpLmNvbmNhdChpICsgMSwgXCIsIGV4cGVjdGVkIFwiKS5jb25jYXQoYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmd0eXA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IHJldCwgYXJnczogbmV3QXJnc18yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSBcImxpdGVyYWxcIjpcbiAgICAgICAgICAgIGUubGl0ZXJhbCA9IHRjTGl0ZXJhbChlLmxpdGVyYWwpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBlLmxpdGVyYWwuYSB9KTtcbiAgICAgICAgY2FzZSBcImJ1aWx0aW4yXCI6XG4gICAgICAgICAgICB2YXIgYXJnMSA9IHRjRXhwcihlLmFyZzEsIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIHZhciBhcmcyID0gdGNFeHByKGUuYXJnMiwgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgaWYgKGFyZzEuYSAhPSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogTGVmdCBtdXN0IGJlIGludFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmcyLmEgIT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IFJpZ2h0IG11c3QgYmUgaW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImludFwiIH0pO1xuICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICB2YXIgbmV3T2JqID0gdGNFeHByKGUub2JqLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICB2YXIgbmV3QXJncztcbiAgICAgICAgICAgIGlmIChuZXdPYmouYSAhPSBcImludFwiICYmIG5ld09iai5hICE9IFwiYm9vbFwiICYmIG5ld09iai5hICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld09iai5hLnRhZyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIk5vbi1vYmplY3QgdHlwZSBpbiBtZXRob2QgY2FsbFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNsYXNzZXMuaGFzKG5ld09iai5hLmNsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkNvbXBpbGVyIGVycm9yLCBubyBzdWNoIGNsYXNzXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjbGFzc2RhdGEgPSBjbGFzc2VzLmdldChuZXdPYmouYS5jbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzZGF0YS50YWcgPT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xhc3NkYXRhLm1ldGhvZHMuaGFzKGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiTm8gc3VjaCBtZXRob2RcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdBcmdzID0gZS5hcmdzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gdGNFeHByKGEsIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGlzZnVuID0gY2xhc3NkYXRhLm1ldGhvZHMuZ2V0KGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdUeXBzID0gdGhpc2Z1bi5wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXRUeXBlID0gdGhpc2Z1bi5yZXQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgd2UgbXVzdCBpZ25vcmUgc2VsZiBieSBhZGRpbmcgMSB0byB0aGUgcmhzXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdUeXBzLmxlbmd0aCAhPT0gbmV3QXJncy5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcInRjOiBtZXRob2QgYXJnIG1pc21hdGNoXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJnVHlwcy5mb3JFYWNoKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodC50eXApICYmICF0LnR5cC5oYXNPd25Qcm9wZXJ0eSgndGFnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnR5cCA9IHsgdGFnOiBcIm9iamVjdFwiLCBjbGFzczogU3RyaW5nKHQudHlwKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQubmFtZSAhPSBcInNlbGZcIiAmJiAhYXNzaWduYWJsZVRvKHQudHlwLCBuZXdBcmdzW2kgLSAxXS5hKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IEFyZyBUeXBlcyBtaXNtYXRjaCBmb3IgXCIuY29uY2F0KHQudHlwLCBcIiBhbmQgXCIpLmNvbmNhdChuZXdBcmdzW2kgLSAxXS5hKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJUYWcgc2F5cyBcIi5jb25jYXQoZS5uYW1lLCBcIiBpcyBhIG1ldGhvZCwgYnV0IGFubm90YXRpb24gc2F5cyBpdCBpc24ndCBhbiBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUlVOVElNRSBFUlJPUjogVGhlIFR5cGUgb2YgXCIuY29uY2F0KGUub2JqLCBcIiBzaG91bGQgYmUgYW4gb2JqLCBpbnN0ZWFkIGl0IGlzIGEgXCIpLmNvbmNhdChuZXdPYmouYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHJldFR5cGUpICYmICFyZXRUeXBlLmhhc093blByb3BlcnR5KCd0YWcnKSkge1xuICAgICAgICAgICAgICAgIC8vSnVzdCBhIG5vcm1hbCBzdHJpbmdcbiAgICAgICAgICAgICAgICByZXRUeXBlID0geyB0YWc6IFwib2JqZWN0XCIsIGNsYXNzOiBTdHJpbmcocmV0VHlwZSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogcmV0VHlwZSwgb2JqOiBuZXdPYmosIGFyZ3M6IG5ld0FyZ3MgfSk7XG4gICAgICAgIGNhc2UgXCJnZXRmaWVsZFwiOlxuICAgICAgICAgICAgdmFyIGNsc19uYW1lO1xuICAgICAgICAgICAgc3dpdGNoIChlLm9iai50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9ial90eXBlID0gb2JqRW52LmdldChlLm9iai5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ial90eXBlID09IFwiYm9vbFwiIHx8IG9ial90eXBlID09IFwiaW50XCIgfHwgb2JqX3R5cGUgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJVTlRJTUUgRVJST1I6IFRoZSBUeXBlIG9mIFwiLmNvbmNhdChlLm9iai5uYW1lLCBcIiBzaG91bGQgYmUgYW4gb2JqXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsc19uYW1lID0gb2JqX3R5cGUuY2xhc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlbGZcIjpcbiAgICAgICAgICAgICAgICAgICAgY2xzX25hbWUgPSBlLm9iai5hLmNsYXNzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0ZmllbGRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUub2JqLmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldF9jbGFzcyA9IG9iakVudi5nZXQoZS5vYmoubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0X2NsYXNzID09IFwiYm9vbFwiIHx8IGdldF9jbGFzcyA9PSBcImludFwiIHx8IGdldF9jbGFzcyA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IFdlaXJkLiBDbGFzcyBTdGF0ZW1lbnQgXCIuY29uY2F0KGNsc19zdG10LCBcIiBoYXMgdGFnIFwiKS5jb25jYXQoY2xzX3N0bXQudGFnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHNfbmFtZSA9IGdldF9jbGFzcy5jbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsc19uYW1lID0gZS5vYmouYS5jbGFzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGNsc19uYW1lID0gZS5vYmouYS5jbGFzcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogdGM6IGdldGZpZWxkLCBub3QgYSBzdXBwb3J0ZWQgZGF0YXR5cGUsYnV0IFwiLmNvbmNhdChlLm9iai50YWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbHNfc3RtdCA9IGNsYXNzZXMuZ2V0KGNsc19uYW1lKTtcbiAgICAgICAgICAgIHdoaWxlIChjbHNfc3RtdC50YWcgPT0gXCJhc3NpZ25cIikge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGNsc19zdG10XG4gICAgICAgICAgICAgICAgY2xzX3N0bXQgPSBjbGFzc2VzLmdldChjbHNfc3RtdC5hLmNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbHNfc3RtdC50YWcgIT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUWVBFIEVSUk9SOiB0Yzogc3RhdGVtZW50IGlzIG5vdCBjbGFzcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFubm87XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRyeSB0byBmaW5kIHR5cGUgZnJvbSB0aGlzIGNscyBzdF9tdCBcIi5jb25jYXQoY2xzX3N0bXQpKTtcbiAgICAgICAgICAgIGNsc19zdG10LmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxkLnRhZyA9PSBcImFzc2lnblwiICYmIGZsZC5uYW1lID09IGUubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmbGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImZpbmQgdHlwZSBcIi5jb25jYXQoZmxkLmEsIFwiIGZvciBcIikuY29uY2F0KGUubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBhbm5vID0gZmxkLmE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IGFubm8gfSk7XG4gICAgICAgIGNhc2UgXCJzZWxmXCI6XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIGUpO1xuICAgIH1cbn1cbmV4cG9ydHMudGNFeHByID0gdGNFeHByO1xuZnVuY3Rpb24gdGNTdG10KHMsIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzLCBjdXJyZW50UmV0dXJuKSB7XG4gICAgY29uc29sZS5sb2coXCJ0Y1N0bXRcIiwgcyk7XG4gICAgc3dpdGNoIChzLnRhZykge1xuICAgICAgICBjYXNlIFwiYXNzaWduXCI6IHtcbiAgICAgICAgICAgIHZhciBzZWxmX2ZsYWcgPSAwO1xuICAgICAgICAgICAgaWYgKHMudmFsdWUudGFnID09IFwiY2FsbFwiICYmIGNsYXNzZXMuaGFzKHMudmFsdWUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNldCBPTlIgdG8gXCIuY29uY2F0KHMubmFtZSkpO1xuICAgICAgICAgICAgICAgIG9ial9uYW1lX3JlZyA9IHMubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqX3R5cGUgPSBjbGFzc2VzLmdldChzLnZhbHVlLm5hbWUpLmE7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9ial90eXBlKSAmJiAhb2JqX3R5cGUuaGFzT3duUHJvcGVydHkoJ3RhZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ial90eXBlID0gQ0xBU1Mob2JqX3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmpFbnYuc2V0KHMubmFtZSwgb2JqX3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYXNzIHRoZSBjYWxsIGNsYXNzIGNoZWNrXCIpO1xuICAgICAgICAgICAgdmFyIHJocyA9IHRjRXhwcihzLnZhbHVlLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICBpZiAocy5hID09PSAnJykge1xuICAgICAgICAgICAgICAgIGlmIChzLm5hbWUuc3RhcnRzV2l0aCgnc2VsZi4nKSkge1xuICAgICAgICAgICAgICAgICAgICBzLm5hbWUgPSBzLm5hbWUuc3BsaXQoJy4nLCAyKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZl9mbGFnID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlcy5oYXMocy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImdldF9uYW1lXCIsIHZhcmlhYmxlcy5nZXQocy5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIHMuYSA9IHZhcmlhYmxlcy5nZXQocy5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJVTlRJTUUgRVJST1I6IENhbm5vdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIFwiLmNvbmNhdChzLm5hbWUsIFwiIGJlZm9yZSBpdHMgZGVjbGFyYXRpb25cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGNTdG10LWFzc2lnblwiLCBzLmEsIHJocy5hKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXNzaWduYWJsZT9cIiwgYXNzaWduYWJsZVRvKHMuYSwgcmhzLmEpKTtcbiAgICAgICAgICAgIGlmIChzLmEgPT0gXCJub25lXCIgJiYgaXNPYmplY3QocmhzLmEpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY2xhc3MgdHlwZSBvZiBsaHMscmhzXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBc3NpZ24gY2xhc3MgdG8gbm9uZSwgd2l0aCBjbGFzc2VzXCIsIGNsYXNzZXMpO1xuICAgICAgICAgICAgICAgIHZhciBjbHNfdHlwID0gb2JqRW52LmdldChzLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghYXNzaWduYWJsZVRvKGNsc190eXAsIHJocy5hKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBDbGFzcyBNaXNtYXRjaDogVHJ5IHRvIGFzc2lnbiBcIi5jb25jYXQocmhzLmEsIFwiIHRvIFwiKS5jb25jYXQocy5uYW1lLCBcIiwgd2hpY2ggaXMgdHlwZSBcIikuY29uY2F0KGNsc190eXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFzc2lnbmFibGVUbyhzLmEsIHJocy5hKSkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgYW4gZXhlbXB0aW9uIGZvciBhc3NpZ24gXCJub25lXCIgdG8gXCJvYmpcIlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IENhbm5vdCBhc3NpZ24gXCIuY29uY2F0KHJocy5hLCBcIiB0byBcIikuY29uY2F0KHMubmFtZSwgXCIsIHdoaWNoIHJlcXVpcmVzIFwiKS5jb25jYXQocy5hKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmhzLmEgPT0gXCJub25lXCIgJiYgaXNPYmplY3Qocy5hKSkge1xuICAgICAgICAgICAgICAgICAgICBzLmEgPSB7IHRhZzogXCJvYmplY3RcIiwgY2xhc3M6IHMuYSB9O1xuICAgICAgICAgICAgICAgICAgICBvYmpFbnYuc2V0KHMubmFtZSwgcy5hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFyaWFibGVzLmhhcyhzLm5hbWUpICYmICFhc3NpZ25hYmxlVG8odmFyaWFibGVzLmdldChzLm5hbWUpLCByaHMuYSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBcIi5jb25jYXQocy5uYW1lLCBcIiBhbHJlYWR5IGRlY2xhcmVkLCB3aGljaCByZXF1aXJlcyBcIikuY29uY2F0KHMuYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJocy5hID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXNzaWduIE5vbmUgUmVzdWx0XCIsIHZhcmlhYmxlcy5nZXQocy5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcy5zZXQocy5uYW1lLCByaHMuYSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gY2hhbmdlIHMuYSBoZXJlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMuc2V0KHMubmFtZSwgcmhzLmEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh2YXJpYWJsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xhc3Nlcy5zZXQocy5uYW1lLHMpO1xuICAgICAgICAgICAgaWYgKHNlbGZfZmxhZyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcy5uYW1lID0gJ3NlbGYuJyArIHMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGZfZmxhZyA9IDA7XG4gICAgICAgICAgICBvYmpfbmFtZV9yZWcgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcyksIHsgdmFsdWU6IHJocyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZGVmaW5lXCI6IHtcbiAgICAgICAgICAgIHZhciBib2R5dmFyc18xID0gbmV3IE1hcCh2YXJpYWJsZXMuZW50cmllcygpKTtcbiAgICAgICAgICAgIHMucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgYm9keXZhcnNfMS5zZXQocC5uYW1lLCBwLnR5cCk7IH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJkZWZpbmUtcy5ib2R5XCIsIHMuYm9keSk7XG4gICAgICAgICAgICB2YXIgcmV0dXJuX2ZsYWcgPSAwO1xuICAgICAgICAgICAgdmFyIG5ld1N0bXRzID0gcy5ib2R5Lm1hcChmdW5jdGlvbiAoYnMpIHsgcmV0dXJuIHRjU3RtdChicywgY2xhc3NlcywgZnVuY3Rpb25zLCBib2R5dmFyc18xLCBzLnJldCk7IH0pO1xuICAgICAgICAgICAgaWYgKHMucmV0ICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgcy5ib2R5LmZvckVhY2goZnVuY3Rpb24gKGJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChicy50YWcgPT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuX2ZsYWcgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybl9mbGFnID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogXCIuY29uY2F0KHMucmV0LCBcIiBuZXZlciByZXR1cm5zXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHMpLCB7IGJvZHk6IG5ld1N0bXRzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjbGFzc1wiOiB7XG4gICAgICAgICAgICB2YXIgYm9keXZhcnMgPSBuZXcgTWFwKHZhcmlhYmxlcy5lbnRyaWVzKCkpO1xuICAgICAgICAgICAgcy5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAodmkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGNfdmkgPSB0Y1N0bXQodmksIGNsYXNzZXMsIGZ1bmN0aW9ucywgYm9keXZhcnMsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodmkudGFnICE9IFwiYXNzaWduXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogdmkgXCIuY29uY2F0KHZpLCBcIidzIHRhZyBpcyBub3QgYXNzaWduXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHl2YXJzLnNldCh2aS5uYW1lLCB0Y192aS5hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicy1maWVsZHM6XCIsIHMuZmllbGRzKTtcbiAgICAgICAgICAgIHZhciBuZXdfbWV0aG9kcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHMubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZHMsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlja2V5IEhlcmUsbWRzIGhlcmUgaXMgdGhlIEZ1bkRlZlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1kcyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobWRzLmJvZHkpO1xuICAgICAgICAgICAgICAgIHZhciBzdG10X2Zyb21fbWRzID0geyBhOiBtZHMuYSwgdGFnOiBcImRlZmluZVwiLCBuYW1lOiBtZHMubmFtZSwgcGFyYW1zOiBtZHMucGFyYW1zLCByZXQ6IG1kcy5yZXQsIGJvZHk6IG1kcy5ib2R5IH07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRjU3RtdChzdG10X2Zyb21fbWRzLCBjbGFzc2VzLCBmdW5jdGlvbnMsIGJvZHl2YXJzLCBtZHMucmV0KTtcbiAgICAgICAgICAgICAgICB2YXIgbWRzX2Zyb21fc3RtdCA9IHsgYTogcmVzdWx0LmEsIG5hbWU6IG1kcy5uYW1lLCBwYXJhbXM6IG1kcy5wYXJhbXMsIHJldDogbWRzLnJldCwgaW5pdHM6IG1kcy5pbml0cywgYm9keTogbWRzLmJvZHkgfTtcbiAgICAgICAgICAgICAgICBuZXdfbWV0aG9kcy5zZXQobmFtZSwgbWRzX2Zyb21fc3RtdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHMubWV0aG9kcyA9IG5ld19tZXRob2RzO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzKSwgeyBhOiBcIm5vbmVcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXhwclwiOiB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdGNFeHByKHMuZXhwciwgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzKSwgeyBleHByOiByZXQsIGE6IHJldC5hIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZXR1cm5cIjoge1xuICAgICAgICAgICAgdmFyIHZhbFR5cCA9IHRjRXhwcihzLnZhbHVlLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoY3VycmVudFJldHVybikpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmV0dXJuID0geyB0YWc6IFwib2JqZWN0XCIsIGNsYXNzOiBTdHJpbmcoY3VycmVudFJldHVybikgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXNzaWduYWJsZVRvKGN1cnJlbnRSZXR1cm4sIHZhbFR5cC5hKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEUgRVJST1I6IFwiLmNvbmNhdCh2YWxUeXAsIFwiIHJldHVybmVkIGJ1dCBcIikuY29uY2F0KGN1cnJlbnRSZXR1cm4sIFwiIGV4cGVjdGVkLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHMpLCB7IHZhbHVlOiB2YWxUeXAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhc3NcIjoge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCBzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaWZcIjoge1xuICAgICAgICAgICAgdmFyIGNvbmQgPSB0Y0V4cHIocy5jb25kLCBjbGFzc2VzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICBpZiAoY29uZC5hICE9IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogXCIuY29uY2F0KGNvbmQsIFwiIG11c3QgYmUgYSBib29sLCBpbnN0ZWFkIGl0IGlzIG5vdyBcIikuY29uY2F0KGNvbmQuYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld19iZF9zdCA9IHMuYm9keS5tYXAoZnVuY3Rpb24gKGJzKSB7IHJldHVybiB0Y1N0bXQoYnMsIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzLCBjdXJyZW50UmV0dXJuKTsgfSk7XG4gICAgICAgICAgICBpZiAocy5lbHNlX2JvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzKSwgeyBjb25kOiBjb25kLCBib2R5OiBuZXdfYmRfc3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3X2Vsc2ViZF9zdCA9IHMuZWxzZV9ib2R5Lm1hcChmdW5jdGlvbiAoYnMpIHsgcmV0dXJuIHRjU3RtdChicywgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMsIGN1cnJlbnRSZXR1cm4pOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHMpLCB7IGNvbmQ6IGNvbmQsIGJvZHk6IG5ld19iZF9zdCwgZWxzZV9ib2R5OiBuZXdfZWxzZWJkX3N0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ3aGlsZVwiOiB7XG4gICAgICAgICAgICB2YXIgY29uZCA9IHRjRXhwcihzLmNvbmQsIGNsYXNzZXMsIGZ1bmN0aW9ucywgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIGlmIChjb25kLmEgIT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFIEVSUk9SOiBcIi5jb25jYXQoY29uZCwgXCIgbXVzdCBiZSBhIGJvb2wsIGluc3RlYWQgaXQgaXMgbm93IFwiKS5jb25jYXQoY29uZC5hKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3X2JkX3N0ID0gcy5ib2R5Lm1hcChmdW5jdGlvbiAoYnMpIHsgcmV0dXJuIHRjU3RtdChicywgY2xhc3NlcywgZnVuY3Rpb25zLCB2YXJpYWJsZXMsIGN1cnJlbnRSZXR1cm4pOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcyksIHsgY29uZDogY29uZCwgYm9keTogbmV3X2JkX3N0IH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy50Y1N0bXQgPSB0Y1N0bXQ7XG5mdW5jdGlvbiB0Y1Byb2dyYW0ocCkge1xuICAgIGNvbnNvbGUubG9nKFwidGNwcm9ncmFtLHBcIiwgcCk7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgY2xhc3NlcyA9IG5ldyBNYXAoKTtcbiAgICBvYmpFbnYgPSBuZXcgTWFwKCk7XG4gICAgcC5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGlmIChzLnRhZyA9PT0gXCJkZWZpbmVcIikge1xuICAgICAgICAgICAgZnVuY3Rpb25zLnNldChzLm5hbWUsIFtzLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudHlwOyB9KSwgcy5yZXRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy50YWcgPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgY2xhc3Nlcy5zZXQocy5uYW1lLCBzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBnbG9iYWxzID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiBwLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICBpZiAocy50YWcgPT09IFwiYXNzaWduXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHNtYXAsIGNoZWNrIGFzc2lnblwiLCBzLnZhbHVlKTtcbiAgICAgICAgICAgIHZhciByaHMgPSB0Y0V4cHIocy52YWx1ZSwgY2xhc3NlcywgZnVuY3Rpb25zLCBnbG9iYWxzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHNtYXAsIHJoczpcIiwgcmhzKTtcbiAgICAgICAgICAgIHZhciB0Y19zID0gdGNTdG10KHMsIGNsYXNzZXMsIGZ1bmN0aW9ucywgZ2xvYmFscywgcmhzLmEpO1xuICAgICAgICAgICAgLy8gZ2xvYmFscy5zZXQocy5uYW1lLCByaHMuYSk7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHMpLCB7IHZhbHVlOiByaHMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gdGNTdG10KHMsIGNsYXNzZXMsIGZ1bmN0aW9ucywgZ2xvYmFscywgXCJub25lXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy50Y1Byb2dyYW0gPSB0Y1Byb2dyYW07XG5mdW5jdGlvbiB0Y0xpdGVyYWwobGl0ZXJhbCkge1xuICAgIHN3aXRjaCAobGl0ZXJhbC50YWcpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBsaXRlcmFsKSwgeyBhOiBcImludFwiIH0pO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBsaXRlcmFsKSwgeyBhOiBcImJvb2xcIiB9KTtcbiAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbGl0ZXJhbCksIHsgYTogXCJub25lXCIgfSk7XG4gICAgfVxufVxuZXhwb3J0cy50Y0xpdGVyYWwgPSB0Y0xpdGVyYWw7XG5mdW5jdGlvbiBpc09iamVjdCh0cCkge1xuICAgIHJldHVybiAhKHRwID09IFwiaW50XCIgfHwgdHAgPT0gXCJib29sXCIgfHwgdHAgPT0gXCJub25lXCIpO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZnVuY3Rpb24gYXNzaWduYWJsZVRvKHR5cGVfYSwgdHlwZV9iKSB7XG4gICAgLy8gUnVsZSBOby4wOiBpZiBzdHJpY3RseSBlcXVhbCwgYWxsb3chXG4gICAgaWYgKHR5cGVfYiA9PT0gdHlwZV9hKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBSdWxlIE5vLjE6IE5vbmUgaXMgYWJsZSB0byBiZSBhc3NpZ25lZCB0byBldmVyeW9uZS5cbiAgICBpZiAodHlwZV9iID09IFwibm9uZVwiKSB7XG4gICAgICAgIC8vIFZlcnkgVHJpY2t5IGhlcmUsbXVzdCBiZSBmaXhlZCBsYXRlclxuICAgICAgICByZXR1cm4gaXNPYmplY3QodHlwZV9hKTtcbiAgICB9XG4gICAgLy8gUnVsZSBObzEuNSBPYmplY3QgaXMgYXNzaWduYWJsZSB0byBOb25lXG4gICAgaWYgKHR5cGVfYSA9PSBcIm5vbmVcIiAmJiBpc09iamVjdCh0eXBlX2IpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBSdWxlIE5vLjI6IE9ubHkgT2JqZWN0IGlzIGFsbG93ZWQgdG8gYXNzaWduIG9iamVjdC5cbiAgICBpZiAodHlwZV9iICE9IFwiaW50XCIgJiYgdHlwZV9iICE9IFwiYm9vbFwiKSB7XG4gICAgICAgIGlmICh0eXBlX2EgIT0gXCJpbnRcIiAmJiB0eXBlX2EgIT0gXCJub25lXCIgJiYgdHlwZV9hICE9IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZV9hLmNsYXNzID09IHR5cGVfYi5jbGFzcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmFzc2lnbmFibGVUbyA9IGFzc2lnbmFibGVUbztcbmZ1bmN0aW9uIENMQVNTKG5hbWUpIHtcbiAgICByZXR1cm4geyB0YWc6IFwib2JqZWN0XCIsIGNsYXNzOiBuYW1lIH07XG59XG5leHBvcnRzLkNMQVNTID0gQ0xBU1M7XG47XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGVyXCIpO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBkaXNwbGF5KGFyZykge1xuICAgICAgICB2YXIgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXRcIikuYXBwZW5kQ2hpbGQoZWx0KTtcbiAgICAgICAgZWx0LmlubmVyVGV4dCA9IGFyZztcbiAgICB9XG4gICAgdmFyIG1lbW9yeSwgaW1wb3J0T2JqZWN0LCBydW5CdXR0b24sIHVzZXJDb2RlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7IGluaXRpYWw6IDEwLCBtYXhpbXVtOiAxMDAgfSk7XG4gICAgICAgIGltcG9ydE9iamVjdCA9IHtcbiAgICAgICAgICAgIGltcG9ydHM6IHtcbiAgICAgICAgICAgICAgICBtZW06IG1lbW9yeSxcbiAgICAgICAgICAgICAgICBwcmludF9udW06IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2dnaW5nIGZyb20gV0FTTTogXCIsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkoU3RyaW5nKGFyZykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpbnRfYm9vbDogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5KFwiRmFsc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5KFwiVHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpbnRfbm9uZTogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5KFwiTm9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBydW5CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJ1blwiKTtcbiAgICAgICAgdXNlckNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInVzZXItY29kZVwiKTtcbiAgICAgICAgcnVuQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb2dyYW0sIG91dHB1dCwgd2F0LCBjb2RlLCByZXN1bHQsIGVfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW0gPSB1c2VyQ29kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheShcIlByb2dyYW0gT3V0cHV0OlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdCA9ICgwLCBjb21waWxlcl8xLmNvbXBpbGUpKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2VuZXJhdGVkLWNvZGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID0gJ0NvZGUgR2VuZXJhdGVkOicgKyB3YXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgY29tcGlsZXJfMS5ydW53YXRzcmMpKHdhdCwgaW1wb3J0T2JqZWN0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb3V0cHV0LnRleHRDb250ZW50ICs9IChTdHJpbmcocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwbGF5KFN0cmluZyhyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yOiBibGFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudGV4dENvbnRlbnQgPSBTdHJpbmcoZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yOiByZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgdXNlckNvZGUudmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInByb2dyYW1cIik7XG4gICAgICAgIHVzZXJDb2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwicHJvZ3JhbVwiLCB1c2VyQ29kZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgIH0pO1xufSk7IH0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB3YWJ0OyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdGlmKF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0pIHtcblx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGVcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi93ZWJzdGFydC50c1wiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=